---
title: Anwenden vereinfachter CQRS- und DDD-Muster in einem Microservice
description: .NET-Microservicearchitektur für .NET-Containeranwendungen | Übersicht über die allgemeine Beziehung zwischen CQRS- und DDD-Mustern
ms.date: 10/08/2018
ms.openlocfilehash: e4e36bafff39f5f30d6371ed7c113322a85c3362
ms.sourcegitcommit: f87ad41b8e62622da126aa928f7640108c4eff98
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/07/2020
ms.locfileid: "80805591"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="4929a-103">Anwenden vereinfachter CQRS- und DDD-Muster in einem Microservice</span><span class="sxs-lookup"><span data-stu-id="4929a-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="4929a-104">CQRS ist ein Architekturkonzept, in dem die Modelle zum Lesen und Schreiben von Daten getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="4929a-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="4929a-105">Der verwandte Begriff [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) wurde ursprünglich von Bertrand Meyer in seinem Buch *Objektorientierte Softwareentwicklung* geprägt.</span><span class="sxs-lookup"><span data-stu-id="4929a-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="4929a-106">Die Grundidee besteht darin, dass die Systemvorgänge in zwei vollständig getrennte Kategorien aufgeteilt werden:</span><span class="sxs-lookup"><span data-stu-id="4929a-106">The basic idea is that you can divide a system's operations into two sharply separated categories:</span></span>

- <span data-ttu-id="4929a-107">Abfragen:</span><span class="sxs-lookup"><span data-stu-id="4929a-107">Queries.</span></span> <span data-ttu-id="4929a-108">Sie geben ein Ergebnis zurück und ändern nicht den Zustand des Systems. Außerdem haben sie keine Nebenwirkungen.</span><span class="sxs-lookup"><span data-stu-id="4929a-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="4929a-109">Befehle:</span><span class="sxs-lookup"><span data-stu-id="4929a-109">Commands.</span></span> <span data-ttu-id="4929a-110">Sie ändern den Zustand eines Systems.</span><span class="sxs-lookup"><span data-stu-id="4929a-110">These change the state of a system.</span></span>

<span data-ttu-id="4929a-111">CQS ist ein einfaches Konzept, in dem die Methoden innerhalb desselben Objekts entweder Abfragen oder Befehle sein können.</span><span class="sxs-lookup"><span data-stu-id="4929a-111">CQS is a simple concept: it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="4929a-112">Jede Methode gibt entweder einen Zustand zurück oder ändert ihn, jedoch nicht beides.</span><span class="sxs-lookup"><span data-stu-id="4929a-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="4929a-113">Selbst ein einzelnes Repositorymusterobjekt kann mit CQS kompatibel sein.</span><span class="sxs-lookup"><span data-stu-id="4929a-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="4929a-114">CQS ist das grundlegende Prinzip von CQRS.</span><span class="sxs-lookup"><span data-stu-id="4929a-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="4929a-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) wurde von Greg Young eingeführt und von Udi Dahan und anderen bekannt gemacht.</span><span class="sxs-lookup"><span data-stu-id="4929a-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="4929a-116">Es basiert auf dem CQS-Prinzip, ist aber detaillierter.</span><span class="sxs-lookup"><span data-stu-id="4929a-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="4929a-117">Dieses Konzept basiert auf Befehlen und Ereignissen sowie optional auf asynchronen Nachrichten.</span><span class="sxs-lookup"><span data-stu-id="4929a-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="4929a-118">Oftmals bezieht sich CQRS auf erweiterte Szenarios, in denen z.B. für Lesevorgänge (Abfragen) und für Schreibvorgänge (Updates) unterschiedliche physische Datenbanken eingesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="4929a-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="4929a-119">Außerdem kann in einem komplexeren CQRS-System [Event Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) für Ihre Updatedatenbank implementiert werden, sodass statt der aktuellen Zustandsdaten nur Ereignisse im Domänenmodell gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="4929a-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="4929a-120">Allerdings wird dieser Ansatz nicht in diesem Leitfaden verwendet.</span><span class="sxs-lookup"><span data-stu-id="4929a-120">However, this approach is not used in this guide.</span></span> <span data-ttu-id="4929a-121">In diesem Leitfaden wird der einfachste CQRS-Ansatz verwendet, bei dem lediglich die Abfragen von den Befehlen getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="4929a-121">This guide uses the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="4929a-122">Die Trennung wird in CQRS erzielt, indem Abfragevorgänge auf einer Ebene und Befehle auf einer anderen gruppiert werden.</span><span class="sxs-lookup"><span data-stu-id="4929a-122">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="4929a-123">Jede Ebene weist ein eigenes Datenmodell auf, das nicht unbedingt einer anderen Datenbank entspricht. Außerdem werden die Ebenen mithilfe eigener Kombinationen von Mustern und Technologien erstellt.</span><span class="sxs-lookup"><span data-stu-id="4929a-123">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="4929a-124">Beide Ebenen können sich sogar innerhalb derselben Ebene oder desselben Microservices befinden, so wie in dem Beispiel (Microservice für Bestellungen) in diesem Handbuch.</span><span class="sxs-lookup"><span data-stu-id="4929a-124">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="4929a-125">Alternativ können sie auch in verschiedenen Microservices oder Prozessen implementiert werden, sodass sie getrennt und ohne Auswirkungen aufeinander optimiert und horizontal hochskaliert werden können.</span><span class="sxs-lookup"><span data-stu-id="4929a-125">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="4929a-126">In CQRS gibt es zwei Objekte für einen Lese-/Schreibvorgang, während es in anderen Kontexten nur eines gibt.</span><span class="sxs-lookup"><span data-stu-id="4929a-126">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="4929a-127">Es gibt gute Gründe für eine nicht normalisierte Datenbank für Lesevorgänge, die Sie in der weiterführenden CQRS-Literatur nachlesen können.</span><span class="sxs-lookup"><span data-stu-id="4929a-127">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="4929a-128">Da unser Ziel darin besteht, die Flexibilität der Abfragen zu erhöhen, statt die Abfragen mit Einschränkungen aus DDD-Mustern wie Aggregaten zu beschränken, wird dieser Ansatz hier jedoch nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="4929a-128">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="4929a-129">Ein Beispiel für diese Art von Dienst ist der Microservice für Bestellungen aus der Referenzanwendung „eShopOnContainers“.</span><span class="sxs-lookup"><span data-stu-id="4929a-129">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="4929a-130">Er basiert auf einem vereinfachten CQRS-Ansatz</span><span class="sxs-lookup"><span data-stu-id="4929a-130">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="4929a-131">und verwendet eine einzelne Datenquelle oder Datenbank, aber zwei logische Modelle sowie DDD-Muster für die Transaktionsdomäne (s. Abbildung 7-2).</span><span class="sxs-lookup"><span data-stu-id="4929a-131">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![Das Diagramm zeigt einen allgemeinen vereinfachten CQRS- und DDD-Microservice.](./media/apply-simplified-microservice-cqrs-ddd-patterns/simplified-cqrs-ddd-microservice.png)

<span data-ttu-id="4929a-133">**Abbildung 7-2**.</span><span class="sxs-lookup"><span data-stu-id="4929a-133">**Figure 7-2**.</span></span> <span data-ttu-id="4929a-134">Vereinfachter auf CQRS und DDD basierender Microservice</span><span class="sxs-lookup"><span data-stu-id="4929a-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="4929a-135">Der logische Microservice für Bestellungen enthält die Datenbank „Ordering“ (Bestellungen), die sich auf demselben Docker-Host befinden kann. Dies ist jedoch nicht zwingend erforderlich.</span><span class="sxs-lookup"><span data-stu-id="4929a-135">The Logical "Ordering" Microservice includes its Ordering database, which can be, but doesn't have to be, the same Docker host.</span></span> <span data-ttu-id="4929a-136">Es eignet sich für die Entwicklung, aber nicht für die Produktion, wenn sich die Datenbank im selben Docker-Host befindet.</span><span class="sxs-lookup"><span data-stu-id="4929a-136">Having the database in the same Docker host is good for development, but not for production.</span></span>

<span data-ttu-id="4929a-137">Die Anwendungsebene kann aus der Web-API selbst bestehen.</span><span class="sxs-lookup"><span data-stu-id="4929a-137">The application layer can be the Web API itself.</span></span> <span data-ttu-id="4929a-138">Das Wichtige am Architekturentwurf ist dabei, dass der Microservice die Abfragen und ViewModels (speziell für die Clientanwendungen erstellte Datenmodelle) nach dem CQRS-Muster von den Befehlen, Domänenmodellen und Transaktionen trennt.</span><span class="sxs-lookup"><span data-stu-id="4929a-138">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="4929a-139">Dadurch bleiben die Abfragen unabhängig von den Einschränkungen der DDD-Muster, die nur für Transaktionen und Updates sinnvoll sind. Dies wird in späteren Abschnitten erläutert.</span><span class="sxs-lookup"><span data-stu-id="4929a-139">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="4929a-140">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="4929a-140">Additional resources</span></span>

- <span data-ttu-id="4929a-141">**Greg Young. Versioning in an Event Sourced System** (Versionsverwaltung in einem System mit Ereignisquelle (kostenloses Online-E-Book)) </span><span class="sxs-lookup"><span data-stu-id="4929a-141">**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book) </span></span>\
   <https://leanpub.com/esversioning/read>

>[!div class="step-by-step"]
><span data-ttu-id="4929a-142">[Zurück](index.md)
>[Weiter](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="4929a-142">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
