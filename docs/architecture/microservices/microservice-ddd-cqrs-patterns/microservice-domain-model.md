---
title: Entwerfen eines Domänenmodells für Microservices
description: .NET-Microservicearchitektur für .NET-Containeranwendungen | Übersicht über die Grundkonzepte beim Entwerfen eines DDD-orientierten Domänenmodells
ms.date: 01/30/2020
ms.openlocfilehash: 234d6e518eac8de5b2f130b91adb32b6a24a7265
ms.sourcegitcommit: ee5b798427f81237a3c23d1fd81fff7fdc21e8d3
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/28/2020
ms.locfileid: "84144590"
---
# <a name="design-a-microservice-domain-model"></a><span data-ttu-id="9b75b-103">Entwerfen eines Microservicedomänenmodells</span><span class="sxs-lookup"><span data-stu-id="9b75b-103">Design a microservice domain model</span></span>

<span data-ttu-id="9b75b-104">*Definieren Sie ein umfassendes Domänenmodell für die einzelnen Unternehmensmicroservices oder begrenzten Kontexte.*</span><span class="sxs-lookup"><span data-stu-id="9b75b-104">*Define one rich domain model for each business microservice or Bounded Context.*</span></span>

<span data-ttu-id="9b75b-105">Ihr Ziel ist die Erstellung eines kohäsiven Domänenmodells für die einzelnen Unternehmensmicroservices oder Kontextgrenzen (Bounded Context, BC).</span><span class="sxs-lookup"><span data-stu-id="9b75b-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="9b75b-106">Beachten Sie aber, dass ein BC oder Unternehmensmicroservice manchmal auch aus mehreren physischen Diensten bestehen kann, die ein einziges Domänenmodell gemeinsam nutzen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="9b75b-107">Das Domänenmodell muss die Regeln, das Verhalten, die Geschäftssprache und Einschränkungen der jeweiligen Kontextgrenzen oder des jeweiligen Unternehmensmicroservices erfassen, die es darstellt.</span><span class="sxs-lookup"><span data-stu-id="9b75b-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="9b75b-108">Das Domänenentitätsmuster</span><span class="sxs-lookup"><span data-stu-id="9b75b-108">The Domain Entity pattern</span></span>

<span data-ttu-id="9b75b-109">Entitäten stellen Domänenobjekte dar. Sie werden nicht nur durch die darin enthaltenen Attribute definiert, sondern primär durch ihre Identität, Kontinuität und Persistenz im Laufe der Zeit.</span><span class="sxs-lookup"><span data-stu-id="9b75b-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="9b75b-110">Eric Evans sagt, dass ein Objekt, das primär durch seine Identität definiert wird, als Entität bezeichnet werde.</span><span class="sxs-lookup"><span data-stu-id="9b75b-110">As Eric Evans says, "an object primarily defined by its identity is called an Entity."</span></span> <span data-ttu-id="9b75b-111">Entitäten sind im Domänenmodell sehr wichtig, da sie die Basis eines Modells darstellen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="9b75b-112">Daher sollten Sie beim Identifizieren und Entwerfen der Entitäten behutsam vorgehen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="9b75b-113">*Die Identität einer Entität kann sich über mehrere Microservices oder Kontextgrenzen erstrecken.*</span><span class="sxs-lookup"><span data-stu-id="9b75b-113">*An entity's identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="9b75b-114">Die gleiche Identität (d.h. der gleiche `Id`-Wert, wenn auch nicht unbedingt die gleiche Domänenentität) kann für mehrere begrenzte Kontexte oder Microservices modelliert werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-114">The same identity (that is, the same `Id` value, although perhaps not the same domain entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="9b75b-115">Dies impliziert jedoch nicht, dass die gleiche Entität mit den gleichen Attributen und der gleichen Logik in mehreren Kontextgrenzen implementiert würde.</span><span class="sxs-lookup"><span data-stu-id="9b75b-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="9b75b-116">Stattdessen begrenzen die Entitäten in den einzelnen Kontextgrenzen ihre Attribute und Verhaltensweisen auf die in der Domäne der Kontextgrenze erforderlichen Attribute und Verhaltensweisen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context's domain.</span></span>

<span data-ttu-id="9b75b-117">Die Entität „Buyer“ (Käufer) enthält z. B. möglicherweise die meisten Attribute für eine Person, die in der Benutzerentität im Microservice „Profile“ (Profil) oder „Identity“ (Identität), einschließlich der Identität, definiert sind.</span><span class="sxs-lookup"><span data-stu-id="9b75b-117">For instance, the buyer entity might have most of a person's attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="9b75b-118">Die Entität „Buyer“ (Käufer) im Microservice „Ordering“ (Bestellung) enthält jedoch möglicherweise weniger Attribute, da sich nur bestimmte Käuferdaten auf den Bestellprozess beziehen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="9b75b-119">Der Kontext der einzelnen Microservices oder Kontextgrenzen hat Auswirkungen auf das zugehörige Domänenmodell.</span><span class="sxs-lookup"><span data-stu-id="9b75b-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="9b75b-120">*Domänenentitäten müssen neben Datenattributen auch Verhaltensweisen implementieren.*</span><span class="sxs-lookup"><span data-stu-id="9b75b-120">*Domain entities must implement behavior in addition to implementing data attributes.*</span></span>

<span data-ttu-id="9b75b-121">Eine Domänenentität in DDD muss die Domänenlogik oder das Verhalten implementieren, die bzw. das sich auf die Entitätsdaten bezieht (das Objekt, auf das im Arbeitsspeicher zugegriffen wird).</span><span class="sxs-lookup"><span data-stu-id="9b75b-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="9b75b-122">Als Teil einer Bestellentitätsklasse müssen beispielsweise eine Geschäftslogik und Vorgänge als Methoden für Aufgaben wie das Hinzufügen eines Bestellartikels, einer Datenvalidierung und einer Gesamtberechnung implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="9b75b-123">Diese Regeln werden nicht auf der Anwendungsschicht verteilt, sondern sind Gegenstand der Entitätsmethoden, die sich auch mit den Invarianten befassen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-123">The entity's methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="9b75b-124">In Abbildung 7-8 wird eine Domänenentität dargestellt, die nicht nur Datenattribute, sondern auch Vorgänge oder Methoden mit verwandter Domänenlogik implementiert.</span><span class="sxs-lookup"><span data-stu-id="9b75b-124">Figure 7-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![Diagramm, das das Muster einer Domänenentität zeigt.](./media/microservice-domain-model/domain-entity-pattern.png)

<span data-ttu-id="9b75b-126">**Abbildung 7-8**.</span><span class="sxs-lookup"><span data-stu-id="9b75b-126">**Figure 7-8**.</span></span> <span data-ttu-id="9b75b-127">Beispiel für den Entwurf einer Domänenentität, die Daten und Verhalten implementiert</span><span class="sxs-lookup"><span data-stu-id="9b75b-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="9b75b-128">Eine Domänenmodellentität implementiert Verhalten durch Methoden, d.h. es handelt sich um kein „anämisches“ Modell.</span><span class="sxs-lookup"><span data-stu-id="9b75b-128">A domain model entity implements behaviors through methods, that is, it's not an "anemic" model.</span></span> <span data-ttu-id="9b75b-129">Manchmal kann es natürlich auch Entitäten geben, die keine Logik als Teil der Entitätsklasse implementieren.</span><span class="sxs-lookup"><span data-stu-id="9b75b-129">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="9b75b-130">Dies kann in untergeordneten Entitäten innerhalb eines Aggregats der Fall sein, wenn die untergeordnete Entität über keine spezielle Logik verfügt, da der Großteil der Logik im Aggregatstamm definiert ist.</span><span class="sxs-lookup"><span data-stu-id="9b75b-130">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="9b75b-131">Wenn Sie über einen komplexen Microservice verfügen, bei dem ein Großteil der Logik in den Dienstklassen und nicht in den Domänenentitäten implementiert ist, könnten Sie in den Bereich des anämischen Domänenmodells fallen, das im folgenden Abschnitt erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="9b75b-131">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="9b75b-132">Umfassendes Domänenmodell im Vergleich zum anämischen Domänenmodell</span><span class="sxs-lookup"><span data-stu-id="9b75b-132">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="9b75b-133">In seinem Beitrag [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html) beschreibt Martin Fowler ein anämisches Domänenmodell wie folgt:</span><span class="sxs-lookup"><span data-stu-id="9b75b-133">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="9b75b-134">Das grundlegende Merkmal eines anämischen Domänenmodells ist, dass es auf den ersten Blick täuschend echt aussieht.</span><span class="sxs-lookup"><span data-stu-id="9b75b-134">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="9b75b-135">Es sind Objekte vorhanden, von denen viele nach den Nomen im Domänenbereich benannt sind, und diese Objekte sind mit den umfassenden Beziehungen und der Struktur eines echten Domänenmodells verbunden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-135">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="9b75b-136">Wenn Sie jedoch das Verhalten betrachten, stellen Sie fest, dass es für diese Objekte kaum Verhaltensweisen gibt, wodurch sie letztlich nur aus Gettern und Settern bestehen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-136">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="9b75b-137">Wenn Sie ein anämisches Domänenmodell verwenden, werden diese Datenmodelle natürlich von einer Reihe von Dienstobjekten verwendet (üblicherweise *Geschäftsebene* genannt), die die gesamte Domänen- oder Geschäftslogik erfassen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-137">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="9b75b-138">Die Geschäftsebene befindet sich oberhalb des Datenmodells und verwendet das Datenmodell nur als Daten.</span><span class="sxs-lookup"><span data-stu-id="9b75b-138">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="9b75b-139">Beim anämischen Domänenmodell handelt es sich nur um einen prozeduralen Formatentwurf.</span><span class="sxs-lookup"><span data-stu-id="9b75b-139">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="9b75b-140">Anämische Entitätsobjekte sind keine echten Objekte, da sie über keine Verhaltensweisen (Methoden) verfügen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-140">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="9b75b-141">Da sie nur Dateneigenschaften enthalten, handelt es sich bei dem Modell um keinen objektorientierten Entwurf.</span><span class="sxs-lookup"><span data-stu-id="9b75b-141">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="9b75b-142">Indem das gesamte Verhalten in Serviceobjekte (die Geschäftsebene) eingefügt wird, verfügen Sie am Ende nur noch über [Spaghetticode](https://en.wikipedia.org/wiki/Spaghetti_code) oder [Transaktionsskripts](https://martinfowler.com/eaaCatalog/transactionScript.html). Dadurch verlieren Sie die Vorteile, die ein Domänenmodell mit sich bringt.</span><span class="sxs-lookup"><span data-stu-id="9b75b-142">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="9b75b-143">Unabhängig davon, ob Ihr Microservice oder Ihre Kontextgrenze sehr einfach ist (ein CRUD-Dienst), ist das anämische Domänenmodell in Form von Entitätsobjekten, die nur Dateneigenschaften enthalten, möglicherweise ausreichend, und möglicherweise wäre das Implementieren komplexerer DDD-Muster nicht sinnvoll.</span><span class="sxs-lookup"><span data-stu-id="9b75b-143">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="9b75b-144">In diesem Fall handelt es sich nur um ein Persistenzmodell, da Sie absichtlich eine Entität erstellt haben, die nur Daten für CRUD-Zwecke enthält.</span><span class="sxs-lookup"><span data-stu-id="9b75b-144">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="9b75b-145">Daher sind Microservicearchitekturen abhängig von den einzelnen Kontextgrenzen perfekt für einen Ansatz mit mehreren Architekturen geeignet.</span><span class="sxs-lookup"><span data-stu-id="9b75b-145">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="9b75b-146">In eShopOnContainers implementiert der Microservice „Ordering“ (Bestellung) beispielsweise DDD-Muster, der Microservice „Catalog“ (Katalog), bei dem es sich um einen einfachen CRUD-Dienst handelt, jedoch nicht.</span><span class="sxs-lookup"><span data-stu-id="9b75b-146">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="9b75b-147">Manche bezeichnen das anämische Domänenmodell als „Antimuster“.</span><span class="sxs-lookup"><span data-stu-id="9b75b-147">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="9b75b-148">Dies hängt wirklich davon ab, was implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="9b75b-148">It really depends on what you are implementing.</span></span> <span data-ttu-id="9b75b-149">Wenn der von Ihnen erstellte Microservice einfach genug ist (z.B. ein CRUD-Dienst), ist er nach dem anämischen Domänenmodell kein Antimuster.</span><span class="sxs-lookup"><span data-stu-id="9b75b-149">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="9b75b-150">Wenn Sie mit der Komplexität der Domäne eines Microservices umgehen müssen, die über zahlreiche, sich ständig ändernde Geschäftsregeln verfügt, stellt das anämische Domänenmodell jedoch möglicherweise ein Antimuster für diesen Microservice oder diese Kontextgrenze dar.</span><span class="sxs-lookup"><span data-stu-id="9b75b-150">However, if you need to tackle the complexity of a microservice's domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="9b75b-151">In diesem Fall könnte es für den langfristigen Erfolg eines solchen Microservice von großem Vorteil sein, wenn das Domänenmodell als umfassendes Modell mit Entitäten entworfen wird, die Daten und Verhaltensweisen enthalten, und wenn zusätzliche DDD-Muster (Aggregate, Wertobjekte usw.) implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-151">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="9b75b-152">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="9b75b-152">Additional resources</span></span>

- <span data-ttu-id="9b75b-153">**DevIQ. Domain Entity (Domänenentität)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-153">**DevIQ. Domain Entity** </span></span>\
  <https://deviq.com/entity/>

- <span data-ttu-id="9b75b-154">**Martin Fowler. The Domain Model (Das Domänenmodell)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-154">**Martin Fowler. The Domain Model** </span></span>\
  <https://martinfowler.com/eaaCatalog/domainModel.html>

- <span data-ttu-id="9b75b-155">**Martin Fowler. Anemic Domain Model (Anämisches Datenmodell)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-155">**Martin Fowler. The Anemic Domain Model** </span></span>\
  <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="9b75b-156">Das Wertobjektmuster</span><span class="sxs-lookup"><span data-stu-id="9b75b-156">The Value Object pattern</span></span>

<span data-ttu-id="9b75b-157">Eric Evans hat festgestellt, dass viele Objekte keine konzeptionelle Identität aufweisen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-157">As Eric Evans has noted, "Many objects do not have conceptual identity.</span></span> <span data-ttu-id="9b75b-158">Diese Objekte beschreiben bestimmte Merkmale einer Komponente.</span><span class="sxs-lookup"><span data-stu-id="9b75b-158">These objects describe certain characteristics of a thing."</span></span>

<span data-ttu-id="9b75b-159">Für eine Entität ist eine Identität erforderlich. Viele Objekte in einem System weisen jedoch keine Identität auf, wie z.B. das Wertobjektmuster.</span><span class="sxs-lookup"><span data-stu-id="9b75b-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="9b75b-160">Ein Wertobjekt ist ein Objekt ohne konzeptionelle Identität, das einen Domänenaspekt beschreibt.</span><span class="sxs-lookup"><span data-stu-id="9b75b-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="9b75b-161">Sie instanziieren diese Objekte, um Entwurfselemente darzustellen, die Sie nur vorübergehend betreffen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="9b75b-162">Für Sie ist wichtig, *was* die Objekte sind, nicht *wer* sie sind.</span><span class="sxs-lookup"><span data-stu-id="9b75b-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="9b75b-163">Zu Beispielen zählen Zahlen und Zeichenfolgen, aber auch Konzepte auf höherer Ebene wie Attributgruppen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="9b75b-164">Eine Entität in einem Microservice ist in einem anderen Microservice möglicherweise keine Entität, da die Kontextgrenze im zweiten Fall unter Umständen eine andere Bedeutung hat.</span><span class="sxs-lookup"><span data-stu-id="9b75b-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="9b75b-165">Eine Adresse in einer E-Commerce-Anwendung hat z. B. möglicherweise gar keine Identität, da sie lediglich eine Gruppe von Attributen aus dem Kundenprofil einer Person oder eines Unternehmens darstellt.</span><span class="sxs-lookup"><span data-stu-id="9b75b-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer's profile for a person or company.</span></span> <span data-ttu-id="9b75b-166">In diesem Fall sollte die Adresse als Wertobjekt klassifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="9b75b-167">In einer Anwendung für ein Stromversorgungsunternehmen könnte die Kundenadresse jedoch wichtig für die Geschäftsdomäne sein.</span><span class="sxs-lookup"><span data-stu-id="9b75b-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="9b75b-168">Daher muss die Adresse über eine Identität verfügen, damit das Abrechnungssystem direkt mit der Adresse verknüpft werden kann.</span><span class="sxs-lookup"><span data-stu-id="9b75b-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="9b75b-169">In diesem Fall sollte eine Adresse als Domänenentität klassifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="9b75b-170">Eine Person mit Namen und Nachnamen ist in der Regel eine Entität, da eine Person eine Identität hat, selbst wenn der Name und Nachname mit anderen Werten übereinstimmen, z.B. wenn sich diese Namen auch auf eine andere Person beziehen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="9b75b-171">Die Verwaltung von Wertobjekten in relationalen Datenbanken und ORMs wie Entity Framework (EF) ist schwierig. In dokumentorientierten Datenbanken können diese einfacher implementiert und verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-171">Value objects are hard to manage in relational databases and ORMs like Entity Framework (EF), whereas in document-oriented databases they are easier to implement and use.</span></span>

<span data-ttu-id="9b75b-172">EF Core 2.0 und neuere Versionen bieten das Feature [Nicht eigenständige Entitäten](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting), das die Verarbeitung von Wertobjekten vereinfacht, wie wir später im Detail sehen werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-172">EF Core 2.0 and later versions include the [Owned Entities](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) feature that makes it easier to handle value objects, as we’ll see in detail later on.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="9b75b-173">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="9b75b-173">Additional resources</span></span>

- <span data-ttu-id="9b75b-174">**Martin Fowler. Value Object pattern (Das Wertobjektmuster)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-174">**Martin Fowler. Value Object pattern** </span></span>\
  <https://martinfowler.com/bliki/ValueObject.html>

- <span data-ttu-id="9b75b-175">**Value Object (Das Wertobjekt)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-175">**Value Object** </span></span>\
  <https://deviq.com/value-object/>

- <span data-ttu-id="9b75b-176">**Value Objects in Test-Driven Development (Wertobjekte in der testgesteuerten Entwicklung)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-176">**Value Objects in Test-Driven Development** </span></span>\
  [https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)

- <span data-ttu-id="9b75b-177">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software. (Domänengesteuertes Design (DDD): Umgang mit Komplexität im Kern einer Software.)**</span><span class="sxs-lookup"><span data-stu-id="9b75b-177">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="9b75b-178">(Buch, das Erläuterungen zu Wertobjekten enthält) </span><span class="sxs-lookup"><span data-stu-id="9b75b-178">(Book; includes a discussion of value objects) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="9b75b-179">Das Aggregatmuster</span><span class="sxs-lookup"><span data-stu-id="9b75b-179">The Aggregate pattern</span></span>

<span data-ttu-id="9b75b-180">Ein Domänenmodell enthält Cluster verschiedener Datenentitäten und Prozesse, die einen wesentlichen Bereich von Funktionen steuern können, z.B. Angebotserfüllung oder Bestand.</span><span class="sxs-lookup"><span data-stu-id="9b75b-180">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfillment or inventory.</span></span> <span data-ttu-id="9b75b-181">Das Aggregat stellt eine differenziertere DDD-Einheit dar und beschreibt ein Cluster oder eine Gruppe mit Entitäten und Verhaltensweisen, die als kohäsive Einheit behandelt werden können.</span><span class="sxs-lookup"><span data-stu-id="9b75b-181">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="9b75b-182">Sie definieren ein Aggregat in der Regel basierend auf den erforderlichen Transaktionen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-182">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="9b75b-183">Ein klassisches Beispiel ist eine Bestellung, die auch eine Liste mit Bestellartikeln umfasst.</span><span class="sxs-lookup"><span data-stu-id="9b75b-183">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="9b75b-184">Ein Bestellartikel ist in der Regel eine Entität.</span><span class="sxs-lookup"><span data-stu-id="9b75b-184">An order item will usually be an entity.</span></span> <span data-ttu-id="9b75b-185">Im Bestellaggregat, das auch die Bestellentität als Stammentität enthält, handelt es sich dabei jedoch um eine untergeordnete Entität, die in der Regel als Aggregatstamm bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="9b75b-185">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="9b75b-186">Das Identifizieren von Aggregaten kann sich als schwierig erweisen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-186">Identifying aggregates can be hard.</span></span> <span data-ttu-id="9b75b-187">Ein Aggregat ist eine Gruppe von Objekten, die zusammen konsistent sein müssen. Sie können aber nicht einfach eine Gruppe von Objekten auswählen und diese als Aggregat bezeichnen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-187">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="9b75b-188">Sie müssen mit einem Domänenkonzept beginnen und die Entitäten berücksichtigen, die in den am häufigsten verwendeten Transaktionen im Zusammenhang mit diesem Konzept verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-188">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="9b75b-189">Diese Entitäten, die im Hinblick auf Transaktionen konsistent sein müssen, bilden ein Aggregat.</span><span class="sxs-lookup"><span data-stu-id="9b75b-189">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="9b75b-190">Die beste Methode zum Identifizieren von Aggregaten ist wahrscheinlich, an Transaktionsvorgänge zu denken.</span><span class="sxs-lookup"><span data-stu-id="9b75b-190">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="9b75b-191">Das Aggregatstamm- oder Stammentitätsmuster</span><span class="sxs-lookup"><span data-stu-id="9b75b-191">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="9b75b-192">Ein Aggregat umfasst mindestens eine Entität: den Aggregatstamm, der auch als Stammentität oder primäre Entität bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="9b75b-192">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="9b75b-193">Darüber hinaus kann es über mehrere untergeordnete Entitäten und Wertobjekte verfügen, wobei alle Entitäten und Objekte zusammenarbeiten, um erforderliche Verhaltensweisen und Transaktionen zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="9b75b-193">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="9b75b-194">Der Zweck eines Aggregatstamms besteht darin, die Konsistenz des Aggregats sicherzustellen. Es sollte der einzige Einstiegspunkt für Updates des Aggregats über Methoden oder Vorgänge in der Aggregatstammklasse sein.</span><span class="sxs-lookup"><span data-stu-id="9b75b-194">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="9b75b-195">Änderungen an Entitäten innerhalb des Aggregats sollten nur über den Aggregatstamm vorgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="9b75b-195">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="9b75b-196">Bei der Konsistenzwächterklausel des Aggregats werden alle Invarianten und Konsistenzregeln berücksichtigt, die Sie in Ihrem Aggregat einhalten müssen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-196">It is the aggregate's consistency guardian, considering all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="9b75b-197">Wenn Sie eine untergeordnete Entität oder ein Wertobjekt unabhängig ändern, kann der Aggregatstamm nicht sicherstellen, dass das Aggregat einen gültigen Status aufweist.</span><span class="sxs-lookup"><span data-stu-id="9b75b-197">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="9b75b-198">Dies wäre vergleichbar mit einem Tisch mit losem Tischbein.</span><span class="sxs-lookup"><span data-stu-id="9b75b-198">It would be like a table with a loose leg.</span></span> <span data-ttu-id="9b75b-199">Der Hauptzweck des Aggregatstamms ist das Wahren der Konsistenz.</span><span class="sxs-lookup"><span data-stu-id="9b75b-199">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="9b75b-200">In Abbildung 7-9 sehen Sie Beispielaggregate wie das Aggregat „Buyer“, das eine einzelne Entität enthält (den Aggregatstamm „Buyer“(Käufer)).</span><span class="sxs-lookup"><span data-stu-id="9b75b-200">In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="9b75b-201">Das Aggregat „Order“ enthält mehrere Entitäten und ein Wertobjekt.</span><span class="sxs-lookup"><span data-stu-id="9b75b-201">The order aggregate contains multiple entities and a value object.</span></span>

![Diagramm, das ein Buyer-Aggregat und ein Order-Aggregat vergleicht.](./media/microservice-domain-model/buyer-order-aggregate-pattern.png)

<span data-ttu-id="9b75b-203">**Abbildung 7-9**.</span><span class="sxs-lookup"><span data-stu-id="9b75b-203">**Figure 7-9**.</span></span> <span data-ttu-id="9b75b-204">Beispiel für Aggregate mit mehreren oder einzelnen Entitäten</span><span class="sxs-lookup"><span data-stu-id="9b75b-204">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="9b75b-205">Ein DDD-Domänenmodell besteht aus Aggregaten. Ein Aggregat kann eine einzige Entität oder mehrere Entitäten sowie auch Wertobjekte beinhalten.</span><span class="sxs-lookup"><span data-stu-id="9b75b-205">A DDD domain model is composed from aggregates, an aggregate can have just one entity or more, and can include value objects as well.</span></span> <span data-ttu-id="9b75b-206">Beachten Sie, dass das Aggregat „Buyer“ (Käufer) über zusätzliche untergeordnete Entitäten verfügen könnte. Dies hängt von Ihrer Domäne ab, wie auch beim Microservice „Ordering“ (Bestellung) in der eShopOnContainers-Referenzanwendung.</span><span class="sxs-lookup"><span data-stu-id="9b75b-206">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="9b75b-207">In Abbildung 7-9 wird ein Fall veranschaulicht, in dem der Käufer über eine einzelne Entität verfügt. Dies ist ein Beispiel für ein Aggregat, das nur einen Aggregatstamm enthält.</span><span class="sxs-lookup"><span data-stu-id="9b75b-207">Figure 7-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="9b75b-208">Es hat sich bewährt, zur Einhaltung der Trennung der Aggregate und für eindeutige Grenzen zwischen den Aggregaten die direkte Navigation zwischen Aggregaten in einem DDD-Domänenmodell nicht zuzulassen und nur über das Feld für den Fremdschlüssel zu verfügen, das im [Domänenmodell des Microservices „Ordering“ (Bestellung)](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers implementiert ist.</span><span class="sxs-lookup"><span data-stu-id="9b75b-208">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="9b75b-209">Die Bestellentität verfügt wie im folgenden Code dargestellt nur über ein Fremdschlüsselfeld für den Käufer, jedoch über keine EF Core-Navigationseigenschaft:</span><span class="sxs-lookup"><span data-stu-id="9b75b-209">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="9b75b-210">Für das Identifizieren von und Arbeiten mit Aggregaten sind Recherchen und Erfahrung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="9b75b-210">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="9b75b-211">Weitere Informationen finden Sie in den folgenden Liste mit Zusatzressourcen.</span><span class="sxs-lookup"><span data-stu-id="9b75b-211">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="9b75b-212">Zusätzliche Ressourcen</span><span class="sxs-lookup"><span data-stu-id="9b75b-212">Additional resources</span></span>

- <span data-ttu-id="9b75b-213">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate (Effektive Aggregatentwicklung, Teil 1: Modellieren eines einzelnen Aggregats)** (von <https://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="9b75b-213">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate** (from <https://dddcommunity.org/>) </span></span>\
  <https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf>

- <span data-ttu-id="9b75b-214">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together (Effektive Aggregatentwicklung Teil II: Kooperation von Aggregaten)** (von <https://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="9b75b-214">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together** (from <https://dddcommunity.org/>) </span></span>\
  <https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf>

- <span data-ttu-id="9b75b-215">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery (Effektive Aggregatentwicklung – Teil III: Gewinnen von Erkenntnissen durch Ermittlung)** (von <https://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="9b75b-215">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery** (from <https://dddcommunity.org/>) </span></span>\
  <https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf>

- <span data-ttu-id="9b75b-216">**Sergey Grybniak. DDD Tactical Design Patterns (Taktische DDD-Entwurfsmuster)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-216">**Sergey Grybniak. DDD Tactical Design Patterns** </span></span>\
  <https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part>

- <span data-ttu-id="9b75b-217">**Chris Richardson. Developing Transactional Microservices Using Aggregates (Entwickeln von Transaktionsmicroservices mit Aggregaten)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-217">**Chris Richardson. Developing Transactional Microservices Using Aggregates** </span></span>\
  <https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson>

- <span data-ttu-id="9b75b-218">**DevIQ. The Aggregate pattern (Das Aggregatmuster)**  </span><span class="sxs-lookup"><span data-stu-id="9b75b-218">**DevIQ. The Aggregate pattern** </span></span>\
  <https://deviq.com/aggregate-pattern/>

>[!div class="step-by-step"]
><span data-ttu-id="9b75b-219">[Zurück](ddd-oriented-microservice.md)
>[Weiter](net-core-microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="9b75b-219">[Previous](ddd-oriented-microservice.md)
[Next](net-core-microservice-domain-model.md)</span></span>
