---
title: where (generischer Typconstraint) – C#-Referenz
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 406c710cd884363c32b98336717732a09b3d1fc1
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/04/2020
ms.locfileid: "84401874"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="0b564-102">where (generischer Typconstraint) (C#-Referenz)</span><span class="sxs-lookup"><span data-stu-id="0b564-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="0b564-103">In einer generischen Typdefinition wird die `where`-Klausel verwendet, um Constraints für Typen anzugeben, die als Argumente für einen Typenparameter in generischen Typen, Methoden, Delegaten oder lokalen Funktionen verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="0b564-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="0b564-104">Constraints können Schnittstellen und Basisklassen angeben oder einen generischen Typ als Verweis-, Wert- oder nicht verwalteten Typ anfordern.</span><span class="sxs-lookup"><span data-stu-id="0b564-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="0b564-105">Sie deklarieren die Funktionen, die das Typargument aufweisen muss.</span><span class="sxs-lookup"><span data-stu-id="0b564-105">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="0b564-106">So können Sie beispielsweise eine generische Klasse erstellen, `MyGenericClass`, deren Typparameter `T` die Schnittstelle <xref:System.IComparable%601> implementiert:</span><span class="sxs-lookup"><span data-stu-id="0b564-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="0b564-107">Weitere Informationen über die where-Klausel in einem Abfrageausdruck finden Sie unter [where-Klausel](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="0b564-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="0b564-108">Die `where`-Klausel kann auch einen Basisklassenconstraint enthalten.</span><span class="sxs-lookup"><span data-stu-id="0b564-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="0b564-109">Der Basisklassenconstraint gibt an, dass ein Typ, der als Typargument für den generischen Typ verwendet wird, über die angegebene Klasse als Basisklasse verfügen oder diese Basisklasse sein muss.</span><span class="sxs-lookup"><span data-stu-id="0b564-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="0b564-110">Wenn ein Basisklassenconstraint verwendet wird, muss er vor jedem anderen Constraint für den Typparameter angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="0b564-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="0b564-111">Einige Typen sind nicht als Basisklassenconstraints zulässig: <xref:System.Object>, <xref:System.Array> und <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="0b564-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="0b564-112">Vor C# 7.3 waren <xref:System.Enum>, <xref:System.Delegate> und <xref:System.MulticastDelegate> ebenfalls nicht als Basisklassenconstraints zulässig.</span><span class="sxs-lookup"><span data-stu-id="0b564-112">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="0b564-113">Das folgende Beispiel zeigt die Typen, die jetzt als Basisklasse angegeben werden können:</span><span class="sxs-lookup"><span data-stu-id="0b564-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="0b564-114">In einem Nullable-Kontext in C# 8.0 und höher wird die NULL-Zulässigkeit des Basisklassentyps erzwungen.</span><span class="sxs-lookup"><span data-stu-id="0b564-114">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="0b564-115">Wenn die Basisklasse ein Non-Nullable-Typ ist (z. B. `Base`), muss das Typargument ein Non-Nullable-Typ sein.</span><span class="sxs-lookup"><span data-stu-id="0b564-115">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="0b564-116">Ist die Basisklasse ein Nullable-Typ (z. B. `Base?`), muss das Typargument ein Nullable- oder Non-Nullable-Verweistyp sein.</span><span class="sxs-lookup"><span data-stu-id="0b564-116">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="0b564-117">Der Compiler gibt eine Warnung aus, wenn das Typargument ein Nullable-Verweistyp ist und die Basisklasse ein Non-Nullable-Typ.</span><span class="sxs-lookup"><span data-stu-id="0b564-117">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="0b564-118">Die `where`-Klausel kann angeben, ob der Typ `class` oder `struct` ist.</span><span class="sxs-lookup"><span data-stu-id="0b564-118">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="0b564-119">Aufgrund des `struct`-Constraints ist die Angabe eines Basisklassenconstraints von `System.ValueType` nicht notwendig.</span><span class="sxs-lookup"><span data-stu-id="0b564-119">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="0b564-120">Der `System.ValueType`-Typ darf nicht als Basisklassenconstraint verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="0b564-120">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="0b564-121">Im folgenden Beispiel werden die `class`- und `struct`-Constraints dargestellt:</span><span class="sxs-lookup"><span data-stu-id="0b564-121">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="0b564-122">In einem Nullable-Kontext in C# 8.0 und höher erfordert der `class`-Constraint einen Non-Nullable-Verweistyp.</span><span class="sxs-lookup"><span data-stu-id="0b564-122">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="0b564-123">Um Nullable-Verweistypen zuzulassen, verwenden Sie den `class?`-Constraint, der sowohl Nullable- als auch Non-Nullable-Verweistypen zulässt.</span><span class="sxs-lookup"><span data-stu-id="0b564-123">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="0b564-124">Die `where`-Klausel kann den `notnull`-Constraint enthalten.</span><span class="sxs-lookup"><span data-stu-id="0b564-124">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="0b564-125">Der `notnull`-Constraint begrenzt den Typparameter auf Nicht-Nullable-Typen.</span><span class="sxs-lookup"><span data-stu-id="0b564-125">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="0b564-126">Bei diesem Typ kann es sich um einen [Werttyp](../builtin-types/value-types.md) oder einen Nicht-Nullable-Verweistyp handeln.</span><span class="sxs-lookup"><span data-stu-id="0b564-126">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="0b564-127">Der `notnull`-Constraint ist ab C  8.0 für Code verfügbar, der in einem [`nullable enable`-Kontext](../../nullable-references.md#nullable-contexts) kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="0b564-127">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="0b564-128">Im Gegensatz zu anderen Constraints generiert der Compiler eine Warnung statt eines Fehlers, wenn ein Typargument den `notnull`-Constraint verletzt.</span><span class="sxs-lookup"><span data-stu-id="0b564-128">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="0b564-129">Warnungen werden nur in einem `nullable enable`-Kontext generiert.</span><span class="sxs-lookup"><span data-stu-id="0b564-129">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0b564-130">Generische Deklarationen, die den `notnull`-Constraint enthalten, können in einem Kontext verwendet werden, in dem nicht bekannt ist, ob NULL-Werte zugelassen sind, aber der Compiler erzwingt den Constraint nicht.</span><span class="sxs-lookup"><span data-stu-id="0b564-130">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="0b564-131">Die `where`-Klausel kann auch einen `unmanaged`-Constraint einschließen.</span><span class="sxs-lookup"><span data-stu-id="0b564-131">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="0b564-132">Der `unmanaged`-Constraint schränkt den Typparameter auf Typen ein, die als [nicht verwaltete Typen](../builtin-types/unmanaged-types.md) bekannt sind.</span><span class="sxs-lookup"><span data-stu-id="0b564-132">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="0b564-133">Der `unmanaged`-Constraint erleichtert das Schreiben von Interop-Code in C# auf niedriger Ebene.</span><span class="sxs-lookup"><span data-stu-id="0b564-133">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="0b564-134">Dieser Constraint ermöglicht wiederverwendbare Routinen für alle nicht verwalteten Typen.</span><span class="sxs-lookup"><span data-stu-id="0b564-134">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="0b564-135">Der `unmanaged`-Constraint kann nicht mit dem `class`- oder `struct`-Constraint kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="0b564-135">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="0b564-136">Der `unmanaged`-Constraint erzwingt, dass der Typ `struct` sein muss:</span><span class="sxs-lookup"><span data-stu-id="0b564-136">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="0b564-137">Die `where`-Klausel kann auch einen `new()`-Konstruktorconstraint einschließen.</span><span class="sxs-lookup"><span data-stu-id="0b564-137">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="0b564-138">Dieser Constraint ermöglicht das Erstellen einer Instanz eines Typparameters unter Verwendung des `new`-Operators.</span><span class="sxs-lookup"><span data-stu-id="0b564-138">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="0b564-139">Der [new()-Constraint](new-constraint.md) informiert den Compiler, dass jedes angegebene Typargument über einen zugänglichen parameterlosen Konstruktor verfügen muss.</span><span class="sxs-lookup"><span data-stu-id="0b564-139">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="0b564-140">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="0b564-140">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="0b564-141">Der `new()`-Constraint wird in der `where`-Klausel als Letztes angezeigt.</span><span class="sxs-lookup"><span data-stu-id="0b564-141">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="0b564-142">Der `new()`-Constraint kann nicht mit dem `struct`- oder `unmanaged`-Constraint kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="0b564-142">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="0b564-143">Alle Typen, die diese Constraints erfüllen, müssen einen zugänglichen parameterlosen Konstruktor aufweisen, wodurch der `new()`-Constraint redundant wird.</span><span class="sxs-lookup"><span data-stu-id="0b564-143">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="0b564-144">Bei mehreren Typparametern müssen Sie für jeden davon eine eigene `where`-Klausel verwenden, z.B.:</span><span class="sxs-lookup"><span data-stu-id="0b564-144">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="0b564-145">Sie können auch Constraints wie folgt an Typparameter generischer Methoden anfügen:</span><span class="sxs-lookup"><span data-stu-id="0b564-145">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="0b564-146">Beachten Sie, dass die Syntax zum Beschreiben der Parameterconstraints für Delegaten mit der Syntax von Methoden identisch ist:</span><span class="sxs-lookup"><span data-stu-id="0b564-146">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="0b564-147">Informationen zu generischen Delegaten finden Sie unter [Generic Delegates (Generische Delegaten)](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="0b564-147">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="0b564-148">Weitere Informationen zur Syntax und der Verwendung von Constraints finden Sie unter [Constraints für Typparameter](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="0b564-148">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="0b564-149">C#-Sprachspezifikation</span><span class="sxs-lookup"><span data-stu-id="0b564-149">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="0b564-150">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="0b564-150">See also</span></span>

- [<span data-ttu-id="0b564-151">C#-Referenz</span><span class="sxs-lookup"><span data-stu-id="0b564-151">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="0b564-152">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="0b564-152">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="0b564-153">Einführung in Generics</span><span class="sxs-lookup"><span data-stu-id="0b564-153">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="0b564-154">new-Constraint</span><span class="sxs-lookup"><span data-stu-id="0b564-154">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="0b564-155">Constraints für Typparameter</span><span class="sxs-lookup"><span data-stu-id="0b564-155">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
