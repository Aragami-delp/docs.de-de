---
title: Ausführen von gruppierten Joins (LINQ in C#)
description: In diesem Artikel erfahren Sie, wie Sie gruppierte Joins mit LINQ in C# ausführen.
ms.date: 04/22/2020
ms.assetid: 9667daf9-a5fd-4b43-a5c4-a9c2b744000e
ms.openlocfilehash: 740a861da7dfb9653a874d5baf67eeb2030555b4
ms.sourcegitcommit: 8b02d42f93adda304246a47f49f6449fc74a3af4
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/24/2020
ms.locfileid: "82135749"
---
# <a name="perform-grouped-joins"></a><span data-ttu-id="7b602-103">Ausführen von Gruppenverknüpfungen</span><span class="sxs-lookup"><span data-stu-id="7b602-103">Perform grouped joins</span></span>

<span data-ttu-id="7b602-104">Die Gruppenverknüpfung ist nützlich für das Erstellen hierarchischer Datenstrukturen.</span><span class="sxs-lookup"><span data-stu-id="7b602-104">The group join is useful for producing hierarchical data structures.</span></span> <span data-ttu-id="7b602-105">Sie verbindet jedes Element aus der ersten Auflistung mit einem Satz von entsprechenden Elementen aus der zweiten Auflistung.</span><span class="sxs-lookup"><span data-stu-id="7b602-105">It pairs each element from the first collection with a set of correlated elements from the second collection.</span></span>

<span data-ttu-id="7b602-106">Eine Klasse oder relationale Datenbanktabelle namens `Student` kann z.B. zwei Felder enthalten: `Id` und `Name`.</span><span class="sxs-lookup"><span data-stu-id="7b602-106">For example, a class or a relational database table named `Student` might contain two fields: `Id` and `Name`.</span></span> <span data-ttu-id="7b602-107">Eine zweite Klasse oder relationale Datenbanktabelle namens `Course` kann zwei Felder enthalten: `StudentId` und `CourseTitle`.</span><span class="sxs-lookup"><span data-stu-id="7b602-107">A second class or relational database table named `Course` might contain two fields: `StudentId` and `CourseTitle`.</span></span> <span data-ttu-id="7b602-108">Eine Gruppenverknüpfung dieser beiden Datenquellen, die auf der übereinstimmenden `Student.Id` und `Course.StudentId` basiert, würde jeden `Student` mit einer Auflistung von `Course`-Objekten gruppieren (die vielleicht leer sind).</span><span class="sxs-lookup"><span data-stu-id="7b602-108">A group join of these two data sources, based on matching `Student.Id` and `Course.StudentId`, would group each `Student` with a collection of `Course` objects (which might be empty).</span></span>

> [!NOTE]
> <span data-ttu-id="7b602-109">Jedes Element der ersten Auflistung erscheint im Ergebnissatz einer Gruppenverknüpfung, unabhängig davon, ob entsprechende Elemente in der zweiten Auflistung gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="7b602-109">Each element of the first collection appears in the result set of a group join regardless of whether correlated elements are found in the second collection.</span></span> <span data-ttu-id="7b602-110">Sollten keine entsprechenden Elemente gefunden werden, ist die Sequenz der entsprechenden Elemente für das Element leer.</span><span class="sxs-lookup"><span data-stu-id="7b602-110">In the case where no correlated elements are found, the sequence of correlated elements for that element is empty.</span></span> <span data-ttu-id="7b602-111">Die Ergebnisauswahl hat daher Zugriff auf jedes Element der ersten Auflistung.</span><span class="sxs-lookup"><span data-stu-id="7b602-111">The result selector therefore has access to every element of the first collection.</span></span> <span data-ttu-id="7b602-112">Dies unterscheidet sich von der Ergebnisauswahl in einer Verknüpfung, bei der keine Gruppen verknüpft werden. Diese kann nicht auf Elemente aus der ersten Auflistung zugreifen, die keine Übereinstimmung in der zweiten Auflistung haben.</span><span class="sxs-lookup"><span data-stu-id="7b602-112">This differs from the result selector in a non-group join, which cannot access elements from the first collection that have no match in the second collection.</span></span>

> [!WARNING]
> <span data-ttu-id="7b602-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> hat keine direkte Entsprechung unter den Begriffen herkömmlicher relationaler Datenbanken.</span><span class="sxs-lookup"><span data-stu-id="7b602-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> has no direct equivalent in traditional relational database terms.</span></span> <span data-ttu-id="7b602-114">Diese Methode implementiert jedoch eine Obermenge innerer Joins und linker äußerer Joins.</span><span class="sxs-lookup"><span data-stu-id="7b602-114">However, this method does implement a superset of inner joins and left outer joins.</span></span> <span data-ttu-id="7b602-115">Beide dieser Vorgänge können im Hinblick auf einen gruppierten Join geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="7b602-115">Both of these operations can be written in terms of a grouped join.</span></span> <span data-ttu-id="7b602-116">Weitere Informationen finden Sie unter [Verknüpfungsvorgänge (C#)](../programming-guide/concepts/linq/join-operations.md) und unter [Entity Framework Core > GroupJoin](https://docs.microsoft.com/ef/core/querying/complex-query-operators#groupjoin).</span><span class="sxs-lookup"><span data-stu-id="7b602-116">For more information, see [Join Operations](../programming-guide/concepts/linq/join-operations.md) and [Entity Framework Core, GroupJoin](https://docs.microsoft.com/ef/core/querying/complex-query-operators#groupjoin).</span></span>

<span data-ttu-id="7b602-117">Im ersten Beispiel in diesem Artikel wird das Ausführen eines gruppierten Joins gezeigt.</span><span class="sxs-lookup"><span data-stu-id="7b602-117">The first example in this article shows you how to perform a group join.</span></span> <span data-ttu-id="7b602-118">Im zweiten Beispiel wird gezeigt, wie eine Gruppenverknüpfung zum Erstellen von XML-Elementen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7b602-118">The second example shows you how to use a group join to create XML elements.</span></span>

## <a name="example---group-join"></a><span data-ttu-id="7b602-119">Beispiel: Gruppierter Join</span><span class="sxs-lookup"><span data-stu-id="7b602-119">Example - Group join</span></span>

<span data-ttu-id="7b602-120">Das folgende Beispiel führt eine Gruppenverknüpfung von Objekten des Typs `Person` und `Pet` aus, die auf der `Person` basiert und mit der `Pet.Owner`-Eigenschaft übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="7b602-120">The following example performs a group join of objects of type `Person` and `Pet` based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="7b602-121">Bei einer Verknüpfung, bei der keine Gruppen verknüpft werden, wird für jede Übereinstimmung ein Elementpaar erzeugt. Im Gegensatz dazu erzeugt eine Gruppenverknüpfung nur ein resultierendes Objekt für jedes Element der ersten Auflistung, was in diesem Beispiel ein `Person`-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="7b602-121">Unlike a non-group join, which would produce a pair of elements for each match, the group join produces only one resulting object for each element of the first collection, which in this example is a `Person` object.</span></span> <span data-ttu-id="7b602-122">Die entsprechenden Elemente aus der zweiten Auflistung, die in diesem Beispiel `Pet`-Objekte sind, werden in einer Auflistung gruppiert.</span><span class="sxs-lookup"><span data-stu-id="7b602-122">The corresponding elements from the second collection, which in this example are `Pet` objects, are grouped into a collection.</span></span> <span data-ttu-id="7b602-123">Die Ergebnisauswahlfunktion erstellt schließlich einen anonymen Typ für jede Übereinstimmung, die aus `Person.FirstName` und einer Auflistung von `Pet`-Objekten besteht.</span><span class="sxs-lookup"><span data-stu-id="7b602-123">Finally, the result selector function creates an anonymous type for each match that consists of `Person.FirstName` and a collection of `Pet` objects.</span></span>

[!code-csharp[CsLINQProgJoining#5](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_1.cs)]

## <a name="example---group-join-to-create-xml"></a><span data-ttu-id="7b602-124">Beispiel: Gruppierter Join zum Erstellen einer XML</span><span class="sxs-lookup"><span data-stu-id="7b602-124">Example - Group join to create XML</span></span>

<span data-ttu-id="7b602-125">Gruppenverknüpfungen lassen sich ideal für das Erstellen von XML mithilfe von LINQ to XML nutzen.</span><span class="sxs-lookup"><span data-stu-id="7b602-125">Group joins are ideal for creating XML by using LINQ to XML.</span></span> <span data-ttu-id="7b602-126">Das folgende Beispiel ähnelt dem vorherigen, nur dass die Ergebnisauswahlfunktion anstatt eines anonymen Typs XML-Elemente erstellt, die die verknüpften Objekte darstellen.</span><span class="sxs-lookup"><span data-stu-id="7b602-126">The following example is similar to the previous example except that instead of creating anonymous types, the result selector function creates XML elements that represent the joined objects.</span></span>

[!code-csharp[CsLINQProgJoining#6](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_2.cs)]

## <a name="see-also"></a><span data-ttu-id="7b602-127">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="7b602-127">See also</span></span>

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [<span data-ttu-id="7b602-128">Ausführen innerer Verknüpfungen</span><span class="sxs-lookup"><span data-stu-id="7b602-128">Perform inner joins</span></span>](perform-inner-joins.md)
- [<span data-ttu-id="7b602-129">Ausführen linker äußerer Verknüpfungen</span><span class="sxs-lookup"><span data-stu-id="7b602-129">Perform left outer joins</span></span>](perform-left-outer-joins.md)
- [<span data-ttu-id="7b602-130">Anonyme Typen</span><span class="sxs-lookup"><span data-stu-id="7b602-130">Anonymous types</span></span>](../programming-guide/classes-and-structs/anonymous-types.md)
