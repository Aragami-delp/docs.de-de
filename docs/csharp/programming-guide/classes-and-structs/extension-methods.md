---
title: Erweiterungsmethoden – C#-Programmierhandbuch
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0f9c0f053e531a44640084a35dc5d8e844ee0b46
ms.sourcegitcommit: 1eae045421d9ea2bfc82aaccfa5b1ff1b8c9e0e4
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/16/2020
ms.locfileid: "84803187"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="d6299-102">Erweiterungsmethoden (C#-Programmierhandbuch)</span><span class="sxs-lookup"><span data-stu-id="d6299-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="d6299-103">Mit Erweiterungsmethoden können Sie vorhandenen Typen Methoden hinzufügen, ohne einen neuen abgeleiteten Typ zu erstellen und ohne den ursprünglichen Typ neu kompilieren oder auf andere Weise bearbeiten zu müssen.</span><span class="sxs-lookup"><span data-stu-id="d6299-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="d6299-104">Erweiterungsmethoden sind statische Methoden, die Sie jedoch wie Instanzmethoden für den erweiterten Typ aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="d6299-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="d6299-105">Für in C#, F# und Visual Basic geschriebenen Clientcode gibt es keinen sichtbaren Unterschied zwischen dem Aufrufen einer Erweiterungsmethode und den in einem Typ definierten Methoden.</span><span class="sxs-lookup"><span data-stu-id="d6299-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="d6299-106">Die häufigsten Erweiterungsmethoden sind die LINQ-Standardabfrageoperatoren, die vorhandenen <xref:System.Collections.IEnumerable?displayProperty=nameWithType>- und <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>-Typen Funktionalität hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="d6299-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="d6299-107">Um die Standardabfrageoperatoren zu verwenden, müssen Sie sie zuerst mit einer `using System.Linq`-Direktive einbinden.</span><span class="sxs-lookup"><span data-stu-id="d6299-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="d6299-108">Jeder Typ, der <xref:System.Collections.Generic.IEnumerable%601> implementiert, scheint Instanzmethoden zu haben, wie z. B. <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6299-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="d6299-109">Sie können diese zusätzlichen Methoden in der IntelliSense-Anweisungsvervollständigung sehen, wenn Sie nach einer Instanz eines <xref:System.Collections.Generic.IEnumerable%601>-Typs, z.B. <xref:System.Collections.Generic.List%601> oder <xref:System.Array>, "dot" eingeben.</span><span class="sxs-lookup"><span data-stu-id="d6299-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="d6299-110">OrderBy-Beispiel</span><span class="sxs-lookup"><span data-stu-id="d6299-110">OrderBy Example</span></span>

<span data-ttu-id="d6299-111">Das folgende Beispiel zeigt, wie Sie die Standardabfrageoperator-Methode `OrderBy` für ein Ganzzahlarray aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="d6299-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="d6299-112">Der Ausdruck in Klammern ist ein Lambda-Ausdruck.</span><span class="sxs-lookup"><span data-stu-id="d6299-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="d6299-113">Viele Standardabfrageoperatoren verwenden Lambda-Ausdrücke als Parameter, dies ist jedoch keine Voraussetzung für Erweiterungsmethoden.</span><span class="sxs-lookup"><span data-stu-id="d6299-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="d6299-114">Weitere Informationen finden Sie unter [Lambdaausdrücke](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="d6299-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="d6299-115">Erweiterungsmethoden werden als statische Methoden definiert, jedoch mithilfe einer Instanzmethodensyntax aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d6299-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="d6299-116">Ihr erster Parameter gibt an, für welchen Typ die Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d6299-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="d6299-117">Dem Parameter wird der [this](../../language-reference/keywords/this.md)-Modifizierer vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="d6299-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="d6299-118">Erweiterungsmethoden befinden sich nur dann im Bereich, wenn Sie den Namespace explizit mit einer `using`-Direktive in Ihren Quellcode importieren.</span><span class="sxs-lookup"><span data-stu-id="d6299-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="d6299-119">Im folgenden Beispiel wird eine für die <xref:System.String?displayProperty=nameWithType>-Klasse definierte Erweiterungsmethode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d6299-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="d6299-120">Die Definition erfolgt in einer nicht geschachtelten, nicht generischen statischen Klasse:</span><span class="sxs-lookup"><span data-stu-id="d6299-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="d6299-121">Die `WordCount`-Erweiterungsmethode kann mit dieser `using`-Direktive eingebunden werden:</span><span class="sxs-lookup"><span data-stu-id="d6299-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="d6299-122">Sie kann darüber hinaus mit dieser Syntax von einer Anwendung aufgerufen werden:</span><span class="sxs-lookup"><span data-stu-id="d6299-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="d6299-123">Sie rufen die Erweiterungsmethode im Code mit Instanzmethodensyntax auf.</span><span class="sxs-lookup"><span data-stu-id="d6299-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="d6299-124">Die vom Compiler erstellte Intermediate Language (IL) übersetzt Ihren Code in einen Aufruf der statischen Methode.</span><span class="sxs-lookup"><span data-stu-id="d6299-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="d6299-125">Es wird nicht wirklich gegen das Prinzip der Kapselung verstoßen.</span><span class="sxs-lookup"><span data-stu-id="d6299-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="d6299-126">Erweiterungsmethoden können nicht auf private Variablen im Typ zugreifen, den sie erweitern.</span><span class="sxs-lookup"><span data-stu-id="d6299-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="d6299-127">Weitere Informationen finden Sie unter [Vorgehensweise: Implementieren und Aufrufen einer benutzerdefinierten Erweiterungsmethode](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="d6299-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="d6299-128">Im Allgemeinen rufen Sie vermutlich sehr viel häufiger Erweiterungsmethoden auf, als eigene Methoden zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="d6299-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="d6299-129">Da Erweiterungsmethoden mit der Instanzmethodensyntax aufgerufen werden, sind für ihren Einsatz aus dem Clientcode keine besonderen Kenntnisse erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d6299-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="d6299-130">Um Erweiterungsmethoden für einen bestimmten Typ zu aktivieren, fügen Sie eine `using`-Direktive für den Namespace, in dem die Methoden definiert werden, hinzu.</span><span class="sxs-lookup"><span data-stu-id="d6299-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="d6299-131">Um beispielsweise die Standardabfrageoperatoren zu verwenden, fügen Sie diese `using`-Direktive dem Code hinzu:</span><span class="sxs-lookup"><span data-stu-id="d6299-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="d6299-132">(Möglicherweise müssen Sie auch einen Verweis auf System.Core.dll hinzufügen.) Wie Sie sehen, werden die Standardabfrageoperatoren in IntelliSense jetzt für die meisten <xref:System.Collections.Generic.IEnumerable%601>-Typen als zusätzliche Methoden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d6299-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="d6299-133">Binden von Erweiterungsmethoden während der Kompilierung</span><span class="sxs-lookup"><span data-stu-id="d6299-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="d6299-134">Sie können Erweiterungsmethoden verwenden, um eine Klasse oder eine Schnittstelle zu erweitern, jedoch nicht, um sie zu überschreiben.</span><span class="sxs-lookup"><span data-stu-id="d6299-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="d6299-135">Eine Erweiterungsmethode mit dem gleichen Namen und der gleichen Signatur wie eine Schnittstellen- oder Klassenmethode wird nie aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d6299-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="d6299-136">Bei der Kompilierung verfügen Erweiterungsmethoden immer über niedrigere Priorität als im Typ selbst definierte Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="d6299-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="d6299-137">Das heißt, wenn ein Typ eine Methode mit dem Namen `Process(int i)` hat und Sie über eine Erweiterungsmethode mit der gleichen Signatur verfügen, stellt der Compiler immer eine Bindung mit der Instanzmethode her.</span><span class="sxs-lookup"><span data-stu-id="d6299-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="d6299-138">Wenn der Compiler einen Methodenaufruf erkennt, sucht er zuerst nach einer Entsprechung in den Instanzmethoden des Typs.</span><span class="sxs-lookup"><span data-stu-id="d6299-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="d6299-139">Wenn keine Entsprechung gefunden wird, sucht er nach Erweiterungsmethoden, die für den Typ definiert wurden, und stellt eine Bindung mit der ersten gefundenen Erweiterungsmethode her.</span><span class="sxs-lookup"><span data-stu-id="d6299-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="d6299-140">Im folgenden Beispiel wird veranschaulicht, wie der Compiler bestimmt, mit welcher Erweiterungsmethode oder Instanzmethode die Bindung erfolgen soll.</span><span class="sxs-lookup"><span data-stu-id="d6299-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="d6299-141">Beispiel</span><span class="sxs-lookup"><span data-stu-id="d6299-141">Example</span></span>

<span data-ttu-id="d6299-142">Das folgende Beispiel veranschaulicht die Regeln, denen der C#-Compiler folgt, um zu bestimmen, ob ein Methodenaufruf an eine Instanzmethode für den Typ oder an eine Erweiterungsmethode gebunden werden soll.</span><span class="sxs-lookup"><span data-stu-id="d6299-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="d6299-143">Die statische Klasse `Extensions` enthält Erweiterungsmethoden, die für jeden Typ definiert wurden, der `IMyInterface` implementiert.</span><span class="sxs-lookup"><span data-stu-id="d6299-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="d6299-144">Die Klassen `A`, `B` und `C` implementieren alle die Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d6299-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="d6299-145">Die `MethodB`-Erweiterungsmethode wird nie aufgerufen, da ihr Name und die Signatur genau mit Methoden übereinstimmen, die bereits von den Klassen implementiert wurden.</span><span class="sxs-lookup"><span data-stu-id="d6299-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="d6299-146">Wenn der Compiler keine Instanzmethode mit einer entsprechenden Signatur findet, stellt er eine Bindung mit einer entsprechenden Erweiterungsmethode her (sofern vorhanden).</span><span class="sxs-lookup"><span data-stu-id="d6299-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="d6299-147">Gängige Verwendungsmuster</span><span class="sxs-lookup"><span data-stu-id="d6299-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="d6299-148">Auflistungsfunktionen</span><span class="sxs-lookup"><span data-stu-id="d6299-148">Collection Functionality</span></span>

<span data-ttu-id="d6299-149">In der Vergangenheit war es üblich, „Sammlungsklassen“ zu erstellen, mit denen die <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>-Schnittstelle für einen bestimmten Typ implementiert und Funktionalität für Sammlungen dieses Typs bereitgestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="d6299-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="d6299-150">Es ist zwar nichts Falsches daran, diese Art von Sammlungsobjekten zu erstellen, aber die gleiche Funktionalität kann durch eine Erweiterung von <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="d6299-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d6299-151">Erweiterungen haben den Vorteil, dass die Funktionalität aus einer beliebigen Sammlung – z. B. <xref:System.Array?displayProperty=nameWithType> oder <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> – aufgerufen werden kann, die <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> für diesen Typ implementiert.</span><span class="sxs-lookup"><span data-stu-id="d6299-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="d6299-152">Ein entsprechendes Beispiel mit Verwendung eines Int32-Arrays finden Sie [weiter oben in diesem Artikel](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="d6299-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="d6299-153">Ebenenspezifische Funktionalität</span><span class="sxs-lookup"><span data-stu-id="d6299-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="d6299-154">Bei Verwendung einer Zwiebelarchitektur oder eines anderen geschichteten Anwendungsdesigns ist es üblich, einen Satz mit Domänenentitäten oder Datenübertragungsobjekten für die Kommunikation über Anwendungsgrenzen hinweg zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="d6299-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="d6299-155">Diese Objekte umfassen in der Regel keine oder nur minimale Funktionalität, die für alle Ebenen der Anwendung gilt.</span><span class="sxs-lookup"><span data-stu-id="d6299-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="d6299-156">Erweiterungsmethoden können verwendet werden, um Funktionalität hinzuzufügen, die für jede Anwendungsschicht spezifisch ist, ohne das Objekt mit Methoden zu überladen, die in anderen Ebenen nicht benötigt werden oder unerwünscht sind.</span><span class="sxs-lookup"><span data-stu-id="d6299-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="d6299-157">Erweiterung von vordefinierten Typen</span><span class="sxs-lookup"><span data-stu-id="d6299-157">Extending Predefined Types</span></span>

<span data-ttu-id="d6299-158">Wenn wiederverwendbare Funktionalität erstellt werden muss, kann statt der Erstellung neuer Objekte häufig ein bereits vorhandener Typ erweitert werden, z. B. ein .NET- oder CLR-Typ.</span><span class="sxs-lookup"><span data-stu-id="d6299-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="d6299-159">Wenn beispielsweise keine Erweiterungsmethoden verwendet werden, könnten wir eine `Engine`- oder `Query`-Klasse zum Ausführen einer Abfrage auf einer SQL Server-Instanz erstellen, die über mehrere Stellen in unserem Code aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="d6299-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="d6299-160">Stattdessen können wir jedoch die Klasse <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> mithilfe von Erweiterungsmethoden erweitern, damit diese Abfrage von jedem beliebigen Ort ausgeführt werden kann, an dem eine Verbindung mit einer SQL Server-Instanz vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d6299-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="d6299-161">Weitere Beispiele wären das Hinzufügen gemeinsamer Funktionalität zur Klasse <xref:System.String?displayProperty=nameWithType>, eine Erweiterung der Datenverarbeitungsfunktionalität der Objekte <xref:System.IO.File?displayProperty=nameWithType> und <xref:System.IO.Stream?displayProperty=nameWithType> sowie <xref:System.Exception?displayProperty=nameWithType>-Objekte für eine spezifische Fehlerbehandlungsfunktionalität.</span><span class="sxs-lookup"><span data-stu-id="d6299-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="d6299-162">Der Verwendung dieser Anwendungsfälle sind praktisch keine Grenzen gesetzt.</span><span class="sxs-lookup"><span data-stu-id="d6299-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="d6299-163">Das Erweitern vordefinierter Typen kann bei `struct`-Typen schwierig sein, da sie als Wert an Methoden übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="d6299-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="d6299-164">Dies bedeutet, dass alle Änderungen an der Struktur an einer Kopie der Struktur vorgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="d6299-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="d6299-165">Diese Änderungen sind nicht sichtbar, nachdem die Erweiterungsmethode beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d6299-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="d6299-166">Ab C# 7.2 können Sie dem ersten Argument einer Erweiterungsmethode den `ref`-Modifizierer hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="d6299-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="d6299-167">Durch das Hinzufügen des `ref`-Modifizierers wird das erste Argument als Verweis übergeben.</span><span class="sxs-lookup"><span data-stu-id="d6299-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="d6299-168">Auf diese Weise können Sie Erweiterungsmethoden schreiben, die den Status der erweiterten Struktur ändern.</span><span class="sxs-lookup"><span data-stu-id="d6299-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="d6299-169">Allgemeine Richtlinien</span><span class="sxs-lookup"><span data-stu-id="d6299-169">General Guidelines</span></span>

<span data-ttu-id="d6299-170">Wenngleich es weiterhin vorzuziehen ist, Funktionalität durch Änderung des Codes eines Objekts oder durch Ableitung eines neuen Typs hinzuzufügen – sofern dies sinnvoll und möglich ist –, sind Erweiterungsmethoden zu einer wichtigen Option zum Bereitstellen wiederverwendbarer Funktionalität im gesamten .NET-Ökosystem geworden.</span><span class="sxs-lookup"><span data-stu-id="d6299-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="d6299-171">In Fällen, in denen die ursprüngliche Quelle nicht Ihrer Kontrolle unterliegt, ein abgeleitetes Objekt ungeeignet ist oder nicht verwendet werden kann oder die Funktionalität nicht über den anwendbaren Bereich hinaus offengelegt werden soll, stellen Erweiterungsmethoden eine ausgezeichnete Wahl dar.</span><span class="sxs-lookup"><span data-stu-id="d6299-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="d6299-172">Weitere Informationen zu abgeleiteten Typen finden Sie unter [Vererbung](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="d6299-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="d6299-173">Wenn Sie eine Erweiterungsmethode zum Erweitern eines Typs verwenden, dessen Quellcode Sie nicht ändern können, laufen Sie Gefahr, dass eine Änderung an der Implementierung des Typs zu einer Beschädigung Ihrer Erweiterungsmethode führt.</span><span class="sxs-lookup"><span data-stu-id="d6299-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="d6299-174">Wenn Sie Erweiterungsmethoden für einen gegebenen Typ implementieren, beachten Sie die folgenden Punkte:</span><span class="sxs-lookup"><span data-stu-id="d6299-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="d6299-175">Eine Erweiterungsmethode wird nie aufgerufen, wenn sie die gleiche Signatur wie eine im Typ definierte Methode hat.</span><span class="sxs-lookup"><span data-stu-id="d6299-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="d6299-176">Erweiterungsmethoden werden auf Namespace-Ebene eingebunden.</span><span class="sxs-lookup"><span data-stu-id="d6299-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="d6299-177">Wenn Sie z. B. über mehrere statische Klassen verfügen, die Erweiterungsmethoden in einem einzelnen Namespace mit dem Namen `Extensions` enthalten, werden sie alle mit der `using Extensions;`-Direktive eingebunden.</span><span class="sxs-lookup"><span data-stu-id="d6299-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="d6299-178">Für eine Klassenbibliothek, die Sie implementiert haben, sollten Sie keine Erweiterungsmethoden verwenden, um zu vermeiden, dass die Versionsnummer einer Assembly erhöht wird.</span><span class="sxs-lookup"><span data-stu-id="d6299-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="d6299-179">Wenn Sie zu einer Bibliothek, deren Quellcode Sie besitzen, wichtige Funktionalität hinzufügen möchten, befolgen Sie die .NET-Richtlinien für Assemblyversionierung.</span><span class="sxs-lookup"><span data-stu-id="d6299-179">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="d6299-180">Weitere Informationen dazu finden Sie unter [Assemblyversionen](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="d6299-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="d6299-181">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="d6299-181">See also</span></span>

- [<span data-ttu-id="d6299-182">C#-Programmierhandbuch</span><span class="sxs-lookup"><span data-stu-id="d6299-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="d6299-183">Parallel Programming Samples (Beispiele für parallele Programmierung (dazu gehören viele Beispielerweiterungsmethoden))</span><span class="sxs-lookup"><span data-stu-id="d6299-183">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="d6299-184">Lambda-Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="d6299-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="d6299-185">Übersicht über Standardabfrageoperatoren</span><span class="sxs-lookup"><span data-stu-id="d6299-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="d6299-186">Conversion rules for Instance parameters and their impact (Konvertierungsregeln für Instanzenparameter und ihre Auswirkungen)</span><span class="sxs-lookup"><span data-stu-id="d6299-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="d6299-187">Extension methods Interoperability between languages (Erweiterungsmethoden-Interoperabilität zwischen Sprachen)</span><span class="sxs-lookup"><span data-stu-id="d6299-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="d6299-188">Extension methods and Curried Delegates (Erweiterungsmethoden und Curry-Delegaten)</span><span class="sxs-lookup"><span data-stu-id="d6299-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="d6299-189">Extension method Binding and Error reporting (Binden von Erweiterungsmethoden und Problemberichten)</span><span class="sxs-lookup"><span data-stu-id="d6299-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
