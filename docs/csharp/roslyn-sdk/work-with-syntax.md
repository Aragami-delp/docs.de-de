---
title: Verwenden des .NET Compiler Platform SDK-Syntaxmodells
description: Diese Übersicht bietet einen Überblick über die Typen, die Sie zum Verstehen und Bearbeiten von Syntaxknoten verwenden.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fdb13095c2b91e54d58988a51a51b05652e57ea6
ms.sourcegitcommit: 488aced39b5f374bc0a139a4993616a54d15baf0
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/12/2020
ms.locfileid: "83208394"
---
# <a name="work-with-syntax"></a><span data-ttu-id="37833-103">Arbeiten mit der Syntax</span><span class="sxs-lookup"><span data-stu-id="37833-103">Work with syntax</span></span>

<span data-ttu-id="37833-104">Die *Syntaxstruktur* ist eine grundlegende Datenstruktur, die von Compiler-APIs verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="37833-104">The *syntax tree* is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="37833-105">Diese Strukturen stellen die lexikalische und syntaktische Struktur des Quellcodes dar.</span><span class="sxs-lookup"><span data-stu-id="37833-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="37833-106">Sie erfüllen zwei wichtige Aufgaben:</span><span class="sxs-lookup"><span data-stu-id="37833-106">They serve two important purposes:</span></span>

- <span data-ttu-id="37833-107">Damit Tools wie zum Beispiel eine IDE, Add-Ins, Codeanalysetools und Refactorings die syntaktische Struktur von Quellcode in dem Projekt eines Benutzers anzeigen und verarbeiten können.</span><span class="sxs-lookup"><span data-stu-id="37833-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user's project.</span></span>
- <span data-ttu-id="37833-108">Damit Tools wie zum Beispiel Refactorings und eine IDE ermöglicht wird, Quellcode auf natürliche Weise zu erstellen, zu ändern und neu anzuordnen, ohne den Text direkt zu bearbeiten.</span><span class="sxs-lookup"><span data-stu-id="37833-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having to use direct text edits.</span></span> <span data-ttu-id="37833-109">Durch Erstellen und Bearbeiten von Strukturen können Tools einfach Quellcode erstellen und neu anordnen.</span><span class="sxs-lookup"><span data-stu-id="37833-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="37833-110">Syntaxstrukturen</span><span class="sxs-lookup"><span data-stu-id="37833-110">Syntax trees</span></span>

<span data-ttu-id="37833-111">Syntaxstrukturen sind die primär verwendete Struktur für Kompilierung, Codeanalyse, Bindung, Refactoring, IDE-Funktionen und Codegenerierung.</span><span class="sxs-lookup"><span data-stu-id="37833-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="37833-112">Kein Teil des Quellcodes kann verstanden werden, ohne zunächst als eines von vielen bekannten strukturellen Sprachelementen identifiziert und kategorisiert worden zu sein.</span><span class="sxs-lookup"><span data-stu-id="37833-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="37833-113">Syntaxstrukturen verfügen über drei wichtige Attribute.</span><span class="sxs-lookup"><span data-stu-id="37833-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="37833-114">Das erste Attribut ist, dass Syntaxstrukturen alle Quellinformationen in voller Genauigkeit enthalten.</span><span class="sxs-lookup"><span data-stu-id="37833-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="37833-115">Volle Genauigkeit bedeutet: Die Syntaxstruktur enthält jede Information aus dem Quelltext, jedes grammatische Konstrukt, jedes lexikalische Token und alles, was dazwischen liegt – einschließlich Leerzeichen, Kommentaren und Präprozessordirektiven.</span><span class="sxs-lookup"><span data-stu-id="37833-115">Full fidelity means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="37833-116">Zum Beispiel wird jedes Literal, das in der Quelle erwähnt wird, so dargestellt, wie es eingegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="37833-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="37833-117">Syntaxstrukturen erfassen auch Fehler im Quellcode, wenn das Programm unvollständig oder falsch formatiert ist, indem übersprungene oder fehlende Token angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="37833-117">Syntax trees also capture errors in source code when the program is incomplete or malformed by representing skipped or missing tokens.</span></span>

<span data-ttu-id="37833-118">Das zweite Attribut von Syntaxstrukturen ist, dass sie den exakten Text, aus dem sie analysiert wurden, produzieren können.</span><span class="sxs-lookup"><span data-stu-id="37833-118">The second attribute of syntax trees is that they can produce the exact text that they were parsed from.</span></span> <span data-ttu-id="37833-119">Es ist möglich, die im Knoten verankerte Textdarstellung der Teilstruktur aus einem beliebigen Syntaxknoten zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="37833-119">From any syntax node, it's possible to get the text representation of the subtree rooted at that node.</span></span> <span data-ttu-id="37833-120">Diese Fähigkeit bedeutet, dass Syntaxstrukturen verwendet werden können, um Quelltext zu erstellen und zu bearbeiten.</span><span class="sxs-lookup"><span data-stu-id="37833-120">This ability means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="37833-121">Durch das Erstellen einer Struktur erstellen Sie gleichzeitig auch den entsprechenden Text, und durch das Bearbeiten einer Syntaxstruktur (d. h. das Erstellen einer neuen Struktur durch das Ändern einer vorhandenen Struktur) nehmen Sie Änderungen am Text vor.</span><span class="sxs-lookup"><span data-stu-id="37833-121">By creating a tree you have, by implication, created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="37833-122">Das dritte Attribut von Syntaxstrukturen ist, dass sie unveränderlich und threadsicher sind.</span><span class="sxs-lookup"><span data-stu-id="37833-122">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span> <span data-ttu-id="37833-123">Nach dem Erstellen ist eine Struktur eine Momentaufnahme des aktuellen Zustands des Codes, die sich nie ändert.</span><span class="sxs-lookup"><span data-stu-id="37833-123">After a tree is obtained, it's a snapshot of the current state of the code and never changes.</span></span> <span data-ttu-id="37833-124">Dadurch können mehrere Benutzer gleichzeitig mit der selben Syntaxstruktur in verschiedenen Threads interagieren, ohne etwas sperren oder duplizieren zu müssen.</span><span class="sxs-lookup"><span data-stu-id="37833-124">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="37833-125">Da Strukturen unveränderlich sind, und keine direkten Änderungen an ihnen vorgenommen werden können, sind Factorymethoden hilfreich beim Erstellen und Bearbeiten von Syntaxstrukturen, weil sie zusätzliche Momentaufnahmen von der Struktur erstellen.</span><span class="sxs-lookup"><span data-stu-id="37833-125">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="37833-126">Strukturen sind bei der Wiederverwendung von grundlegenden Knoten effizient, weshalb eine neue Version schnell und mit geringem zusätzlichem Speicherplatz neu erstellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="37833-126">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="37833-127">Eine Syntaxstruktur ist eine Datenstruktur, in der nichtterminale Strukturelemente anderen Elementen übergeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="37833-127">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="37833-128">Jede Syntaxstruktur besteht aus Knoten, Token und Trivia.</span><span class="sxs-lookup"><span data-stu-id="37833-128">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="37833-129">Syntaxknoten</span><span class="sxs-lookup"><span data-stu-id="37833-129">Syntax nodes</span></span>

<span data-ttu-id="37833-130">Syntaxknoten gehören zu den Hauptelementen der Syntaxstrukturen.</span><span class="sxs-lookup"><span data-stu-id="37833-130">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="37833-131">Diese Knoten stellen Syntaxkonstrukte wie Deklarationen, Anweisungen, Klauseln und Ausdrücke dar.</span><span class="sxs-lookup"><span data-stu-id="37833-131">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="37833-132">Jede Kategorie der Syntaxknoten wird durch eine separate Klasse dargestellt, die von <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="37833-132">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="37833-133">Die Anzahl von Knotenklassen ist nicht erweiterbar.</span><span class="sxs-lookup"><span data-stu-id="37833-133">The set of node classes is not extensible.</span></span>

<span data-ttu-id="37833-134">Alle Syntaxknoten sind nichtterminale Knoten in der Syntaxstruktur, was bedeutet, dass ihnen immer andere Knoten und Token untergeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="37833-134">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="37833-135">Als untergeordnetes Element eines anderen Knotens hat jeder Knoten einen übergeordneten Knoten, auf den mit der Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="37833-135">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="37833-136">Da Knoten und Strukturen unveränderlich sind, ändert sich das übergeordnete Element eines Knotens nie.</span><span class="sxs-lookup"><span data-stu-id="37833-136">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="37833-137">Das übergeordnete Element des Stamms der Struktur ist NULL.</span><span class="sxs-lookup"><span data-stu-id="37833-137">The root of the tree has a null parent.</span></span>

<span data-ttu-id="37833-138">Jeder Knoten verfügt über die Methode <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType>, die die untergeordneten Knoten sequenziell, je nach ihrer Position im Quelltext, auflistet.</span><span class="sxs-lookup"><span data-stu-id="37833-138">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="37833-139">Diese Auflistung enthält keine Token.</span><span class="sxs-lookup"><span data-stu-id="37833-139">This list does not contain tokens.</span></span> <span data-ttu-id="37833-140">Alle Knoten verfügen auch über Methoden zum Untersuchen von Nachfolgern, wie <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> oder <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A>, die eine Liste aller Knoten, Token oder Trivia darstellen, die in der Unterstruktur vorhanden sind, die von dem Knoten abstammt.</span><span class="sxs-lookup"><span data-stu-id="37833-140">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the subtree rooted by that node.</span></span>

<span data-ttu-id="37833-141">Darüber hinaus macht jede Unterklasse der Syntaxknoten alle identischen untergeordneten Elemente durch stark typisierte Eigenschaften verfügbar.</span><span class="sxs-lookup"><span data-stu-id="37833-141">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="37833-142">Zum Beispiel verfügt eine Knotenklasse <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> über drei zusätzliche Eigenschaften, die auf binäre Operatoren beschränkt sind: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> und <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="37833-142">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="37833-143">Der Typ von <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> und <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> ist <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, und der Typ von <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> ist <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="37833-143">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="37833-144">Einige Syntaxknoten haben optionale untergeordnete Elemente.</span><span class="sxs-lookup"><span data-stu-id="37833-144">Some syntax nodes have optional children.</span></span> <span data-ttu-id="37833-145">Zum Beispiel hat <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> ein optionales <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="37833-145">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="37833-146">Die Eigenschaft gibt NULL zurück, wenn das untergeordnete Element nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="37833-146">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="37833-147">Syntaxtoken</span><span class="sxs-lookup"><span data-stu-id="37833-147">Syntax tokens</span></span>

<span data-ttu-id="37833-148">Syntaxtoken sind terminale Elemente der Grammatik und repräsentieren die kleinsten syntaktischen Elemente des Codes.</span><span class="sxs-lookup"><span data-stu-id="37833-148">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="37833-149">Sie sind nie übergeordnete Elemente von anderen Knoten oder Token.</span><span class="sxs-lookup"><span data-stu-id="37833-149">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="37833-150">Syntaxtoken bestehen aus Schlüsselwörtern, Bezeichnern, Literalen und Interpunktion.</span><span class="sxs-lookup"><span data-stu-id="37833-150">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="37833-151">Der Typ <xref:Microsoft.CodeAnalysis.SyntaxToken> ist zugunsten der Effizienz ein CLR-Werttyp.</span><span class="sxs-lookup"><span data-stu-id="37833-151">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="37833-152">Im Gegensatz zu Syntaxknoten gibt es deshalb nur eine Struktur für alle Arten von Token mit verschiedenen Eigenschaften, deren Bedeutung von der Art des dargestellten Tokens abhängt.</span><span class="sxs-lookup"><span data-stu-id="37833-152">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="37833-153">Zum Beispiel stellt ein Token für ein Integer-Literal einen numerischen Wert dar.</span><span class="sxs-lookup"><span data-stu-id="37833-153">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="37833-154">Zusätzlich zu dem unformatierten Quelltext den das Token umfasst, verfügt das Literal-Token über eine <xref:Microsoft.CodeAnalysis.SyntaxToken.Value>-Eigenschaft, die den genauen Ganzzahlwert dekodiert angibt.</span><span class="sxs-lookup"><span data-stu-id="37833-154">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="37833-155">Diese Eigenschaft wird mit <xref:System.Object> typisiert, weil sie eine von vielen primitiven Typen sein kann.</span><span class="sxs-lookup"><span data-stu-id="37833-155">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="37833-156">Die Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> gibt die selben Informationen an wie die Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> an, sie wird jedoch immer als <xref:System.String> typisiert.</span><span class="sxs-lookup"><span data-stu-id="37833-156">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="37833-157">Ein Bezeichner in einem C#-Quelltext kann Escapezeichen in Unicode enthalten, aber die Syntax der Escapesequenz selbst zählt nicht als Teil des Namens des Bezeichners.</span><span class="sxs-lookup"><span data-stu-id="37833-157">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="37833-158">Obwohl der unformatierte Text, den das Token umfasst, die Escapesequenz einschließt, tut die Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> das nicht.</span><span class="sxs-lookup"><span data-stu-id="37833-158">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="37833-159">Stattdessen enthält sie die Unicode-Zeichen, die von dem Escapezeichen identifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="37833-159">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="37833-160">Wenn der Quelltext zum Beispiel einen Bezeichner enthält, der als `\u03C0` geschrieben wird, dann gibt die Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> dieses Tokens `π` zurück.</span><span class="sxs-lookup"><span data-stu-id="37833-160">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="37833-161">Syntaxtrivia</span><span class="sxs-lookup"><span data-stu-id="37833-161">Syntax trivia</span></span>

<span data-ttu-id="37833-162">Syntaxtrivia stellen hauptsächlich die Bestandteile des Quelltexts dar, die für das normale Verständnis des Codes nicht wichtig sind, z.B. Leerzeichen, Kommentare und Präprozessordirektiven.</span><span class="sxs-lookup"><span data-stu-id="37833-162">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="37833-163">Syntaxtrivia sind, wie Syntaxtoken, Werttypen.</span><span class="sxs-lookup"><span data-stu-id="37833-163">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="37833-164">Der einzelne Typ <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> wird dazu verwendet, alle Arten von Trivia zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="37833-164">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="37833-165">Trivia werden nicht als untergeordnetes Element eines Knotens in der Syntaxstruktur eingeschlossen, weil sie kein Teil der normalen Sprachsyntax sind, und überall zwischen zwei Token auftauchen können.</span><span class="sxs-lookup"><span data-stu-id="37833-165">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="37833-166">Dennoch sind sie als Teil der Syntaxstruktur vorhanden, weil sie beim Implementieren einer Funktion, wie dem Refactoring und der genauen Beibehaltung des Quelltexts, wichtig sind.</span><span class="sxs-lookup"><span data-stu-id="37833-166">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="37833-167">Sie können auf Trivia zugreifen, indem Sie die Sammlungen <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> oder <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> eines Tokens überprüfen.</span><span class="sxs-lookup"><span data-stu-id="37833-167">You can access trivia by inspecting a token's <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="37833-168">Triviasequenzen werden beim Analysieren von Quelltext den Token zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="37833-168">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="37833-169">Im Allgemeinen sind einem Token alle darauffolgenden Trivia in der selben Zeile bis zum nächsten Token zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="37833-169">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="37833-170">Alle Trivia nach dieser Zeile sind dem nächsten Token zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="37833-170">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="37833-171">Dem ersten Token in der Quelldatei werden alle anfänglichen Trivia zugeordnet, und die letzte Triviasequenz der Datei wird dem Dateiende-Token zugewiesen, das andernfalls eine Breite von 0 (null) hat.</span><span class="sxs-lookup"><span data-stu-id="37833-171">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="37833-172">Im Gegensatz zu Syntaxknoten und Token haben Syntaxtrivia keine übergeordneten Elemente.</span><span class="sxs-lookup"><span data-stu-id="37833-172">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="37833-173">Da sie Teil der Struktur sind und jeweils einem einzelnen Token zugeordnet sind, können Sie auf dieses Token mit der <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType>-Eigenschaft zugreifen.</span><span class="sxs-lookup"><span data-stu-id="37833-173">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="37833-174">Span-Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="37833-174">Spans</span></span>

<span data-ttu-id="37833-175">Alle Knoten, Token und Trivia kennen ihre Position im Quelltext und die Anzahl der von ihnen enthaltenen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="37833-175">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="37833-176">Eine Position im Text wird von einer 32-Bit-Ganzzahl, also einem nullbasierten `char`-Index, dargestellt.</span><span class="sxs-lookup"><span data-stu-id="37833-176">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="37833-177">Ein <xref:Microsoft.CodeAnalysis.Text.TextSpan>-Objekt ist eine Anfangsposition und eine Anzahl von Zeichen, die jeweils beide als ganze Zahl dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="37833-177">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="37833-178">Wenn <xref:Microsoft.CodeAnalysis.Text.TextSpan> die Länge 0 (null) hat, bezieht es sich auf eine Position zwischen zwei Zeichen.</span><span class="sxs-lookup"><span data-stu-id="37833-178">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="37833-179">Jeder Knoten verfügt über zwei <xref:Microsoft.CodeAnalysis.Text.TextSpan>-Eigenschaften: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> und <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span><span class="sxs-lookup"><span data-stu-id="37833-179">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="37833-180">Die Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> bezeichnet die Textspanne vom ersten Token in der Unterstruktur des Knotens bis zum Ende des letzten Tokens.</span><span class="sxs-lookup"><span data-stu-id="37833-180">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node's subtree to the end of the last token.</span></span> <span data-ttu-id="37833-181">Diese Spanne umfasst keine führenden oder nachgestellten Trivia.</span><span class="sxs-lookup"><span data-stu-id="37833-181">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="37833-182">Die Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> bezeichnet die Textspanne, die die normale Spanne des Knotens und die Spannen jeglicher führenden oder nachgestellten Trivia enthält.</span><span class="sxs-lookup"><span data-stu-id="37833-182">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node's normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="37833-183">Zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="37833-183">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="37833-184">Der Anweisungsknoten im Block verfügt über eine Spanne, die von einzelnen senkrechten Strichen (|) ausgezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="37833-184">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="37833-185">Sie umfasst die Zeichen `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="37833-185">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="37833-186">Die vollständige Spanne wird mit doppelten senkrechten Strichen (||) ausgezeichnet.</span><span class="sxs-lookup"><span data-stu-id="37833-186">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="37833-187">Sie enthält die gleichen Zeichen wie die Spanne und Zeichen, die den führenden und nachfolgenden Trivia zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="37833-187">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="37833-188">Kind-Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="37833-188">Kinds</span></span>

<span data-ttu-id="37833-189">Alle Knoten, Token und Trivia über die Eigenschaft <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> vom Typ <xref:System.Int32?displayProperty=nameWithType>, die das genaue Syntax-Element identifiziert, das dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="37833-189">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="37833-190">Dieser Wert kann in eine sprachspezifische Enumeration umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="37833-190">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="37833-191">Jede Programmiersprache (C# oder Visual Basic) verfügt über eine einzelne `SyntaxKind`-Enumeration (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> bzw. <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>), die alle möglichen Knoten, Token und Trivia in der Grammatik auflistet.</span><span class="sxs-lookup"><span data-stu-id="37833-191">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="37833-192">Diese Konvertierung kann automatisch erfolgen, indem Sie auf die Erweiterungsmethoden <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> oder <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> zugreifen.</span><span class="sxs-lookup"><span data-stu-id="37833-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="37833-193">Die <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind>-Eigenschaft ermöglicht einfache Mehrdeutigkeitsvermeidung für Syntaxknotentypen, die die gleiche Knotenklasse nutzen.</span><span class="sxs-lookup"><span data-stu-id="37833-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="37833-194">Für Token und Trivia ist diese Eigenschaft die einzige Möglichkeit, verschiedene Elementtypen voneinander zu unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="37833-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="37833-195">Angenommen, eine einzelne <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax>-Klasse verfügt über die untergeordneten Elemente <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> und <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="37833-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="37833-196">Dann unterscheidet die <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A>-Eigenschaft, ob es sich um einen Syntaxknoten mit <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> oder <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> handelt.</span><span class="sxs-lookup"><span data-stu-id="37833-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="37833-197">Fehler</span><span class="sxs-lookup"><span data-stu-id="37833-197">Errors</span></span>

<span data-ttu-id="37833-198">Auch wenn der Quelltext Syntaxfehler enthält, wird eine vollständige Syntaxstruktur verfügbar gemacht, die auf die Quelle zurückführbar ist.</span><span class="sxs-lookup"><span data-stu-id="37833-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="37833-199">Wenn der Parser auf Code trifft, der nicht der definierten Syntax der Programmiersprache entspricht, nutzt er eines von zwei Verfahren, um eine Syntaxstruktur zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="37833-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree:</span></span>

- <span data-ttu-id="37833-200">Wenn der Parser eine bestimmte Art von Token erwartet, es aber nicht vorhanden ist, kann er dort, wo er das Token erwartet hat, ein fehlendes Token in die Syntaxstruktur einfügen.</span><span class="sxs-lookup"><span data-stu-id="37833-200">If the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="37833-201">Ein fehlendes Token stellt das Token dar, das vom Parser erwartet wurde, es besitzt jedoch eine leere Span-Eigenschaft, und die zugehörige <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType>-Eigenschaft gibt `true` an.</span><span class="sxs-lookup"><span data-stu-id="37833-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

- <span data-ttu-id="37833-202">Der Parser kann Token überspringen, bis er ein Token findet, bei dem er mit der Analyse fortfahren kann.</span><span class="sxs-lookup"><span data-stu-id="37833-202">The parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="37833-203">Wenn das der Fall ist, werden die übersprungenen Token als Triviaknoten mit der Eigenschaft <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia> angefügt.</span><span class="sxs-lookup"><span data-stu-id="37833-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
