---
title: Tupeltypen | C#-Leitfaden
description: Erfahren Sie mehr über unbenannte und benannte Tupeltypen in C#
ms.date: 05/15/2018
ms.technology: csharp-fundamentals
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 497f95811677c300e1fadad65eb495dced7f2da3
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/04/2020
ms.locfileid: "84374615"
---
# <a name="c-tuple-types"></a><span data-ttu-id="458a0-103">C#-Tupeltypen</span><span class="sxs-lookup"><span data-stu-id="458a0-103">C# tuple types</span></span>

<span data-ttu-id="458a0-104">C#-Tupel sind Typen, die Sie mithilfe einer einfachen Syntax definieren.</span><span class="sxs-lookup"><span data-stu-id="458a0-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="458a0-105">Zu den Vorteilen gehören eine einfachere Syntax, Regeln für auf Zahlen basierte Umwandlungen (sogenannte Kardinalitäten) und Typen von Elementen sowie konsistente Regeln für Kopien, Gleichheitstests und Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="458a0-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="458a0-106">Dafür unterstützen Tupel nicht einige der objektorientierten Idiome, die der Vererbung zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="458a0-107">Sie erhalten im Abschnitt zu Tupeln im Artikel [Neuerungen in C# 7.0](whats-new/csharp-7.md#tuples) einen Überblick.</span><span class="sxs-lookup"><span data-stu-id="458a0-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="458a0-108">In diesem Artikel erhalten Sie Informationen zu Sprachregeln, die Tupel in C# 7.0 und höheren Versionen steuern und zu verschiedenen Verwendungsarten. Außerdem wird ein erster Leitfaden zum Arbeiten mit Tupeln zur Verfügung gestellt.</span><span class="sxs-lookup"><span data-stu-id="458a0-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="458a0-109">Die neuen Tupeleigenschaften benötigen die <xref:System.ValueTuple>-Typen.</span><span class="sxs-lookup"><span data-stu-id="458a0-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="458a0-110">Sie müssen das NuGet-Paket [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) hinzufügen, um es auf Plattformen zu verwenden, die keine Typen enthalten.</span><span class="sxs-lookup"><span data-stu-id="458a0-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="458a0-111">Dies ist ähnlich wie bei anderen Sprachfunktionen, die auf im Framework übermittelten Typen basieren.</span><span class="sxs-lookup"><span data-stu-id="458a0-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="458a0-112">Beispiele hierfür sind `async` und `await`, die auf der `INotifyCompletion`-Schnittstelle basieren, und LINQ, das auf `IEnumerable<T>` basiert.</span><span class="sxs-lookup"><span data-stu-id="458a0-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="458a0-113">Allerdings ändert sich der Übermittlungsmechanismus, da .NET plattformunabhängiger wird.</span><span class="sxs-lookup"><span data-stu-id="458a0-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="458a0-114">.NET Framework wird möglicherweise nicht immer im gleichen Rhythmus wie der Sprachcompiler ausgeliefert.</span><span class="sxs-lookup"><span data-stu-id="458a0-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="458a0-115">Wenn neue Sprachfunktionen auf neuen Typen basieren, sind diese Typen als NuGet-Pakete bei der Auslieferung der Sprachfunktionen verfügbar.</span><span class="sxs-lookup"><span data-stu-id="458a0-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="458a0-116">Da diese neuen Typen dem standardmäßigen .NET API hinzugefügt und als Teil des Frameworks bereitgestellt werden, wird die Anforderung des NuGet-Pakets entfernt.</span><span class="sxs-lookup"><span data-stu-id="458a0-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="458a0-117">Beginnen wir mit den Gründen für das Hinzufügen neuer Unterstützung für Tupel.</span><span class="sxs-lookup"><span data-stu-id="458a0-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="458a0-118">Methoden geben ein einzelnes Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="458a0-118">Methods return a single object.</span></span> <span data-ttu-id="458a0-119">Mit Tupel können Sie mehrere Werte einfacher in das einzelne Objekt packen.</span><span class="sxs-lookup"><span data-stu-id="458a0-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="458a0-120">.NET Framework hat bereits generische `Tuple`-Klassen.</span><span class="sxs-lookup"><span data-stu-id="458a0-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="458a0-121">Diese Klassen hatten jedoch zwei wesentliche Einschränkungen.</span><span class="sxs-lookup"><span data-stu-id="458a0-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="458a0-122">Zum einen haben die `Tuple`-Klassen ihre Eigenschaften als `Item1`, `Item2` usw. bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="458a0-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="458a0-123">Diese Namen enthalten keine semantischen Informationen.</span><span class="sxs-lookup"><span data-stu-id="458a0-123">Those names carry no semantic information.</span></span> <span data-ttu-id="458a0-124">Mit diesen `Tuple`-Typen kann nicht die Bedeutung der einzelnen Eigenschaften kommuniziert werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="458a0-125">Die neuen Sprachfeatures ermöglichen Ihnen, semantisch aussagekräftige Namen für die Elemente eines Tupels zu deklarieren und zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="458a0-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="458a0-126">Die `Tuple`-Klassen verursachen mehr Bedenken bezüglich der Leistung, da es sich dabei um Verweistypen handelt.</span><span class="sxs-lookup"><span data-stu-id="458a0-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="458a0-127">Das Verwenden von einem der `Tuple`-Typen bedeutet, dass Objekte zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="458a0-128">Bei langsamen Pfaden kann das Zuordnen vieler kleiner Objekte einen messbaren Einfluss auf die Leistung Ihrer Anwendungen haben.</span><span class="sxs-lookup"><span data-stu-id="458a0-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="458a0-129">Deshalb nutzt die Sprachunterstützung für Tupels die neuen `ValueTuple`-Strukturen.</span><span class="sxs-lookup"><span data-stu-id="458a0-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="458a0-130">Sie können `class` oder `struct` zum Tragen von mehreren Elementen erstellen, um diese Mängel zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="458a0-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="458a0-131">Leider bedeutet das mehr Arbeit für Sie, und es verdeckt Ihre Entwurfsabsicht.</span><span class="sxs-lookup"><span data-stu-id="458a0-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="458a0-132">Durch das Erstellen von `struct` und `class` wird angedeutet, dass Sie einen Typ sowohl mit Daten als auch mit Verhalten definieren.</span><span class="sxs-lookup"><span data-stu-id="458a0-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="458a0-133">In vielen Fällen möchten Sie einfach mehrere Werte in ein einzelnes Objekt speichern.</span><span class="sxs-lookup"><span data-stu-id="458a0-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="458a0-134">Die Sprachfunktionen und die generischen `ValueTuple`-Strukturen setzen die Regel durch, dass Sie nicht jedes beliebige Verhalten (Methoden) den Tupeltypen hinzufügen können.</span><span class="sxs-lookup"><span data-stu-id="458a0-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="458a0-135">Alle `ValueTuple`-Typen sind *veränderbare Strukturen*.</span><span class="sxs-lookup"><span data-stu-id="458a0-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="458a0-136">Jedes Memberfeld ist ein öffentliches Feld.</span><span class="sxs-lookup"><span data-stu-id="458a0-136">Each member field is a public field.</span></span> <span data-ttu-id="458a0-137">Das macht sie sehr einfach.</span><span class="sxs-lookup"><span data-stu-id="458a0-137">That makes them very lightweight.</span></span> <span data-ttu-id="458a0-138">Allerdings bedeutet dies, dass Tupel nicht dort verwendet werden dürfen, wo Unveränderlichkeit wichtig ist.</span><span class="sxs-lookup"><span data-stu-id="458a0-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="458a0-139">Tupel sind sowohl einfachere als auch flexiblere Datencontainer als `class`- und `struct`-Typen.</span><span class="sxs-lookup"><span data-stu-id="458a0-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="458a0-140">Betrachten wir diese Unterschiede.</span><span class="sxs-lookup"><span data-stu-id="458a0-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="458a0-141">Benannte und unbenannte Tupel</span><span class="sxs-lookup"><span data-stu-id="458a0-141">Named and unnamed tuples</span></span>

<span data-ttu-id="458a0-142">Die `ValueTuple`-Struktur hat Felder mit den Namen `Item1`, `Item2`, `Item3` usw., die den Eigenschaften ähnlich sind, die in den vorhandenen `Tuple`-Typen definiert wurden.</span><span class="sxs-lookup"><span data-stu-id="458a0-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="458a0-143">Diese Namen sind die einzigen Namen, die Sie für *unbenannte Tupel* verwenden können.</span><span class="sxs-lookup"><span data-stu-id="458a0-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="458a0-144">Wenn Sie einem Tupel keine alternativen Feldnamen bereitstellen, haben Sie einen unbenannten Tupel erstellt:</span><span class="sxs-lookup"><span data-stu-id="458a0-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="458a0-145">Das Tupel im vorherigen Beispiel wurde mithilfe von Literalkonstanten initialisiert und verfügt nicht über Elementnamen, die mithilfe von *Projektionen für Tupel-Feldnamen* in C# 7.1 erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="458a0-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="458a0-146">Sie können jedoch bei der Initialisierung eines Tupels neue Spracheigenschaften verwenden, die jedem Feld bessere Namen geben.</span><span class="sxs-lookup"><span data-stu-id="458a0-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="458a0-147">Dadurch wird ein *benannter Tupel* erstellt.</span><span class="sxs-lookup"><span data-stu-id="458a0-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="458a0-148">Benannte Tupel haben immer noch Elemente mit den Namen `Item1`, `Item2`, `Item3` usw.</span><span class="sxs-lookup"><span data-stu-id="458a0-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="458a0-149">Sie haben jedoch auch Synonyme für alle Elemente, die Sie benannt haben.</span><span class="sxs-lookup"><span data-stu-id="458a0-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="458a0-150">Sie erstellen einen benannten Tupel, indem Sie den Namen für jedes Element angeben.</span><span class="sxs-lookup"><span data-stu-id="458a0-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="458a0-151">Eine Möglichkeit ist es, die Namen als Teil der Initialisierung des Tupel anzugeben:</span><span class="sxs-lookup"><span data-stu-id="458a0-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="458a0-152">Diese Synonyme werden vom Compiler und der Sprache verarbeitet, sodass Sie benannte Tupel effektiv verwenden können.</span><span class="sxs-lookup"><span data-stu-id="458a0-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="458a0-153">IDEs und Editoren können die semantischen Namen mithilfe der Roslyn-APIs lesen.</span><span class="sxs-lookup"><span data-stu-id="458a0-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="458a0-154">Sie können auf die Elemente eines benannten Tupels durch diese semantischen Namen an einer beliebigen Stelle in der gleichen Assembly verweisen.</span><span class="sxs-lookup"><span data-stu-id="458a0-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="458a0-155">Der Compiler ersetzt die Namen, die Sie definiert haben, mit `Item*`-Äquivalenten, wenn die Compilerausgabe erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="458a0-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="458a0-156">Die kompilierte Microsoft Intermediate Language (MSIL) enthält nicht die Namen, die Sie diesen Elementen gegeben haben.</span><span class="sxs-lookup"><span data-stu-id="458a0-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="458a0-157">Ab C# 7.1 können die Feldnamen für ein Tupel von den Variablen bereitgestellt werden, die zum Initialisieren des Tupels verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="458a0-158">Diese werden als **[Tupel-Projektionsinitialisierer](#tuple-projection-initializers)** bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="458a0-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="458a0-159">Der folgende Code erstellt ein Tupel namens `accumulation` mit den Elementen `count` (ein integer-Typ Zahl) und `sum` (ein Double-Typ).</span><span class="sxs-lookup"><span data-stu-id="458a0-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="458a0-160">Der Compiler muss diese Namen kommunizieren, die Sie für Tupel erstellt haben, die von öffentlichen Methoden oder Eigenschaften zurückgegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="458a0-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="458a0-161">In diesen Fällen fügt der Compiler ein Attribut <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> zur Methode hinzu.</span><span class="sxs-lookup"><span data-stu-id="458a0-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="458a0-162">Dieses Attribut enthält eine <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames>-Listeneigenschaft, die die Namen für jedes der Elemente im Tupel enthält.</span><span class="sxs-lookup"><span data-stu-id="458a0-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="458a0-163">Entwicklungstools wie Visual Studio lesen auch diese Metadaten und stellen IntelliSense und andere Funktionen bereit, die die Feldnamen der Metadaten verwenden.</span><span class="sxs-lookup"><span data-stu-id="458a0-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="458a0-164">Es ist wichtig, diese zugrunde liegenden Grundlagen der neuen Tupel sowie den `ValueTuple`-Typ zu verstehen, um die Regeln für das gegenseitige Zuweisen von benannten Tupel zu verstehen.</span><span class="sxs-lookup"><span data-stu-id="458a0-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="458a0-165">Tupel-Projektionsinitialisierer</span><span class="sxs-lookup"><span data-stu-id="458a0-165">Tuple projection initializers</span></span>

<span data-ttu-id="458a0-166">Im allgemeinen funktionieren Tupel-Projektionsinitialisierer, indem die Variablen- oder Feldnamen von der rechten Seite der Initialisierungsanweisung eines Tupels verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="458a0-167">Wenn ein expliziter Name vergeben wird, hat dieser vor jedem projizierten Namen Vorrang.</span><span class="sxs-lookup"><span data-stu-id="458a0-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="458a0-168">Im folgenden Initialisierer sind die Elemente beispielsweise `explicitFieldOne` und `explicitFieldTwo`, nicht `localVariableOne` und `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="458a0-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="458a0-169">Für jedes Feld ohne expliziten Namen wird ein zutreffender, impliziter Name projiziert.</span><span class="sxs-lookup"><span data-stu-id="458a0-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="458a0-170">Es ist weder explizit noch implizit nötig, semantische Namen bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="458a0-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="458a0-171">Der folgende Initialisierer besitzt den Feldnamen `Item1`, dessen Wert `42` ist, und `stringContent`, dessen Wert „Die Antwort auf alles“ ist:</span><span class="sxs-lookup"><span data-stu-id="458a0-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="458a0-172">Es gibt zwei Bedingungen, unter denen die Feldnamen von Kandidaten nicht auf das Tupelfeld projiziert werden:</span><span class="sxs-lookup"><span data-stu-id="458a0-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="458a0-173">Wenn es sich beim Namen des Kandidaten um einen reservierten Tupelnamen handelt.</span><span class="sxs-lookup"><span data-stu-id="458a0-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="458a0-174">Die Beispiele umfassen `Item3`, `ToString` oder `Rest`.</span><span class="sxs-lookup"><span data-stu-id="458a0-174">Examples include `Item3`, `ToString`, or `Rest`.</span></span>
1. <span data-ttu-id="458a0-175">Wenn es sich beim Namen des Kandidaten um das Duplikat des expliziten oder impliziten Feldnamens eines anderen Tupels handelt.</span><span class="sxs-lookup"><span data-stu-id="458a0-175">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="458a0-176">Durch diese Bedingungen wird Mehrdeutigkeit vermieden.</span><span class="sxs-lookup"><span data-stu-id="458a0-176">These conditions avoid ambiguity.</span></span> <span data-ttu-id="458a0-177">Diese Namen würden eine Mehrdeutigkeit verursachen, wenn sie als Feldnamen für das Feld eines Tupels verwendet würden.</span><span class="sxs-lookup"><span data-stu-id="458a0-177">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="458a0-178">Keine dieser Bedingungen verursacht Kompilierzeitfehler.</span><span class="sxs-lookup"><span data-stu-id="458a0-178">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="458a0-179">Stattdessen werden für die Elemente, die nicht über projizierte Namen verfügen, keine semantischen Namen projiziert.</span><span class="sxs-lookup"><span data-stu-id="458a0-179">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="458a0-180">In den folgenden Beispielen werden diese Bedingungen veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="458a0-180">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="458a0-181">Diese Situationen verursachen keine Compilerfehler, da diese eine grundlegende Änderung für mit C# 7.0 geschriebenen Code darstellen würden, bei dem die Projektionen für Tupel-Feldnamen noch nicht verfügbar waren.</span><span class="sxs-lookup"><span data-stu-id="458a0-181">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="458a0-182">Gleichheit und Tupel</span><span class="sxs-lookup"><span data-stu-id="458a0-182">Equality and tuples</span></span>

<span data-ttu-id="458a0-183">Ab C# 7.3 unterstützen Tupeltypen die Operatoren `==` und `!=`.</span><span class="sxs-lookup"><span data-stu-id="458a0-183">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="458a0-184">Diese Operatoren arbeiten durch Vergleichen jedes Members des linken Arguments mit jedem Member des rechten Arguments in der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="458a0-184">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="458a0-185">Diese Vergleiche können verkürzt werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-185">These comparisons short-circuit.</span></span> <span data-ttu-id="458a0-186">Sie beenden die Auswertung von Membern, sobald ein Paar nicht gleich ist.</span><span class="sxs-lookup"><span data-stu-id="458a0-186">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="458a0-187">In folgendem Codebeispiel wird `==` verwendet, die Vergleichsregeln gelten jedoch alle für `!=`.</span><span class="sxs-lookup"><span data-stu-id="458a0-187">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="458a0-188">Das folgende Codebeispiel stellt einen Gleichheitsvergleich für zwei Paare ganzer Zahlen dar:</span><span class="sxs-lookup"><span data-stu-id="458a0-188">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="458a0-189">Es gibt einige Regeln, die Tupelgleichheitstests einfacher machen.</span><span class="sxs-lookup"><span data-stu-id="458a0-189">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="458a0-190">Die Tupelgleichheit führt [mehrstufige Konvertierungen](~/_csharplang/spec/conversions.md#lifted-conversion-operators) aus, wenn eines der Tupel ein Tupel mit NULL-Werten ist, so wie im folgenden Code dargestellt:</span><span class="sxs-lookup"><span data-stu-id="458a0-190">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="458a0-191">Die Tupelgleichheit führt ebenso implizite Konvertierungen für jeden Member beider Tupel aus.</span><span class="sxs-lookup"><span data-stu-id="458a0-191">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="458a0-192">Dazu gehören mehrstufige Konvertierungen, Erweiterungskonvertierungen oder andere implizite Konvertierungen.</span><span class="sxs-lookup"><span data-stu-id="458a0-192">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="458a0-193">Die folgenden zwei Beispiele zeigen, dass ein ganzzahliges 2-Tupel mit einem langen 2-Tupel aufgrund der impliziten Konvertierung von „integer“ in „long“ verglichen werden kann.</span><span class="sxs-lookup"><span data-stu-id="458a0-193">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="458a0-194">Die Namen der Tupelmember sind nicht Teil von Tests auf Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="458a0-194">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="458a0-195">Wenn jedoch einer der Operanden ein Tupelliteral mit expliziten Namen ist, generiert der Compiler die Warnung CS8383, wenn diese Namen nicht mit den Namen des anderen Operanden übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="458a0-195">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="458a0-196">Sobald beide Operanden Tupelliterale sind, befindet sich die Warnung beim rechten Operanden, wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="458a0-196">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="458a0-197">Zuletzt können Tupel geschachtelte Tupel enthalten.</span><span class="sxs-lookup"><span data-stu-id="458a0-197">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="458a0-198">Die Tupelgleichheit vergleicht die „Form“ jedes Operanden, wie im folgenden Beispiel dargestellt, über geschachtelte Tupel:</span><span class="sxs-lookup"><span data-stu-id="458a0-198">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="458a0-199">Beim Vergleich zweier Tupel für Gleichheit (oder Ungleichheit) tritt zur Kompilierzeit ein Fehler auf, wenn sie verschiedene Formen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="458a0-199">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="458a0-200">Der Compiler unternimmt keinen Dekonstruktionsversuch für geschachtelte Tupel, um diese zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="458a0-200">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="458a0-201">Zuweisung und Tupel</span><span class="sxs-lookup"><span data-stu-id="458a0-201">Assignment and tuples</span></span>

<span data-ttu-id="458a0-202">Die Sprache unterstützt die Zuordnung zwischen Tupeltypen, die über die gleiche Anzahl von Elementen verfügen, wobei jedes Element auf der rechten Seite implizit in sein entsprechendes linkes Element konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="458a0-202">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="458a0-203">Andere Konvertierungen werden für Zuweisungen nicht in Betracht gezogen.</span><span class="sxs-lookup"><span data-stu-id="458a0-203">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="458a0-204">Bei der Zuweisung eines Tupels zu einem anderen tritt zur Kompilierzeit ein Fehler auf, wenn sie verschiedene Formen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="458a0-204">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="458a0-205">Der Compiler unternimmt keinen Dekonstruktionsversuch für geschachtelte Tupel, um diese zu zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="458a0-205">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="458a0-206">Sehen wir uns die Arten von Zuweisungen an, die zwischen Tupeltypen zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="458a0-206">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="458a0-207">Berücksichtigen Sie diese Variablen, die in den folgenden Beispielen verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="458a0-207">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="458a0-208">Die ersten zwei Variablen (`unnamed` und `anonymous`) haben keine semantischen Namen für die Elemente bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="458a0-208">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="458a0-209">Die Feldnamen lauten `Item1` und `Item2`.</span><span class="sxs-lookup"><span data-stu-id="458a0-209">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="458a0-210">Die letzten zwei Variablen (`named` und `differentName`) haben semantische Namen für die Elemente angegeben.</span><span class="sxs-lookup"><span data-stu-id="458a0-210">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="458a0-211">Diese zwei Tupel besitzen unterschiedliche Namen für die Elemente.</span><span class="sxs-lookup"><span data-stu-id="458a0-211">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="458a0-212">Alle vier dieser Tupel haben die gleiche Anzahl von Elementen (als „Kardinalität“ bezeichnet), und die Typen dieser Elemente sind identisch.</span><span class="sxs-lookup"><span data-stu-id="458a0-212">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="458a0-213">Daher funktionieren alle Zuweisungen:</span><span class="sxs-lookup"><span data-stu-id="458a0-213">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="458a0-214">Beachten Sie, dass die Namen der Tupel nicht zugewiesen sind.</span><span class="sxs-lookup"><span data-stu-id="458a0-214">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="458a0-215">Die Werte der Elemente werden nach der Reihenfolge der Elemente im Tupel zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="458a0-215">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="458a0-216">Tupel mit unterschiedlichen Typen oder mit einer unterschiedlichen Anzahl von Elementen sind nicht zuweisbar:</span><span class="sxs-lookup"><span data-stu-id="458a0-216">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="458a0-217">Tupel als Methodenrückgabewert</span><span class="sxs-lookup"><span data-stu-id="458a0-217">Tuples as method return values</span></span>

<span data-ttu-id="458a0-218">Einer der häufigsten Verwendungszwecke für Tupel ist als Methodenrückgabewerte.</span><span class="sxs-lookup"><span data-stu-id="458a0-218">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="458a0-219">Lassen Sie uns ein ausführliches Beispiel ansehen.</span><span class="sxs-lookup"><span data-stu-id="458a0-219">Let's walk through one example.</span></span> <span data-ttu-id="458a0-220">Betrachten Sie diese Methode, die die Standardabweichung für eine Sequenz von Zahlen berechnet:</span><span class="sxs-lookup"><span data-stu-id="458a0-220">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="458a0-221">In diesem Beispiel wird die unkorrigierte Beispielstandardabweichung berechnet.</span><span class="sxs-lookup"><span data-stu-id="458a0-221">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="458a0-222">Die korrigierte Formel der Beispielstandardabweichung würde die Summe der Differenzen im Quadrat vom Mittelwert mithilfe von (N-1) anstatt N teilen, wie es die Erweiterungsmethode `Average` macht.</span><span class="sxs-lookup"><span data-stu-id="458a0-222">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="458a0-223">Weitere Informationen zu den Unterschieden zwischen diesen Formeln für die Standardabweichung finden Sie in einem Statistiktext.</span><span class="sxs-lookup"><span data-stu-id="458a0-223">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="458a0-224">Der vorangehende Code entspricht der idealen Formel für die Standardabweichung.</span><span class="sxs-lookup"><span data-stu-id="458a0-224">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="458a0-225">Die richtige Antwort wird generiert, aber es ist eine ineffiziente Implementierung.</span><span class="sxs-lookup"><span data-stu-id="458a0-225">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="458a0-226">Diese Methode listet die Sequenz zweimal auf: Einmal, um den Durchschnitt zu erzeugen, und einmal, um den Durchschnitt des Quadrats der Differenz des Durchschnitts zu erzeugen.</span><span class="sxs-lookup"><span data-stu-id="458a0-226">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="458a0-227">(Beachten Sie, dass LINQ-Abfragen verzögert ausgewertet werden. Daher kann die Berechnung der Unterschiede vom Mittelwert und des Durchschnitts dieser Unterschiede nur eine Enumeration erzeugen.)</span><span class="sxs-lookup"><span data-stu-id="458a0-227">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="458a0-228">Es gibt eine alternative Formel, die eine Standardabweichung anhand einer Enumeration der Sequenz berechnet.</span><span class="sxs-lookup"><span data-stu-id="458a0-228">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="458a0-229">Diese Berechnung erzeugt zwei Werte, da sie die Sequenz auflistet: Die Summe aller Elemente in der Sequenz und die Summe jedes Werts im Quadrat:</span><span class="sxs-lookup"><span data-stu-id="458a0-229">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="458a0-230">Diese Version listet die Sequenz genau einmal auf.</span><span class="sxs-lookup"><span data-stu-id="458a0-230">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="458a0-231">Der Code kann jedoch nicht wieder verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-231">But it's not reusable code.</span></span> <span data-ttu-id="458a0-232">Während Sie arbeiten, werden Sie sehen, dass viele unterschiedliche statistische Berechnungen die Anzahl von Elementen in der Sequenz, die Summe der Sequenzen und die Summe der Quadrate der Sequenz verwenden.</span><span class="sxs-lookup"><span data-stu-id="458a0-232">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="458a0-233">Gestalten Sie diese Methode um und schreiben Sie eine Hilfsmethode, die alle diese Werte erzeugt.</span><span class="sxs-lookup"><span data-stu-id="458a0-233">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="458a0-234">Alle drei Werte können als Tupel zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-234">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="458a0-235">Wir aktualisieren diese Methoden, sodass die drei Werte, die während der Enumeration berechnet werden, in einem Tupel gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-235">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="458a0-236">Dadurch wird diese Version erstellt:</span><span class="sxs-lookup"><span data-stu-id="458a0-236">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="458a0-237">Die Unterstützung von Refactoring in Visual Studio vereinfacht es, die Funktionen für die Kernstatistik in eine private Methode zu extrahieren.</span><span class="sxs-lookup"><span data-stu-id="458a0-237">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="458a0-238">Das gibt Ihnen eine `private static`-Methode, die den Tupeltyp mit den drei Werten von `Sum`, `SumOfSquares` und `Count` zurückgibt:</span><span class="sxs-lookup"><span data-stu-id="458a0-238">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]

<span data-ttu-id="458a0-239">Die Sprache aktiviert einige weitere Optionen, die Sie verwenden können, wenn Sie ein Paar schnelle manuelle Bearbeitungen vornehmen möchten.</span><span class="sxs-lookup"><span data-stu-id="458a0-239">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="458a0-240">Sie können zuerst die Deklaration `var` verwenden, um das Tupelergebnis vom Methodenaufruf `ComputeSumAndSumOfSquares` zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="458a0-240">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="458a0-241">Sie können auch drei diskrete Variablen in der Methode `ComputeSumAndSumOfSquares` erstellen.</span><span class="sxs-lookup"><span data-stu-id="458a0-241">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="458a0-242">Die finale Version wird im folgenden Beispielcode dargestellt:</span><span class="sxs-lookup"><span data-stu-id="458a0-242">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="458a0-243">Die endgültige Version kann für jede Methode, die diese drei Werte oder einen Teil davon benötigt, verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-243">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="458a0-244">Die Sprache unterstützt andere Optionen, indem sie die Namen der Elemente in diesen Methoden verwaltet, die Tupel zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="458a0-244">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="458a0-245">Sie können die Feldnamen aus der Deklaration des Rückgabewerts entfernen und einen unbenannten Tupel zurückgeben:</span><span class="sxs-lookup"><span data-stu-id="458a0-245">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="458a0-246">Die Felder für dieses Tupel heißen `Item1`, `Item2` und `Item3`.</span><span class="sxs-lookup"><span data-stu-id="458a0-246">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="458a0-247">Es wird empfohlen, dass Sie den Tupelelementen, die von Methoden zurückgegeben werden, semantische Namen bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="458a0-247">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="458a0-248">Ein anderes Idiom, für das Tupel nützlich sein können, ist beim Erstellen von LINQ-Abfragen.</span><span class="sxs-lookup"><span data-stu-id="458a0-248">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="458a0-249">Das letztendlich projizierte Ergebnis enthält oft einige (aber nicht alle) Eigenschaften des Objekts, die ausgewählt werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-249">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="458a0-250">Sie würden normalerweise die Abfrageergebnisse in eine Sequenz von Objekten projizieren, die ein anonymer Typ waren.</span><span class="sxs-lookup"><span data-stu-id="458a0-250">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="458a0-251">Das stellte viele Einschränkungen dar, hauptsächlich, weil anonyme Typen nicht bequem im Rückgabetyp für eine Methode benannt werden konnten.</span><span class="sxs-lookup"><span data-stu-id="458a0-251">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="458a0-252">Alternativen, in denen `object` und `dynamic` als Typ des Ergebnisses verwende wurden, gingen mit erheblichen Leistungseinbußen einher.</span><span class="sxs-lookup"><span data-stu-id="458a0-252">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="458a0-253">Das Zurückgeben einer Sequenz eines Tupeltyps ist einfach, und die Namen und Typen der Elemente sind zur Kompilierzeit und über die IDE-Tools verfügbar.</span><span class="sxs-lookup"><span data-stu-id="458a0-253">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="458a0-254">Betrachten Sie z B. eine ToDo-Anwendung.</span><span class="sxs-lookup"><span data-stu-id="458a0-254">For example, consider a ToDo application.</span></span> <span data-ttu-id="458a0-255">Sie könnten eine Klassen vielleicht so ähnlich wie folgt definieren, um einen einzelnen Eintrag in der ToDo-Liste darzustellen:</span><span class="sxs-lookup"><span data-stu-id="458a0-255">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="458a0-256">Ihre mobile Anwendung unterstützt vielleicht ein kompaktes Format der aktuellen ToDo-Elemente, die nur den Titel anzeigen.</span><span class="sxs-lookup"><span data-stu-id="458a0-256">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="458a0-257">LINQ-Abfragen würden eine Projektion erstellen, die nur die ID und den Titel enthält.</span><span class="sxs-lookup"><span data-stu-id="458a0-257">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="458a0-258">Eine Methode, die eine Tupelsequenz zurückgibt, drückt den Entwurf gut aus:</span><span class="sxs-lookup"><span data-stu-id="458a0-258">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="458a0-259">In C# 7.1 ermöglichen Tupelprojektionen Ihnen das Erstellen benannter Tupel mithilfe von Elementen, ähnlich wie beim Benennen von Eigenschaften bei anonymen Typen.</span><span class="sxs-lookup"><span data-stu-id="458a0-259">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="458a0-260">Im obigen Code erstellt die `select`-Anweisung in der Abfrageprojektionen ein Tupel, das die Elemente `ID` und `Title` besitzt.</span><span class="sxs-lookup"><span data-stu-id="458a0-260">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="458a0-261">Das benannte Tupel kann Teil der Signatur sein.</span><span class="sxs-lookup"><span data-stu-id="458a0-261">The named tuple can be part of the signature.</span></span> <span data-ttu-id="458a0-262">Es lässt den Compiler und IDE-Tools statisch bereitstellen, indem überprüft wird, ob Sie das Ergebnis richtig verwenden.</span><span class="sxs-lookup"><span data-stu-id="458a0-262">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="458a0-263">Das benannte Tupel trägt auch die statischen Typinformationen, sodass keine teuren Laufzeitfunktionen wie Reflektion oder dynamische Bindung verwendet werden müssen, um mit den Ergebnissen zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="458a0-263">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="458a0-264">Dekonstruktion</span><span class="sxs-lookup"><span data-stu-id="458a0-264">Deconstruction</span></span>

<span data-ttu-id="458a0-265">Sie können alle Elemente in einem Tupel entpacken, indem das Tupel, das von einer Methode zurückgegeben wurde, *dekonstruiert* wird.</span><span class="sxs-lookup"><span data-stu-id="458a0-265">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="458a0-266">Es gibt drei verschiedene Ansätze zum Dekonstruieren von Tupeln.</span><span class="sxs-lookup"><span data-stu-id="458a0-266">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="458a0-267">Zuerst können Sie ausdrücklich den Typ von jedem Feld in Klammern deklarieren, um diskrete Variablen für jedes der Elemente im Tupel zu erstellen:</span><span class="sxs-lookup"><span data-stu-id="458a0-267">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="458a0-268">Sie können auch typisierte Variablen für jedes Feld in ein Tupel deklarieren, indem das Schlüsselwort `var` außerhalb der Klammern verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="458a0-268">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="458a0-269">Das Verwenden des Schlüsselworts `var` mit beliebigen oder allen Variablendeklarationen in den Klammern ist auch zulässig.</span><span class="sxs-lookup"><span data-stu-id="458a0-269">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span>

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="458a0-270">Sie können einen bestimmten Typ außerhalb der Klammern verwenden, auch wenn jedes Feld im Tupel den selben Typ hat.</span><span class="sxs-lookup"><span data-stu-id="458a0-270">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="458a0-271">Sie können Tupel auch mit bereits vorhandenen Deklarationen dekonstruieren:</span><span class="sxs-lookup"><span data-stu-id="458a0-271">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="458a0-272">Allerdings können bereits vorhandene Deklarationen nicht mit Deklarationen vermischt werden, die in Klammern stehen.</span><span class="sxs-lookup"><span data-stu-id="458a0-272">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="458a0-273">Folgendes ist beispielsweise nicht erlaubt: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="458a0-273">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="458a0-274">Dadurch wird der Fehler CS8184 ausgelöst, da *x* in Klammern und *y* bereits zuvor an einer anderen Stelle deklariert wurden.</span><span class="sxs-lookup"><span data-stu-id="458a0-274">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="458a0-275">Dekonstruieren von benutzerdefinierten Typen</span><span class="sxs-lookup"><span data-stu-id="458a0-275">Deconstructing user-defined types</span></span>

<span data-ttu-id="458a0-276">Jeder Tupeltyp kann dekonstruiert werden, wie oben gezeigt wurde.</span><span class="sxs-lookup"><span data-stu-id="458a0-276">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="458a0-277">Es ist genau so einfach, die Dekonstruktion in beliebigen benutzerdefinierten Typen (Klassen, Strukturen oder sogar Oberflächen) zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="458a0-277">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="458a0-278">Der Autor des Typs kann eine oder mehrere `Deconstruct`-Methoden definieren, die einer beliebigen Anzahl von [`out`-Variablen](language-reference/keywords/out-parameter-modifier.md) Werte zuweisen, die die Datenelemente darstellen, die den Typ ausmachen.</span><span class="sxs-lookup"><span data-stu-id="458a0-278">The type author can define one or more `Deconstruct` methods that assign values to any number of [`out` variables](language-reference/keywords/out-parameter-modifier.md) representing the data elements that make up the type.</span></span> <span data-ttu-id="458a0-279">Der folgende `Person`-Typ definiert z.B. eine `Deconstruct`-Methode, die ein Personenobjekt in die Elemente dekonstruiert, die dem Vor- und Nachnamen entsprechen:</span><span class="sxs-lookup"><span data-stu-id="458a0-279">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="458a0-280">Die Dekonstruktionsmethode ermöglicht die Zuordnung von einer `Person` zu zwei Zeichenfolgen, die die Eigenschaften `FirstName` und `LastName` darstellen:</span><span class="sxs-lookup"><span data-stu-id="458a0-280">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="458a0-281">Sie können Dekonstruktion selbst für Typen aktivieren, die Sie nicht geschrieben haben.</span><span class="sxs-lookup"><span data-stu-id="458a0-281">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="458a0-282">Die `Deconstruct`-Methode kann eine Erweiterungsmethode sein, die die zugänglichen Datenmember eines Objekts entpackt.</span><span class="sxs-lookup"><span data-stu-id="458a0-282">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="458a0-283">Das folgende Beispiel zeigt einen `Student`-Typ, der vom `Person`-Typ abgeleitet wurde, sowie eine Erweiterungsmethode, die ein `Student` in drei Variablen dekonstruiert, die den `FirstName`, `LastName` und `GPA` darstellen:</span><span class="sxs-lookup"><span data-stu-id="458a0-283">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="458a0-284">Ein `Student`-Objekt hat jetzt zwei zugängliche `Deconstruct`-Methoden: Die Erweiterungsmethode, die für `Student`-Typen deklariert wurde, und die Member des `Person`-Typs.</span><span class="sxs-lookup"><span data-stu-id="458a0-284">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="458a0-285">Beide befinden sich im Geltungsbereich, womit ein `Student` entweder in zwei oder drei Variablen dekonstruiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="458a0-285">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="458a0-286">Wenn Sie einem Studenten drei Variablen zuweisen, werden der Vorname, der Nachname sowie das GPA zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="458a0-286">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="458a0-287">Wenn Sie einem Studenten zwei Variablen zuweisen, werden nur Vor- und Nachname zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="458a0-287">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="458a0-288">Sie sollten vorsichtig mit dem Definieren von mehreren `Deconstruct`-Methoden in einer Klasse oder einer Klassenhierarchie sein.</span><span class="sxs-lookup"><span data-stu-id="458a0-288">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="458a0-289">Mehrere `Deconstruct`-Methoden, die die gleiche Anzahl von `out`-Parameter haben, können schnell zu Mehrdeutigkeiten führen.</span><span class="sxs-lookup"><span data-stu-id="458a0-289">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="458a0-290">Aufrufer können dann vielleicht nicht die gewünschte `Deconstruct`-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="458a0-290">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="458a0-291">In diesem Beispiel besteht eine minimale Wahrscheinlichkeit für einen mehrdeutigen Aufruf, weil die `Deconstruct`-Methode für `Person` zwei Ausgabeparameter besitzt, und die `Deconstruct`-Methode für `Student` drei besitzt.</span><span class="sxs-lookup"><span data-stu-id="458a0-291">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="458a0-292">Dekonstruktionsoperatoren werden nicht für Gleichheitstests verwendet.</span><span class="sxs-lookup"><span data-stu-id="458a0-292">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="458a0-293">Das folgende Beispiel generiert den Compilerfehler CS0019:</span><span class="sxs-lookup"><span data-stu-id="458a0-293">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="458a0-294">Die Methode `Deconstruct` kann das `Person`-Objekt `p` in ein Tupel konvertieren, das zwei Zeichenfolgen enthält. Dieses gilt jedoch nicht im Kontext von Gleichheitstests.</span><span class="sxs-lookup"><span data-stu-id="458a0-294">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="458a0-295">Tupel als out-Parameter</span><span class="sxs-lookup"><span data-stu-id="458a0-295">Tuples as out parameters</span></span>

<span data-ttu-id="458a0-296">Tupel können *selbst* als [`out`-Parameter](language-reference/keywords/out-parameter-modifier.md) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="458a0-296">Tuples can be used as [`out` parameters](language-reference/keywords/out-parameter-modifier.md) *themselves*.</span></span> <span data-ttu-id="458a0-297">Dies sollte nicht mit einer Mehrdeutigkeit verwechselt werden, die zuvor im Abschnitt [Dekonstruktion ](#deconstruction) erwähnt wurde.</span><span class="sxs-lookup"><span data-stu-id="458a0-297">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="458a0-298">In einem Methodenaufruf müssen Sie nur die Form des Tupels beschreiben:</span><span class="sxs-lookup"><span data-stu-id="458a0-298">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="458a0-299">Alternativ können Sie ein [_unbenanntes_](#named-and-unnamed-tuples) Tupel verwenden und auf seine Felder als `Item1` und `Item2` verweisen:</span><span class="sxs-lookup"><span data-stu-id="458a0-299">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="458a0-300">Schlussbemerkung</span><span class="sxs-lookup"><span data-stu-id="458a0-300">Conclusion</span></span>

<span data-ttu-id="458a0-301">Die neue Sprach- und Bibliotheksunterstützung für benannte Tupel vereinfacht es, mit Entwürfen zu arbeiten, die Datenstrukturen verwenden, die mehrere Elemente definieren, aber keine Verhalten definieren, wie es Klassen und Strukturen tun.</span><span class="sxs-lookup"><span data-stu-id="458a0-301">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="458a0-302">Die Verwendung von Tupeln ist für diese Typen einfach und präzise.</span><span class="sxs-lookup"><span data-stu-id="458a0-302">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="458a0-303">Sie erhalten alle Vorteile der Überprüfung von statischen Typen, ohne Typen mithilfe der ausführlicheren `class`- oder `struct`-Syntax schreiben zu müssen.</span><span class="sxs-lookup"><span data-stu-id="458a0-303">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="458a0-304">Dennoch sind sie für Hilfsmethoden, die `private` oder `internal` sind, am nützlichsten.</span><span class="sxs-lookup"><span data-stu-id="458a0-304">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="458a0-305">Erstellen Sie benutzerdefinierte Typen, entweder `class` oder `struct`, wenn Ihre öffentlichen Methoden einen Wert mit mehreren Elementen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="458a0-305">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
