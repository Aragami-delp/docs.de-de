---
title: Definieren benutzerdefinierter Typen für die Verwendung in .NET-XAML-Diensten
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/12/2020
ms.locfileid: "81433073"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="43891-102">Definieren benutzerdefinierter Typen für die Verwendung mit .NET XAML Services</span><span class="sxs-lookup"><span data-stu-id="43891-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="43891-103">Wenn Sie benutzerdefinierte Typen definieren, die Geschäftsobjekte oder Typen sind, die nicht von bestimmten Frameworks abhängig sind, gibt es bestimmte bewährte Methoden für XAML, die Sie befolgen können.</span><span class="sxs-lookup"><span data-stu-id="43891-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="43891-104">Wenn Sie diese Vorgehensweisen befolgen, können .NET XAML Services und seine XAML-Reader und XAML-Writer die XAML-Eigenschaften Ihres Typs ermitteln und ihn mithilfe des XAML-Typsystems in einem XAML-Knotenstream entsprechend darstellungen.</span><span class="sxs-lookup"><span data-stu-id="43891-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="43891-105">In diesem Thema werden bewährte Methoden für Typdefinitionen, Memberdefinitionen und CLR-Zuordnungen von Typen oder Membern beschrieben.</span><span class="sxs-lookup"><span data-stu-id="43891-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="43891-106">Konstruktormuster und Typdefinitionen für XAML</span><span class="sxs-lookup"><span data-stu-id="43891-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="43891-107">Um als Objektelement in XAML instanziiert zu werden, muss eine benutzerdefinierte Klasse die folgenden Anforderungen erfüllen:</span><span class="sxs-lookup"><span data-stu-id="43891-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="43891-108">Die benutzerdefinierte Klasse muss öffentlich sein und einen parameterlosen öffentlichen Konstruktor verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="43891-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="43891-109">(Hinweise zu Strukturen finden Sie im folgenden Abschnitt.)</span><span class="sxs-lookup"><span data-stu-id="43891-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="43891-110">Die benutzerdefinierte Klasse darf keine geschachtelte Klasse sein.</span><span class="sxs-lookup"><span data-stu-id="43891-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="43891-111">Der zusätzliche "Punkt" im Vollständigennamenpfad macht die Klassennamespace-Division mehrdeutig und stört andere XAML-Features, z. B. angefügte Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="43891-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="43891-112">Wenn ein Objekt als Objektelement instanziiert werden kann, kann das erstellte Objekt das Eigenschaftselementformular aller Eigenschaften ausfüllen, die das Objekt als zugrunde liegenden Typ annehmen.</span><span class="sxs-lookup"><span data-stu-id="43891-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="43891-113">Sie können weiterhin Objektwerte für Typen bereitstellen, die diese Kriterien nicht erfüllen, wenn Sie einen Wertkonverter aktivieren.</span><span class="sxs-lookup"><span data-stu-id="43891-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="43891-114">Weitere Informationen finden Sie unter [Typkonverter und Markuperweiterungen für XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="43891-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="43891-115">Strukturen</span><span class="sxs-lookup"><span data-stu-id="43891-115">Structures</span></span>

<span data-ttu-id="43891-116">Strukturen können immer in XAML nach CLR-Definition erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="43891-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="43891-117">Dies liegt daran, dass ein CLR-Compiler implizit einen parameterlosen Konstruktor für eine Struktur erstellt.</span><span class="sxs-lookup"><span data-stu-id="43891-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="43891-118">Dieser Konstruktor initialisiert alle Eigenschaftswerte auf ihre Standardwerte.</span><span class="sxs-lookup"><span data-stu-id="43891-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="43891-119">In einigen Fällen ist das Standardmäßige Konstruktionsverhalten für eine Struktur nicht wünschenswert.</span><span class="sxs-lookup"><span data-stu-id="43891-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="43891-120">Dies kann daran liegen, dass die Struktur dazu bestimmt ist, Werte zu füllen und konzeptionell als Union zu fungieren.</span><span class="sxs-lookup"><span data-stu-id="43891-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="43891-121">Als Union können die enthaltenen Werte sich gegenseitig ausschließende Interpretationen haben, und daher ist keine ihrer Eigenschaften setzbar.</span><span class="sxs-lookup"><span data-stu-id="43891-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="43891-122">Ein Beispiel für eine solche Struktur <xref:System.Windows.GridLength>im WPF-Vokabular ist .</span><span class="sxs-lookup"><span data-stu-id="43891-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="43891-123">Solche Strukturen sollten einen Typkonverter implementieren, damit die Werte in Attributform ausgedrückt werden können, indem Zeichenfolgenkonventionen verwendet werden, die die unterschiedlichen Interpretationen oder Modi der Strukturwerte erstellen.</span><span class="sxs-lookup"><span data-stu-id="43891-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="43891-124">Die Struktur sollte auch ähnliches Verhalten für die Codekonstruktion über einen nicht parameterlosen Konstruktor verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="43891-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="43891-125">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="43891-125">Interfaces</span></span>

<span data-ttu-id="43891-126">Schnittstellen können als zugrunde liegende Elementtypen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="43891-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="43891-127">Das XAML-Typsystem überprüft die zuweisbare Liste und erwartet, dass das Objekt, das als Wert bereitgestellt wird, der Schnittstelle zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="43891-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="43891-128">Es gibt kein Konzept, wie die Schnittstelle als XAML-Typ dargestellt werden muss, solange ein relevanter zuweisbarer Typ die XAML-Konstruktionsanforderungen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="43891-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="43891-129">Fabrikmethoden</span><span class="sxs-lookup"><span data-stu-id="43891-129">Factory Methods</span></span>

<span data-ttu-id="43891-130">Werksmethoden sind ein XAML 2009-Feature.</span><span class="sxs-lookup"><span data-stu-id="43891-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="43891-131">Sie ändern das XAML-Prinzip, dass Objekte über parameterlose Konstruktoren verfügen müssen.</span><span class="sxs-lookup"><span data-stu-id="43891-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="43891-132">Factory-Methoden sind in diesem Artikel nicht dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="43891-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="43891-133">Siehe [x:FactoryMethod-Richtlinie](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="43891-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="43891-134">Enumerationen</span><span class="sxs-lookup"><span data-stu-id="43891-134">Enumerations</span></span>

<span data-ttu-id="43891-135">Enumerationen weisen ein systemeigenes XAML-Konvertierungsverhalten auf.</span><span class="sxs-lookup"><span data-stu-id="43891-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="43891-136">Die in XAML angegebenen Enumerationskonstantennamen werden für den zugrunde liegenden Enumerationstyp aufgelöst und geben den Enumerationswert an einen XAML-Objektschreiber zurück.</span><span class="sxs-lookup"><span data-stu-id="43891-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="43891-137">XAML unterstützt eine Verwendung im Flags-Stil <xref:System.FlagsAttribute> für Enumerationen mit angewendeter Anwendung.</span><span class="sxs-lookup"><span data-stu-id="43891-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="43891-138">Weitere Informationen finden Sie unter [XAML-Syntax im Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="43891-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="43891-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) wird für die WPF-Zielgruppe geschrieben, aber die meisten Informationen in diesem Thema sind für XAML relevant, das nicht spezifisch für ein bestimmtes Implementierungsframework ist.)</span><span class="sxs-lookup"><span data-stu-id="43891-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="43891-140">Elementdefinitionen</span><span class="sxs-lookup"><span data-stu-id="43891-140">Member Definitions</span></span>

<span data-ttu-id="43891-141">Typen können Member für die XAML-Verwendung definieren.</span><span class="sxs-lookup"><span data-stu-id="43891-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="43891-142">Es ist möglich, dass Typen Member definieren, die XAML-fähig sind, auch wenn dieser bestimmte Typ nicht XAML-verwendbar ist.</span><span class="sxs-lookup"><span data-stu-id="43891-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="43891-143">Dies ist aufgrund der CLR-Vererbung möglich.</span><span class="sxs-lookup"><span data-stu-id="43891-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="43891-144">Solange ein Typ, der das Member erbt, die XAML-Verwendung als Typ unterstützt und das Member die XAML-Verwendung für den zugrunde liegenden Typ unterstützt oder über eine systemeigene XAML-Syntax verfügt, ist dieser Member XAML-fähig.</span><span class="sxs-lookup"><span data-stu-id="43891-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="43891-145">Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="43891-145">Properties</span></span>

<span data-ttu-id="43891-146">Wenn Sie Eigenschaften als öffentliche CLR-Eigenschaft `get` definieren, die die typischen CLR- und `set` Accessormuster und das sprachgerechte Schlüsselwortverwendet umsetzt, kann das XAML-Typsystem die Eigenschaft als Member mit entsprechenden Informationen melden, die für <xref:System.Xaml.XamlMember> Eigenschaften bereitgestellt werden, z. <xref:System.Xaml.XamlMember.IsReadPublic%2A> B. und <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="43891-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="43891-147">Bestimmte Eigenschaften können eine Textsyntax aktivieren, indem Sie <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="43891-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="43891-148">Weitere Informationen finden Sie unter [Typkonverter und Markuperweiterungen für XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="43891-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="43891-149">In Ermangelung einer Textsyntax oder systemeigenen XAML-Konvertierung und in Ermangelung weiterer Indirektionen,<xref:System.Xaml.XamlMember.TargetType%2A> z. B. einer Markuperweiterungsverwendung, muss der Typ einer Eigenschaft (im XAML-Typsystem) in der Lage sein, eine Instanz an einen XAML-Objektwriter zurückzugeben, indem der Zieltyp als CLR-Typ behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="43891-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="43891-150">Bei Verwendung von XAML 2009 kann [x:Reference Markup Extension](xreference-markup-extension.md) verwendet werden, um Werte bereitzustellen, wenn die vorherigen Überlegungen nicht erfüllt werden. Dies ist jedoch eher ein Verwendungsproblem als ein Typdefinitionsproblem.</span><span class="sxs-lookup"><span data-stu-id="43891-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="43891-151">Ereignisse</span><span class="sxs-lookup"><span data-stu-id="43891-151">Events</span></span>

<span data-ttu-id="43891-152">Wenn Sie Ereignisse als öffentliches CLR-Ereignis definieren, kann das XAML-Typsystem das Ereignis als Member mit <xref:System.Xaml.XamlMember.IsEvent%2A> als `true`melden.</span><span class="sxs-lookup"><span data-stu-id="43891-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="43891-153">Das Verdrahten der Ereignishandler liegt nicht im Bereich der .NET XAML Services-Funktionen. Die Verdrahtung wird bestimmten Frameworks und Implementierungen überlassen.</span><span class="sxs-lookup"><span data-stu-id="43891-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="43891-154">Methoden</span><span class="sxs-lookup"><span data-stu-id="43891-154">Methods</span></span>

<span data-ttu-id="43891-155">Inlinecode für Methoden ist keine Standard-XAML-Funktion.</span><span class="sxs-lookup"><span data-stu-id="43891-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="43891-156">In den meisten Fällen verweisen Sie nicht direkt auf Methodenmember aus XAML, und die Rolle von Methoden in XAML besteht nur darin, Unterstützung für bestimmte XAML-Muster bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="43891-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="43891-157">[x:FactoryMethod-Richtlinie](xfactorymethod-directive.md) ist eine Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="43891-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="43891-158">Felder</span><span class="sxs-lookup"><span data-stu-id="43891-158">Fields</span></span>

<span data-ttu-id="43891-159">CLR-Entwurfsrichtlinien verhindern nicht statische Felder.</span><span class="sxs-lookup"><span data-stu-id="43891-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="43891-160">Bei statischen Feldern können Sie nur über [x:Static Markup Extension](xstatic-markup-extension.md)auf statische Feldwerte zugreifen. In diesem Fall tun Sie nichts Besonderes in der CLR-Definition, um ein Feld für [x:Static-Verwendungen](xstatic-markup-extension.md) verfügbar zu machen.</span><span class="sxs-lookup"><span data-stu-id="43891-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="43891-161">Anfügbis-Mitglieder</span><span class="sxs-lookup"><span data-stu-id="43891-161">Attachable Members</span></span>

<span data-ttu-id="43891-162">Anfügbare Member werden XAML durch ein Accessormethodenmuster für einen definierenden Typ verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="43891-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="43891-163">Der definierende Typ selbst muss nicht als Objekt verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="43891-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="43891-164">Ein allgemeines Muster besteht darin, eine Dienstklasse zu deklarieren, deren Rolle darin besteht, das anfügbisierbare Element zu besitzen und die zugehörigen Verhaltensweisen zu implementieren, aber keine andere Funktion wie eine UI-Darstellung zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="43891-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="43891-165">In den folgenden Abschnitten stellt der Platzhalter *PropertyName* den Namen ihres anfügbaren Elements dar.</span><span class="sxs-lookup"><span data-stu-id="43891-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="43891-166">Dieser Name muss in der [XamlName-Grammatik](xamlname-grammar.md)gültig sein.</span><span class="sxs-lookup"><span data-stu-id="43891-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="43891-167">Seien Sie vorsichtig bei Namenskollisionen zwischen diesen Mustern und anderen Methoden eines Typs.</span><span class="sxs-lookup"><span data-stu-id="43891-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="43891-168">Wenn ein Member vorhanden ist, das mit einem der Muster übereinstimmt, kann es von einem XAML-Prozessor als anfügbarer Membernutzungspfad interpretiert werden, auch wenn dies nicht Ihre Absicht war.</span><span class="sxs-lookup"><span data-stu-id="43891-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="43891-169">Der GetPropertyName-Accessor</span><span class="sxs-lookup"><span data-stu-id="43891-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="43891-170">Die Signatur `GetPropertyName` für den Accessor muss sein:</span><span class="sxs-lookup"><span data-stu-id="43891-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="43891-171">Das `target`-Objekt kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="43891-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="43891-172">Sie können dies verwenden, um die Verwendung Ihres anfügbaren Mitglieds zu erweitern. Verwendungen außerhalb des beabsichtigten Bereichs werden ungültige Cast-Ausnahmen auslösen, die dann durch einen XAML-Analysefehler angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="43891-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="43891-173">Der Parametername `target` ist keine Anforderung, `target` wird aber in den meisten Implementierungen konventionell benannt.</span><span class="sxs-lookup"><span data-stu-id="43891-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="43891-174">Der Rückgabewert kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="43891-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="43891-175">Um eine <xref:System.ComponentModel.TypeConverter> aktivierte Textsyntax für die Attributverwendung <xref:System.ComponentModel.TypeConverterAttribute> des `GetPropertyName` anfügbaren Elements zu unterstützen, gelten Sie für den Accessor.</span><span class="sxs-lookup"><span data-stu-id="43891-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="43891-176">Die Anwendung `get` auf `set` die anstelle der kann nicht-intuitiv erscheinen; Diese Konvention kann jedoch das Konzept der schreibgeschützten anfügbaren Member unterstützen, die serialisierbar sind, was in Designerszenarien nützlich ist.</span><span class="sxs-lookup"><span data-stu-id="43891-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="43891-177">Der SetPropertyName-Accessor</span><span class="sxs-lookup"><span data-stu-id="43891-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="43891-178">Die Signatur `SetPropertyName` für den Accessor muss sein:</span><span class="sxs-lookup"><span data-stu-id="43891-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="43891-179">Das `target` Objekt kann als spezifischerer Typ in Ihrer Implementierung angegeben werden, mit der gleichen Logik und den gleichen Folgen wie im vorherigen Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="43891-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="43891-180">Das `value`-Objekt kann als spezifischerer Typ in Ihrer Implementierung angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="43891-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="43891-181">Denken Sie daran, dass der Wert für diese Methode die Eingabe ist, die von der XAML-Verwendung stammt, in der Regel in Attributform.</span><span class="sxs-lookup"><span data-stu-id="43891-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="43891-182">Aus dem Attributformular muss es Eine Wertkonverterunterstützung für `GetPropertyName`eine Textsyntax geben, und Sie schreiben dem s-Accessor zu.</span><span class="sxs-lookup"><span data-stu-id="43891-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="43891-183">Anfügbis Member Stores</span><span class="sxs-lookup"><span data-stu-id="43891-183">Attachable Member Stores</span></span>

<span data-ttu-id="43891-184">Die Accessormethoden reichen in der Regel nicht aus, um eine Möglichkeit bereitzustellen, anfügbare Elementwerte in einem Objektdiagramm zu platzieren oder Werte aus dem Objektdiagramm abzurufen und ordnungsgemäß zu serialisieren.</span><span class="sxs-lookup"><span data-stu-id="43891-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="43891-185">Um diese Funktionalität `target` bereitzustellen, müssen die Objekte in den vorherigen Accessorsignaturen in der Lage sein, Werte zu speichern.</span><span class="sxs-lookup"><span data-stu-id="43891-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="43891-186">Der Speichermechanismus sollte mit dem Elementelementprinzip im Einklang stehen, dass das Element an Ziele anhängt werden kann, bei denen das anfügbisierbare Element nicht in der Mitgliederliste aufgeführt ist.</span><span class="sxs-lookup"><span data-stu-id="43891-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="43891-187">.NET XAML Services bietet eine Implementierungstechnik für <xref:System.Xaml.IAttachedPropertyStore> anfügbisierbare Memberspeicher über die APIs und <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="43891-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="43891-188"><xref:System.Xaml.IAttachedPropertyStore>wird von den XAML-Writern verwendet, um die Speicherimplementierung zu `target` ermitteln, und sollte für den Typ implementiert werden, der der Accessoren ist.</span><span class="sxs-lookup"><span data-stu-id="43891-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="43891-189">Die <xref:System.Xaml.AttachablePropertyServices> statischen APIs werden im Körper der Accessoren verwendet und <xref:System.Xaml.AttachableMemberIdentifier>verweisen auf das ansteckbare Element durch seine .</span><span class="sxs-lookup"><span data-stu-id="43891-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="43891-190">XAML-bezogene CLR-Attribute</span><span class="sxs-lookup"><span data-stu-id="43891-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="43891-191">Das korrekte Zuweisen ihrer Typen, Member und Assemblys ist wichtig, um Systeminformationen vom XAML-Typ an .NET XAML Services zu melden.</span><span class="sxs-lookup"><span data-stu-id="43891-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="43891-192">Die Meldung von XAML-Typsysteminformationen ist relevant, wenn eine der folgenden Situationen anwendung ist:</span><span class="sxs-lookup"><span data-stu-id="43891-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="43891-193">Sie beabsichtigen, Ihre Typen für die Verwendung mit XAML-Systemen zu verwenden, die direkt auf .NET XAML Services XAML-Lesegeräten und XAML-Writern basieren.</span><span class="sxs-lookup"><span data-stu-id="43891-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="43891-194">Sie definieren oder verwenden ein XAML-verwendendes Framework, das auf diesen XAML-Readern und XAML-Writern basiert.</span><span class="sxs-lookup"><span data-stu-id="43891-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="43891-195">Eine Auflistung der einzelnen XAML-bezogenen Attribute, die für die XAML-Unterstützung Ihrer benutzerdefinierten Typen relevant sind, finden Sie unter [XAML-verknüpfte CLR-Attribute für benutzerdefinierte Typen und Bibliotheken](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="43891-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="43891-196">Verwendung</span><span class="sxs-lookup"><span data-stu-id="43891-196">Usage</span></span>

<span data-ttu-id="43891-197">Die Verwendung benutzerdefinierter Typen erfordert, dass der Markupautor ein Präfix für die Assembly und den CLR-Namespace zuordnen muss, die den benutzerdefinierten Typ enthalten.</span><span class="sxs-lookup"><span data-stu-id="43891-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="43891-198">Dieses Verfahren ist in diesem Thema nicht dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="43891-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="43891-199">Zugriffsebene</span><span class="sxs-lookup"><span data-stu-id="43891-199">Access Level</span></span>

<span data-ttu-id="43891-200">XAML bietet eine Möglichkeit zum Laden und Instanziieren von Typen mit Zugriffsebene. `internal`</span><span class="sxs-lookup"><span data-stu-id="43891-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="43891-201">Diese Funktion wird bereitgestellt, damit Benutzercode eigene Typen definieren und dann diese Klassen aus Markup instanziieren kann, das ebenfalls Teil desselben Benutzercodebereichs ist.</span><span class="sxs-lookup"><span data-stu-id="43891-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="43891-202">Ein Beispiel von WPF ist immer <xref:System.Windows.Controls.UserControl> dann, wenn Benutzercode eine definiert, die als eine Möglichkeit zum Umgestalten eines UI-Verhaltens `public` gedacht ist, jedoch nicht als Teil eines möglichen Erweiterungsmechanismus, der durch Deklarieren der unterstützenden Klasse mit Zugriffsebene impliziert werden könnte.</span><span class="sxs-lookup"><span data-stu-id="43891-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="43891-203">Ein <xref:System.Windows.Controls.UserControl> solcher kann `internal` mit Zugriff deklariert werden, wenn der Sicherungscode in dieselbe Assembly kompiliert wird, von der aus als XAML-Typ verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="43891-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="43891-204">Für eine Anwendung, die XAML <xref:System.Xaml.XamlObjectWriter>unter voller `internal` Vertrauenswürdigkeit lädt und verwendet, ist das Laden von Klassen mit Zugriffsebene immer aktiviert.</span><span class="sxs-lookup"><span data-stu-id="43891-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="43891-205">Für eine Anwendung, die XAML unter teilweiser Vertrauenswürdigkeit lädt, können Sie die Merkmale der Zugriffsebene mithilfe der <xref:System.Xaml.Permissions.XamlAccessLevel> API steuern.</span><span class="sxs-lookup"><span data-stu-id="43891-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="43891-206">Außerdem müssen Verzögerungsmechanismen (z. B. das WPF-Vorlagensystem) in der Lage sein, Berechtigungen auf Zugriffsebene weiterzuleiten und für die eventuellelaufzeitauswertung beizubehalten. Dies wird intern durch <xref:System.Xaml.Permissions.XamlAccessLevel> Übergeben der Informationen behandelt.</span><span class="sxs-lookup"><span data-stu-id="43891-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="43891-207">WPF-Implementierung</span><span class="sxs-lookup"><span data-stu-id="43891-207">WPF Implementation</span></span>

<span data-ttu-id="43891-208">WPF XAML verwendet ein teilweise vertrauenswürdiges Zugriffsmodell, wobei, wenn BAML unter teilweiser Vertrauenswürdigkeit geladen wird, der Zugriff auf <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> die Assembly, die die BAML-Quelle ist, beschränkt ist.</span><span class="sxs-lookup"><span data-stu-id="43891-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="43891-209">Für den Aufschub verwendet <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> WPF als Mechanismus zum Übergeben der Informationen auf Zugriffsebene.</span><span class="sxs-lookup"><span data-stu-id="43891-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="43891-210">In der WPF XAML-Terminologie ist ein *interner Typ* ein Typ, der von derselben Assembly definiert wird und auch die referenzierende XAML enthält.</span><span class="sxs-lookup"><span data-stu-id="43891-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="43891-211">Ein solcher Typ kann über einen XAML-Namespace zugeordnet werden, der absichtlich den `xmlns:local="clr-namespace:WPFApplication1"`Assembly=-Teil einer Zuordnung auslässt, z. B. .</span><span class="sxs-lookup"><span data-stu-id="43891-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="43891-212">Wenn BAML auf einen internen `internal` Typ verweist und `GeneratedInternalTypeHelper` dieser Typ über Zugriffsebene verfügt, wird eine Klasse für die Assembly generiert.</span><span class="sxs-lookup"><span data-stu-id="43891-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="43891-213">Wenn Sie vermeiden `GeneratedInternalTypeHelper`möchten, müssen `public` Sie entweder die Zugriffsebene verwenden oder die entsprechende Klasse in eine separate Assembly einteilen und diese Assembly abhängig machen.</span><span class="sxs-lookup"><span data-stu-id="43891-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="43891-214">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="43891-214">See also</span></span>

- [<span data-ttu-id="43891-215">XAML-bezogene CLR-Attribute für benutzerdefinierte Typen und Bibliotheken</span><span class="sxs-lookup"><span data-stu-id="43891-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="43891-216">XAML-Dienste</span><span class="sxs-lookup"><span data-stu-id="43891-216">XAML Services</span></span>](../../../api/index.md)
