---
title: Codeverträge
description: Untersuchen Sie Code Verträge, die eine Möglichkeit zum Angeben von Vorbedingungen, nach Bedingungen und Objekt invarianten in Ihrem .NET-Code bieten.
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: 60f794373af75bd3f745c224e0a8c7a84192e4c4
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904142"
---
# <a name="code-contracts"></a><span data-ttu-id="4499f-103">Codeverträge</span><span class="sxs-lookup"><span data-stu-id="4499f-103">Code Contracts</span></span>

<span data-ttu-id="4499f-104">Codeverträge bieten eine Möglichkeit, Vorbedingungen, Nachbedingungen und Objektinvarianten im Code festzulegen.</span><span class="sxs-lookup"><span data-stu-id="4499f-104">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="4499f-105">Vorbedingungen sind Anforderungen, die beim Eingeben einer Methode oder Eigenschaft erfüllt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="4499f-105">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="4499f-106">Nachbedingungen beschreiben Erwartungen zu dem Zeitpunkt, zu dem die Methode oder der Eigenschaftencode beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-106">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="4499f-107">Objektinvarianten beschreiben den erwarteten Zustand für eine Klasse, die in einem einwandfreien Zustand ist.</span><span class="sxs-lookup"><span data-stu-id="4499f-107">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="4499f-108">Codeverträge enthalten Klassen zum Markieren des Codes, eine statische Analyse für die Kompilierzeitanalyse und eine Laufzeitanalyse.</span><span class="sxs-lookup"><span data-stu-id="4499f-108">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="4499f-109">Die Klassen für Codeverträge befinden sich im <xref:System.Diagnostics.Contracts>-Namespace.</span><span class="sxs-lookup"><span data-stu-id="4499f-109">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="4499f-110">Codeverträge bieten folgende Vorteile:</span><span class="sxs-lookup"><span data-stu-id="4499f-110">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="4499f-111">Verbessertes Testen: Codeverträge ermöglichen eine statische Vertragsüberprüfung, Laufzeitüberprüfung und Dokumentationsgenerierung.</span><span class="sxs-lookup"><span data-stu-id="4499f-111">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="4499f-112">Automatische Testtools: Sie können mithilfe von Codeverträgen aussagekräftigere Komponententests generieren, indem bedeutungslose Testargumente, die die Vorbedingungen nicht erfüllen, herausgefiltert werden.</span><span class="sxs-lookup"><span data-stu-id="4499f-112">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="4499f-113">Statische Überprüfung: Mit der statischen Prüfung kann bestimmt werden, ob Vertragsverletzungen vorliegen, ohne das Programm auszuführen.</span><span class="sxs-lookup"><span data-stu-id="4499f-113">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="4499f-114">Es wird nach impliziten Verträgen (wie NULL-Dereferenzierungen und Arraygrenzen) sowie nach expliziten Verträgen gesucht.</span><span class="sxs-lookup"><span data-stu-id="4499f-114">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="4499f-115">Referenzdokumentation: Der Dokumentations-Generator erweitert vorhandene XML-Dokumentationsdateien um Vertragsinformationen.</span><span class="sxs-lookup"><span data-stu-id="4499f-115">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="4499f-116">Es gibt auch Stylesheets, die mit [Sandcastle](https://github.com/EWSoftware/SHFB) verwendet werden können, sodass die generierten Dokumentationsseiten Vertragsabschnitte enthalten können.</span><span class="sxs-lookup"><span data-stu-id="4499f-116">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="4499f-117">Alle .NET Framework-Sprachen können umgehend Verträge nutzen. Sie müssen keinen speziellen Parser oder Compiler schreiben.</span><span class="sxs-lookup"><span data-stu-id="4499f-117">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="4499f-118">Mit einem Visual Studio-Add-In können Sie die Ebene der auszuführenden Codevertragsanalyse angeben.</span><span class="sxs-lookup"><span data-stu-id="4499f-118">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="4499f-119">Durch die Analysen kann überprüft werden, ob die Verträge wohlgeformt sind (Typüberprüfung und Namensauflösung), und es kann eine kompilierte Form der Verträge im Microsoft Intermediate Language(MSIL)-Format erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="4499f-119">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="4499f-120">Die Erstellung von Verträgen in Visual Studio ermöglicht die Nutzung der vom Tool bereitgestellten IntelliSense-Standardfunktionen.</span><span class="sxs-lookup"><span data-stu-id="4499f-120">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="4499f-121">Die meisten Methoden in der Vertragsklasse werden bedingt kompiliert. Das heißt, dass der Compiler nur dann Aufrufe dieser Methoden ausgibt, wenn Sie mithilfe der `#define`-Anweisung ein Sonderzeichen (CONTRACTS_FULL) definieren.</span><span class="sxs-lookup"><span data-stu-id="4499f-121">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="4499f-122">CONTRACTS_FULL ermöglicht das Schreiben von Verträgen in den Code ohne Verwendung von `#ifdef`-Anweisungen. Sie können unterschiedliche Builds erstellen, von denen einige Verträge enthalten und andere keine Verträge enthalten.</span><span class="sxs-lookup"><span data-stu-id="4499f-122">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="4499f-123">Tools und ausführliche Anweisungen zur Verwendung von Code Verträgen finden Sie unter [Code Verträge](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) auf der Visual Studio Marketplace-Website.</span><span class="sxs-lookup"><span data-stu-id="4499f-123">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="4499f-124">Preconditions</span><span class="sxs-lookup"><span data-stu-id="4499f-124">Preconditions</span></span>

<span data-ttu-id="4499f-125">Sie können Vorbedingungen mit der <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType>-Methode ausdrücken.</span><span class="sxs-lookup"><span data-stu-id="4499f-125">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4499f-126">Vorbedingungen geben den Zustand beim Aufrufen einer Methode an.</span><span class="sxs-lookup"><span data-stu-id="4499f-126">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="4499f-127">Sie werden im Allgemeinen zum Angeben gültiger Parameterwerte verwendet.</span><span class="sxs-lookup"><span data-stu-id="4499f-127">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="4499f-128">Auf alle Member, die in Vorbedingungen erwähnt werden, muss mindestens wie auf die Methode selbst zugegriffen werden können. Andernfalls wird die Vorbedingung möglicherweise nicht von allen Aufrufern einer Methode verstanden.</span><span class="sxs-lookup"><span data-stu-id="4499f-128">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="4499f-129">Die Bedingung darf keine Nebeneffekte haben.</span><span class="sxs-lookup"><span data-stu-id="4499f-129">The condition must have no side-effects.</span></span> <span data-ttu-id="4499f-130">Das Laufzeitverhalten fehlerhafter Vorbedingungen wird durch die Laufzeitanalyse bestimmt.</span><span class="sxs-lookup"><span data-stu-id="4499f-130">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="4499f-131">Die folgende Vorbedingung drückt z. B. aus, dass der Parameter `x` nicht NULL sein darf.</span><span class="sxs-lookup"><span data-stu-id="4499f-131">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="4499f-132">Wenn im Code bei Verletzung einer Vorbedingung eine bestimmte Ausnahme ausgelöst werden soll, können Sie die generische Überladung von <xref:System.Diagnostics.Contracts.Contract.Requires%2A> wie folgt verwenden:</span><span class="sxs-lookup"><span data-stu-id="4499f-132">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="4499f-133">Ältere "Requires"-Anweisungen</span><span class="sxs-lookup"><span data-stu-id="4499f-133">Legacy Requires Statements</span></span>

<span data-ttu-id="4499f-134">Der Großteil des Codes enthält einige Parametervalidierungsfunktionen in Form des `if`-`then`-`throw`-Codes.</span><span class="sxs-lookup"><span data-stu-id="4499f-134">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="4499f-135">Die Vertragstools erkennen diese Anweisungen in den folgenden Fällen als Vorbedingungen:</span><span class="sxs-lookup"><span data-stu-id="4499f-135">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="4499f-136">Die Anweisungen werden vor allen anderen Anweisungen in einer Methode angezeigt.</span><span class="sxs-lookup"><span data-stu-id="4499f-136">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="4499f-137">Auf den gesamten Satz solcher Anweisungen folgt ein expliziter <xref:System.Diagnostics.Contracts.Contract>-Methodenaufruf, beispielsweise ein Aufruf der <xref:System.Diagnostics.Contracts.Contract.Requires%2A>-, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>-, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>- oder <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="4499f-137">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="4499f-138">Wenn `if`-`then`-`throw`-Anweisungen in dieser Form angezeigt werden, erkennen die Tools sie als ältere `requires`-Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="4499f-138">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="4499f-139">Wenn keine anderen Verträge auf die `if`-`then`-`throw`-Sequenz folgen, beenden Sie den Code mit der <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="4499f-139">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="4499f-140">Beachten Sie, dass die Bedingung im vorangehenden Test eine negierte Vorbedingung ist.</span><span class="sxs-lookup"><span data-stu-id="4499f-140">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="4499f-141">(Die tatsächliche Vorbedingung wäre `x != null` .) Eine negatierte Vorbedingung ist hochgradig eingeschränkt: Sie muss wie im vorherigen Beispiel geschrieben werden. Das heißt, Sie sollte keine `else` Klauseln enthalten, und der Text der- `then` Klausel muss eine einzelne- `throw` Anweisung sein.</span><span class="sxs-lookup"><span data-stu-id="4499f-141">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="4499f-142">Der `if`-Test unterliegt Reinheits- und Sichtbarkeitsregeln (siehe [Verwendungsrichtlinien](#usage_guidelines)), aber der `throw`-Ausdruck unterliegt nur Reinheitsregeln.</span><span class="sxs-lookup"><span data-stu-id="4499f-142">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="4499f-143">Der Typ der ausgelösten Ausnahme muss jedoch genauso sichtbar sein wie die Methode, in der der Vertrag vorkommt.</span><span class="sxs-lookup"><span data-stu-id="4499f-143">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="4499f-144">Nachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-144">Postconditions</span></span>

<span data-ttu-id="4499f-145">Nachbedingungen sind Verträge für den Zustand einer Methode, wenn diese beendet wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-145">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="4499f-146">Die Nachbedingung wird unmittelbar vor dem Beenden einer Methode überprüft.</span><span class="sxs-lookup"><span data-stu-id="4499f-146">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="4499f-147">Das Laufzeitverhalten fehlerhafter Nachbedingungen wird durch die Laufzeitanalyse bestimmt.</span><span class="sxs-lookup"><span data-stu-id="4499f-147">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="4499f-148">Im Gegensatz zu Vorbedingungen können Nachbedingungen mit geringerer Sichtbarkeit auf Member verweisen.</span><span class="sxs-lookup"><span data-stu-id="4499f-148">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="4499f-149">Ein Client ist möglicherweise nicht in der Lage, einige der Informationen zu verstehen oder zu verwenden, die durch eine Nachbedingung mithilfe eines privaten Zustands ausgedrückt wurden. Dadurch wird die Fähigkeit des Clients, die Methode ordnungsgemäß zu verwenden, jedoch nicht beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="4499f-149">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="4499f-150">Standardmäßige Nachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-150">Standard Postconditions</span></span>

<span data-ttu-id="4499f-151">Sie können standardmäßige Nachbedingungen mit der <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>-Methode ausdrücken.</span><span class="sxs-lookup"><span data-stu-id="4499f-151">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="4499f-152">Nachbedingungen drücken eine Bedingung aus, die bei normaler Beendigung der Methode `true` sein muss.</span><span class="sxs-lookup"><span data-stu-id="4499f-152">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="4499f-153">Ausnahmenachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-153">Exceptional Postconditions</span></span>

<span data-ttu-id="4499f-154">Ausnahmenachbedingungen sind Nachbedingungen, die `true` sein sollten, wenn eine bestimmte Ausnahme von einer Methode ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-154">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="4499f-155">Sie können diese Nachbedingungen mit der <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>-Methode (wie im folgenden Beispiel gezeigt) angeben.</span><span class="sxs-lookup"><span data-stu-id="4499f-155">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="4499f-156">Das Argument ist die Bedingung, die `true` sein muss, wenn eine Ausnahme ausgelöst wird, bei der es sich um einen Untertyp von `T` handelt.</span><span class="sxs-lookup"><span data-stu-id="4499f-156">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="4499f-157">Es gibt einige Ausnahmetypen, die nur erschwert in einer Ausnahmenachbedingung verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="4499f-157">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="4499f-158">Beispielsweise erfordert die Verwendung des <xref:System.Exception>-Typs für `T`, dass die Bedingung durch die Methode unabhängig vom Typ der ausgelösten Ausnahme gewährleistet wird, auch wenn es sich um einen Stapelüberlauf oder eine andere nicht kontrollierbare Ausnahme handelt.</span><span class="sxs-lookup"><span data-stu-id="4499f-158">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="4499f-159">Verwenden Sie Ausnahmenachbedingungen nur für bestimmte Ausnahmen, die beim Aufruf eines Members ausgelöst werden könnten, z. B. wenn eine <xref:System.InvalidTimeZoneException> für einen <xref:System.TimeZoneInfo>-Methodenaufruf ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-159">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="4499f-160">Besondere Nachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-160">Special Postconditions</span></span>

<span data-ttu-id="4499f-161">Die folgenden Methoden können nur innerhalb von Nachbedingungen verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="4499f-161">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="4499f-162">Mit dem Ausdruck `Contract.Result<T>()`, in dem `T` durch den Rückgabetyp der Methode ersetzt wird, können Sie auf Methodenrückgabewerte in Nachbedingungen verweisen.</span><span class="sxs-lookup"><span data-stu-id="4499f-162">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="4499f-163">Wenn der Compiler den Typ nicht ableiten kann, müssen Sie ihn explizit angeben.</span><span class="sxs-lookup"><span data-stu-id="4499f-163">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="4499f-164">Der C#-Compiler kann beispielsweise keine Typen für Methoden ableiten, die keine Argumente akzeptieren. Daher ist die folgende Nachbedingung erforderlich: `Contract.Ensures(0 <Contract.Result<int>())`-Methoden mit dem Rückgabetyp `void` können in ihren Nachbedingungen nicht auf `Contract.Result<T>()` verweisen.</span><span class="sxs-lookup"><span data-stu-id="4499f-164">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="4499f-165">Ein prestate-Wert in einer Nachbedingung verweist auf den Wert eines Ausdrucks am Anfang einer Methode oder Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="4499f-165">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="4499f-166">Er verwendet den Ausdruck `Contract.OldValue<T>(e)`, wobei `T` der Typ von `e` ist.</span><span class="sxs-lookup"><span data-stu-id="4499f-166">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="4499f-167">Sie können das generische Typargument weglassen, wenn der Compiler den Typ ableiten kann.</span><span class="sxs-lookup"><span data-stu-id="4499f-167">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="4499f-168">(Beispielsweise leitet der c#-Compiler immer den-Typ ein, da er ein Argument annimmt.) Es gibt mehrere Einschränkungen hinsichtlich der möglichen Bedingungen in `e` und den Kontexten, in denen ein Alter Ausdruck auftreten kann.</span><span class="sxs-lookup"><span data-stu-id="4499f-168">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="4499f-169">Ein alter Ausdruck darf keinen anderen alten Ausdruck enthalten.</span><span class="sxs-lookup"><span data-stu-id="4499f-169">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="4499f-170">Vor allem muss ein alter Ausdruck auf einen Wert verweisen, der im Vorbedingungszustand der Methode vorhanden war.</span><span class="sxs-lookup"><span data-stu-id="4499f-170">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="4499f-171">Es muss sich also um einen Ausdruck handeln, der ausgewertet werden kann, solange die Vorbedingung der Methode `true` ist.</span><span class="sxs-lookup"><span data-stu-id="4499f-171">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="4499f-172">Nachfolgend finden Sie mehrere Instanzen dieser Regel.</span><span class="sxs-lookup"><span data-stu-id="4499f-172">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="4499f-173">Der Wert muss im Vorbedingungszustand der Methode vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="4499f-173">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="4499f-174">Um auf ein Feld für ein Objekt zu verweisen, müssen die Vorbedingungen sicherstellen, dass das Objekt immer ungleich NULL ist.</span><span class="sxs-lookup"><span data-stu-id="4499f-174">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="4499f-175">Sie können nicht auf den Rückgabewert der Methode in einem alten Ausdruck verweisen:</span><span class="sxs-lookup"><span data-stu-id="4499f-175">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="4499f-176">Sie können nicht auf `out`-Parameter in einem alten Ausdruck verweisen.</span><span class="sxs-lookup"><span data-stu-id="4499f-176">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="4499f-177">Ein alter Ausdruck kann nicht von der gebundenen Variablen eines Quantifizierers abhängen, wenn der Bereich des Quantifizierers vom Rückgabewert der Methode abhängt:</span><span class="sxs-lookup"><span data-stu-id="4499f-177">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="4499f-178">Ein alter Ausdruck kann nur auf den Parameter des anonymen Delegaten in einem <xref:System.Diagnostics.Contracts.Contract.ForAll%2A>- oder <xref:System.Diagnostics.Contracts.Contract.Exists%2A>-Aufruf verweisen, wenn er als Indexer oder Argument für einen Methodenaufruf verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="4499f-178">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="4499f-179">Ein alter Ausdruck kann nicht im Text eines anonymen Delegaten auftreten, wenn der Wert des alten Ausdrucks von einem der Parameter des anonymen Delegaten abhängt, sofern der anonyme Delegat kein Argument für die <xref:System.Diagnostics.Contracts.Contract.ForAll%2A>- oder <xref:System.Diagnostics.Contracts.Contract.Exists%2A>-Methode ist:</span><span class="sxs-lookup"><span data-stu-id="4499f-179">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="4499f-180">`Out`-Parameter stellen ein Problem dar, weil Verträge vor dem Text der Methode angezeigt werden und die meisten Compiler keine Verweise auf `out`-Parameter in Nachbedingungen zulassen.</span><span class="sxs-lookup"><span data-stu-id="4499f-180">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="4499f-181">Zur Lösung dieses Problems steht in der <xref:System.Diagnostics.Contracts.Contract>-Klasse die <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>-Methode zur Verfügung, die eine Nachbedingung auf Grundlage eines `out`-Parameters zulässt.</span><span class="sxs-lookup"><span data-stu-id="4499f-181">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="4499f-182">Wie bei der <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>-Methode können Sie den generischen Typparameter weglassen, wenn der Compiler den Typ ableiten kann.</span><span class="sxs-lookup"><span data-stu-id="4499f-182">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="4499f-183">Der Vertrags-Rewriter ersetzt den Methodenaufruf durch den Wert des `out`-Parameters.</span><span class="sxs-lookup"><span data-stu-id="4499f-183">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="4499f-184">Die <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>-Methode kann nur in Nachbedingungen angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="4499f-184">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="4499f-185">Das Argument für die Methode muss ein `out`-Parameter oder ein Feld eines strukturbezogenen `out`-Parameters sein.</span><span class="sxs-lookup"><span data-stu-id="4499f-185">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="4499f-186">Letzteres ist auch hilfreich, wenn auf Felder in der Nachbedingung eines Strukturkonstruktors verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-186">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="4499f-187">Derzeit kann von den Tools für die Codevertragsanalyse nicht überprüft werden, ob `out`-Parameter ordnungsgemäß initialisiert werden, und deren Nennung in der Nachbedingung wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="4499f-187">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="4499f-188">Wenn also im vorherigen Beispiel in der Zeile nach dem Vertrag der Wert von `x` verwendet worden wäre, statt der Zeile eine ganze Zahl zuzuweisen, würde ein Compiler nicht den entsprechenden Fehler ausgeben.</span><span class="sxs-lookup"><span data-stu-id="4499f-188">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="4499f-189">In einem Build, in dem das CONTRACTS_FULL-Präprozessorsymbol nicht definiert ist (z.B. in einem Releasebuild), gibt der Compiler jedoch einen Fehler aus.</span><span class="sxs-lookup"><span data-stu-id="4499f-189">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="4499f-190">Invarianten</span><span class="sxs-lookup"><span data-stu-id="4499f-190">Invariants</span></span>

<span data-ttu-id="4499f-191">Objektinvarianten sind Bedingungen, die für jede Instanz einer Klasse "true" sein sollten, wenn das Objekt für einen Client sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="4499f-191">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="4499f-192">Sie drücken die Bedingungen aus, unter denen das Objekt als korrekt betrachtet wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-192">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="4499f-193">Die invarianten Methoden werden identifiziert, indem sie mit dem <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>-Attribut markiert werden.</span><span class="sxs-lookup"><span data-stu-id="4499f-193">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="4499f-194">Die invarianten Methoden dürfen keinen Code enthalten. Eine Ausnahme bildet eine Sequenz von Aufrufen der <xref:System.Diagnostics.Contracts.Contract.Invariant%2A>-Methode, bei denen (wie im folgenden Beispiel gezeigt) jeweils eine einzelne Invariante angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-194">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="4499f-195">Invarianten werden durch das CONTRACTS_FULL-Präprozessorsymbol bedingt definiert.</span><span class="sxs-lookup"><span data-stu-id="4499f-195">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="4499f-196">Bei der Laufzeitüberprüfung werden die Invarianten am Ende jeder öffentlichen Methode überprüft.</span><span class="sxs-lookup"><span data-stu-id="4499f-196">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="4499f-197">Wenn eine Invariante eine öffentliche Methode in der gleichen Klasse erwähnt, wird die Invariantenüberprüfung, die normalerweise am Ende dieser öffentlichen Methode erfolgt, deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="4499f-197">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="4499f-198">Stattdessen wird die Überprüfung nur am Ende des äußersten Methodenaufrufs dieser Klasse ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="4499f-198">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="4499f-199">Dies geschieht auch, wenn die Klasse wegen eines Aufrufs einer Methode in einer anderen Klasse erneut eingegeben wird.</span><span class="sxs-lookup"><span data-stu-id="4499f-199">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="4499f-200">Invarianten werden nicht für einen objektfinalizer und eine- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung geprüft.</span><span class="sxs-lookup"><span data-stu-id="4499f-200">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="4499f-201">Verwendungsrichtlinien</span><span class="sxs-lookup"><span data-stu-id="4499f-201">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="4499f-202">Verträge – Reihenfolge</span><span class="sxs-lookup"><span data-stu-id="4499f-202">Contract Ordering</span></span>

<span data-ttu-id="4499f-203">In der folgenden Tabelle wird die Reihenfolge der Elemente aufgeführt, die Sie beim Schreiben von Methodenverträgen verwenden sollten.</span><span class="sxs-lookup"><span data-stu-id="4499f-203">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="4499f-204">Abwärtskompatible öffentliche Vorbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-204">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="4499f-205">Alle öffentlichen Vorbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-205">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="4499f-206">Alle öffentlichen (normalen) Nachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-206">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="4499f-207">Alle öffentlichen Ausnahmenachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-207">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="4499f-208">Alle privaten/internen (normalen) Nachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-208">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="4499f-209">Alle privaten/internen Ausnahmenachbedingungen</span><span class="sxs-lookup"><span data-stu-id="4499f-209">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="4499f-210">Rufen Sie bei Verwendung von `if`-`then`-`throw`-Formatvorbedingungen ohne andere Verträge <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> auf, um anzugeben, dass es sich bei allen vorherigen If-Überprüfungen um Vorbedingungen handelt.</span><span class="sxs-lookup"><span data-stu-id="4499f-210">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="4499f-211">Reinheit</span><span class="sxs-lookup"><span data-stu-id="4499f-211">Purity</span></span>

<span data-ttu-id="4499f-212">Alle Methoden, die in einem Vertrag aufgerufen werden, müssen "rein" sein, was bedeutet, dass kein bereits vorhandener Zustand aktualisiert werden darf.</span><span class="sxs-lookup"><span data-stu-id="4499f-212">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="4499f-213">Mit einer reinen Methode können Objekte geändert werden, die nach Eintragung in die reine Methode erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="4499f-213">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="4499f-214">Bei Verwendung von Codevertragstools wird derzeit davon ausgegangen, dass die folgenden Codeelemente rein sind:</span><span class="sxs-lookup"><span data-stu-id="4499f-214">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="4499f-215">Methoden, die mit dem <xref:System.Diagnostics.Contracts.PureAttribute> markiert sind.</span><span class="sxs-lookup"><span data-stu-id="4499f-215">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="4499f-216">Typen, die mit dem <xref:System.Diagnostics.Contracts.PureAttribute> markiert sind (das Attribut gilt für alle Methoden des Typs).</span><span class="sxs-lookup"><span data-stu-id="4499f-216">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="4499f-217">Get-Eigenschaftenaccessoren</span><span class="sxs-lookup"><span data-stu-id="4499f-217">Property get accessors.</span></span>

- <span data-ttu-id="4499f-218">Operatoren (statische Methoden, deren Namen mit „op“ beginnen, die einen oder zwei Parameter und einen nicht leeren Rückgabetyp aufweisen).</span><span class="sxs-lookup"><span data-stu-id="4499f-218">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="4499f-219">Eine beliebige Methode, deren vollqualifizierter Name mit "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path" oder "System.Type" beginnt.</span><span class="sxs-lookup"><span data-stu-id="4499f-219">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="4499f-220">Ein beliebiger aufgerufener Delegat, vorausgesetzt, dass dem Delegattyp selbst das <xref:System.Diagnostics.Contracts.PureAttribute> zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="4499f-220">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="4499f-221">Die Delegattypen <xref:System.Predicate%601?displayProperty=nameWithType> und <xref:System.Comparison%601?displayProperty=nameWithType> werden als rein eingestuft.</span><span class="sxs-lookup"><span data-stu-id="4499f-221">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="4499f-222">Sichtbarkeit</span><span class="sxs-lookup"><span data-stu-id="4499f-222">Visibility</span></span>

<span data-ttu-id="4499f-223">Alle in einem Vertrag erwähnten Member müssen mindestens ebenso sichtbar sein wie die Methode, in der sie angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="4499f-223">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="4499f-224">Ein privates Feld kann beispielsweise nicht in einer Vorbedingung für eine öffentliche Methode erwähnt werden. Clients können keinen derartigen Vertrag überprüfen, bevor sie die Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="4499f-224">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="4499f-225">Wenn das Feld jedoch mit dem <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute> markiert wird, unterliegt es diesen Regeln nicht.</span><span class="sxs-lookup"><span data-stu-id="4499f-225">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="4499f-226">Beispiel</span><span class="sxs-lookup"><span data-stu-id="4499f-226">Example</span></span>

<span data-ttu-id="4499f-227">Im folgenden Beispiel wird die Verwendung von Codeverträgen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="4499f-227">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
