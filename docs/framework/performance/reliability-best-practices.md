---
title: Empfohlene Vorgehensweisen für die Zuverlässigkeit
description: Weitere Informationen finden Sie unter Bewährte Methoden für die Zuverlässigkeit in .NET-Host basierten Server Anwendungen, z. b. SQL Server. Verhindern, dass Sie Ressourcenverlusten oder heruntergefahren werden.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474240"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="f8830-104">Empfohlene Vorgehensweisen für die Zuverlässigkeit</span><span class="sxs-lookup"><span data-stu-id="f8830-104">Reliability Best Practices</span></span>

<span data-ttu-id="f8830-105">Die folgenden Zuverlässigkeitsregeln sind auf SQL Server ausgerichtet, jedoch gelten sie auch für jede hostbasierte Serveranwendung.</span><span class="sxs-lookup"><span data-stu-id="f8830-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="f8830-106">Es ist äußerst wichtig, dass es bei Servern wie SQL Server zu keinem Ressourcenverlust kommt und dass diese nicht zum Absturz gebracht werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="f8830-107">Dies kann jedoch nicht erreicht werden, indem Zurücksetzungscode für jede Methode geschrieben wird, die den Zustand eines Objekts ändert.</span><span class="sxs-lookup"><span data-stu-id="f8830-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="f8830-108">Das Ziel ist nicht, 100 Prozent zuverlässigen verwalteten Code zu schreiben, der mit Zurücksetzungscode nach Fehlern an einer beliebigen Stelle wiederhergestellt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="f8830-109">Das wäre eine schwierige Aufgabe mit wenig Aussicht auf Erfolg.</span><span class="sxs-lookup"><span data-stu-id="f8830-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="f8830-110">Die Common Language Runtime (CLR) kann keine ausreichend starken Garantien für verwalteten Code bereitstellen, um das Schreiben von perfektem Code möglich zu machen.</span><span class="sxs-lookup"><span data-stu-id="f8830-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="f8830-111">Beachten Sie, dass SQL Server im Gegensatz zu ASP.NET nur einen Prozess verwendet, der nicht wiederverwendet werden kann, ohne dass eine Datenbank für eine unzumutbar lange Zeit außer Betrieb genommen wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="f8830-112">Mit diesen schwächeren Garantien und der Ausführung in einem einzelnen Prozess basiert die Zuverlässigkeit auf dem Beenden von Threads oder ggf. dem Wiederverwenden von Anwendungsdomänen sowie dem Ergreifen von Vorsichtsmaßnahmen, um sicherzustellen, dass Betriebssystemressourcen wie Handles oder Arbeitsspeicher nicht verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="f8830-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="f8830-113">Selbst mit dieser einfacheren Zuverlässigkeitseinschränkung bestehen immer noch erhebliche Zuverlässigkeitsanforderungen:</span><span class="sxs-lookup"><span data-stu-id="f8830-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="f8830-114">Betriebssystemressourcen dürfen niemals verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="f8830-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="f8830-115">Alle verwalteten Sperren für die CLR müssen identifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="f8830-116">Ein anwendungsdomänenübergreifender freigegebener Zustand darf niemals unterbrochen werden, damit das Wiederverwenden von <xref:System.AppDomain> reibungslos funktioniert.</span><span class="sxs-lookup"><span data-stu-id="f8830-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="f8830-117">Obwohl es theoretisch möglich ist, verwalteten Code zu schreiben, um <xref:System.Threading.ThreadAbortException>-, <xref:System.StackOverflowException>- und <xref:System.OutOfMemoryException>-Ausnahmen zu behandeln, kann von Entwicklern nicht erwartet werden, derart stabilen Code für die gesamte Anwendung schreiben.</span><span class="sxs-lookup"><span data-stu-id="f8830-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="f8830-118">Aus diesem Grund führen Out-of-band-Ausnahmen dazu, dass der ausführende Thread beendet wird. Wenn der beendete Thread einen Freigabezustand geändert hat, was dadurch ermittelt werden kann, ob im Thread eine Sperre enthalten ist, wird <xref:System.AppDomain> nicht geladen.</span><span class="sxs-lookup"><span data-stu-id="f8830-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="f8830-119">Wenn eine Methode, die einen freigegebenen Zustand ändert, beendet wird, ist der Zustand inkonsistent, da es nicht möglich ist, verlässlichen Zurücksetzungscode zu schreiben, um den Freigabezustand zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="f8830-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="f8830-120">In der Version 2.0 von .NET Framework ist SQL Server der einzige Host, der Zuverlässigkeit erfordert.</span><span class="sxs-lookup"><span data-stu-id="f8830-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="f8830-121">Wenn Ihre Assembly auf SQL Server ausgeführt wird, sollten Sie Zuverlässigkeit für jeden Teil dieser Assembly gewährleisten, selbst wenn bestimmte Funktionen vorhanden sind, die bei der Ausführung in der Datenbank deaktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="f8830-122">Dies ist erforderlich, da die Codeanalyse-Engine Code auf Assemblyebene untersucht und nicht von deaktiviertem Code unterscheiden kann.</span><span class="sxs-lookup"><span data-stu-id="f8830-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="f8830-123">Eine andere Überlegung bei der SQL Server-Programmierung ist, dass SQL Server alles in einem Prozess ausführt. Außerdem wird die <xref:System.AppDomain>-Wiederverwendung zur Bereinigung aller Ressourcen wie Arbeitsspeicher und Betriebssystemhandles verwendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="f8830-124">Sie können sich nicht auf Finalizer, Destruktoren oder `try/finally`-Blöcke für Zurücksetzungscode verlassen.</span><span class="sxs-lookup"><span data-stu-id="f8830-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="f8830-125">Diese können unterbrochen oder nicht aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="f8830-126">Asynchrone Ausnahmen wie <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> und <xref:System.OutOfMemoryException> können an unerwarteten Stellen und prinzipiell in jeder Computeranweisung auftreten.</span><span class="sxs-lookup"><span data-stu-id="f8830-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="f8830-127">Bei verwalteten Threads handelt es sich nicht notwendigerweise um Win32-Threads in SQL. Es kann sich auch um Fibers handeln.</span><span class="sxs-lookup"><span data-stu-id="f8830-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="f8830-128">Ein prozess- oder anwendungsdomänenübergreifender veränderlicher Freigabezustand lässt sich nur mit großem Aufwand sicher verändern und sollte wenn möglich vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="f8830-129">Probleme aufgrund von nicht ausreichendem Arbeitsspeicher sind in SQL Server nicht selten.</span><span class="sxs-lookup"><span data-stu-id="f8830-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="f8830-130">Wenn in SQL Server gehostete Bibliotheken ihren Freigabezustand nicht ordnungsgemäß aktualisieren, ist die Wahrscheinlichkeit hoch, dass der Code nicht wiederhergestellt wird, bis die Datenbank neu gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="f8830-131">Zudem ist es in einigen Extremfällen möglich, dass dadurch beim SQL Server-Prozess ein Fehler auftritt, wodurch die Datenbank neu gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="f8830-132">Ein Neustart der Datenbank kann zum Absturz einer Website führen oder sich auf Unternehmensvorgänge auswirken, wobei die Verfügbarkeit beeinträchtigt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="f8830-133">Ein langsamer Verlust von Betriebssystemressourcen wie Arbeitsspeicher oder Handles kann dazu führen, dass beim Server ein Fehler auftritt, wobei Handles ohne Möglichkeit zur Wiederherstellung zugewiesen werden. Möglicherweise kann auch die Leistung des Servers langsam abnehmen, wobei die Verfügbarkeit der Anwendung eines Kunden reduziert wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="f8830-134">Natürlich sollen diese Szenarios vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="f8830-135">Best Practices-Regeln</span><span class="sxs-lookup"><span data-stu-id="f8830-135">Best practice rules</span></span>

<span data-ttu-id="f8830-136">In der Einführung wurde der Fokus darauf gelegt, auf welche Fehler im Code Review für den verwalteten Code, der auf dem Server ausgeführt wird, geprüft werden muss, um die Stabilität und Zuverlässigkeit des Frameworks zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="f8830-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="f8830-137">All diese Überprüfungen werden allgemein empfohlen und sind auf einem Server ein absolutes Muss.</span><span class="sxs-lookup"><span data-stu-id="f8830-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="f8830-138">Bei einem Deadlock oder einer Ressourceneinschränkung bricht SQL Server einen Thread ab oder entfernt eine <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="f8830-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="f8830-139">In diesem Fall wird nur Zurücksetzungscode in einem eingeschränkten Ausführungsbereich (CER) garantiert ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f8830-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="f8830-140">Verwenden von SafeHandle zur Vermeidung von Ressourcenverlusten</span><span class="sxs-lookup"><span data-stu-id="f8830-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="f8830-141">Falls <xref:System.AppDomain> entladen wird, können Sie sich nicht auf die Ausführung von `finally`-Blöcken oder Finalizern verlassen. Daher ist es wichtig, den Zugriff auf alle Betriebssystemressourcen über die <xref:System.Runtime.InteropServices.SafeHandle>-Klasse anstatt über <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef> oder ähnliche Klassen zu abstrahieren.</span><span class="sxs-lookup"><span data-stu-id="f8830-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="f8830-142">Dies ermöglicht der CLR, die von Ihnen verwendeten Handles selbst im Fall des Entfernens von <xref:System.AppDomain> nachzuverfolgen und zu schließen.</span><span class="sxs-lookup"><span data-stu-id="f8830-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="f8830-143"><xref:System.Runtime.InteropServices.SafeHandle> verwendet ein Objekt der Klasse CriticalFinalizerObject als Finalizer, der von der CLR immer ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="f8830-144">Das Betriebssystemhandle wird vom Moment seiner Erstellung in einem SafeHandle bis zu dem Moment gespeichert, in dem es freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="f8830-145">Es gibt kein Zeitfenster, in dem eine <xref:System.Threading.ThreadAbortException> den Verlust eines Handles verursachen kann.</span><span class="sxs-lookup"><span data-stu-id="f8830-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="f8830-146">Darüber hinaus führt der Plattformaufruf eine Verweiszählung des Handles aus, was eine genaue Nachverfolgung der Lebenszeit des Handles ermöglicht. Hierdurch wird ein Sicherheitsproblem mit einer Racebedingung zwischen `Dispose` und einer Methode verhindert, die das Handle momentan verwendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="f8830-147">Die meisten Klassen, die derzeit über einen Finalizer zum einfachen Bereinigen eines Betriebssystemhandles verfügen, werden den Finalizer nicht mehr benötigen.</span><span class="sxs-lookup"><span data-stu-id="f8830-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="f8830-148">Stattdessen wird sich der Finalizer in der abgeleiteten <xref:System.Runtime.InteropServices.SafeHandle>-Klasse befinden.</span><span class="sxs-lookup"><span data-stu-id="f8830-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="f8830-149">Beachten Sie, dass <xref:System.Runtime.InteropServices.SafeHandle> kein Ersatz für <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> ist.</span><span class="sxs-lookup"><span data-stu-id="f8830-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="f8830-150">Es bestehen immer noch potenzielle Vorteile im Hinblick auf Ressourcenkonflikte und Leistung gegenüber dem expliziten Löschen von Betriebssystemressourcen.</span><span class="sxs-lookup"><span data-stu-id="f8830-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="f8830-151">Beachten Sie aber, dass `finally`-Blöcke, die Ressourcen explizit löschen, möglicherweise nicht vollständig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="f8830-152"><xref:System.Runtime.InteropServices.SafeHandle> ermöglicht es Ihnen, Ihre eigene <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode zu implementieren, die Anweisungen zum Freigeben des Handles ausführt. Beispiele für derartige Anweisungen sind das Übergeben des Zustands an eine Routine zur Freigabe von Betriebssystemhandles oder das Freigeben von mehreren Handles in einer Schleife.</span><span class="sxs-lookup"><span data-stu-id="f8830-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="f8830-153">Die CLR garantiert, dass diese Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="f8830-154">Es liegt in der Verantwortung des Erstellers der <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Implementierung, sicherzustellen, dass das Handle in allen Fällen freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="f8830-155">Wird dies nicht sichergestellt, geht das Handle verloren, was oft dazu führt, dass native Ressourcen verloren gehen, die dem Handle zugewiesen sind.</span><span class="sxs-lookup"><span data-stu-id="f8830-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="f8830-156">Daher ist es wichtig, abgeleitete <xref:System.Runtime.InteropServices.SafeHandle>-Klassen so zu strukturieren, dass die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Implementierung nicht die Zuordnung von Ressourcen erfordert, die zum Zeitpunkt des Aufrufs möglicherweise nicht verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="f8830-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="f8830-157">Beachten Sie, dass es zulässig ist, Methoden aufzurufen, die möglicherweise innerhalb der Implementierung von <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> fehlschlagen, vorausgesetzt, Ihr Code kann mit solchen Fehlern umgehen und die Vereinbarung zum Freigeben des nativen Handles erfüllen.</span><span class="sxs-lookup"><span data-stu-id="f8830-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="f8830-158">Für das Debuggen verfügt <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> über einen Rückgabewert vom Typ <xref:System.Boolean>, der auf `false` gesetzt werden kann, wenn ein schwerwiegender Fehler auftritt, der die Freigabe der Ressource verhindert.</span><span class="sxs-lookup"><span data-stu-id="f8830-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="f8830-159">Auf diese Weise wird der MDA [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) aktiviert, um im aktivierten Zustand bei der Identifizierung des Problems zu helfen.</span><span class="sxs-lookup"><span data-stu-id="f8830-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="f8830-160">Er wirkt sich auf keine andere Weise auf die Laufzeit aus. <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> wird nicht erneut für die dieselbe Ressource aufgerufen, und daher geht das Handle verloren.</span><span class="sxs-lookup"><span data-stu-id="f8830-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="f8830-161"><xref:System.Runtime.InteropServices.SafeHandle> ist in bestimmten Kontexten nicht geeignet.</span><span class="sxs-lookup"><span data-stu-id="f8830-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="f8830-162">Da die <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>-Methode in einem <xref:System.GC>-Finalizerthread ausgeführt werden kann, sollten alle Handles, die in einem bestimmten Thread freigegeben werden müssen, nicht in eine <xref:System.Runtime.InteropServices.SafeHandle>-Klasse eingebunden sein.</span><span class="sxs-lookup"><span data-stu-id="f8830-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="f8830-163">Runtime Callable Wrapper (RCWs) können durch die CLR ohne zusätzlichen Code bereinigt werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="f8830-164">Bei Code, der den Plattformaufruf verwendet und ein COM-Objekt als `IUnknown*` oder <xref:System.IntPtr> behandelt, muss der Code so umgeschrieben werden, dass er einen RCW verwendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="f8830-165"><xref:System.Runtime.InteropServices.SafeHandle> ist für dieses Szenario möglicherweise nicht geeignet, da die Möglichkeit besteht, dass eine nicht verwaltete Freigabemethode einen Rückruf für den verwalteten Code ausführt.</span><span class="sxs-lookup"><span data-stu-id="f8830-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-166">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-166">Code analysis rule</span></span>

<span data-ttu-id="f8830-167">Verwenden Sie <xref:System.Runtime.InteropServices.SafeHandle>, um Betriebssystemressourcen zu kapseln.</span><span class="sxs-lookup"><span data-stu-id="f8830-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="f8830-168">Verwenden Sie nicht <xref:System.Runtime.InteropServices.HandleRef> oder Felder vom Typ <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="f8830-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="f8830-169">Stellen Sie sicher, dass Finalizer nicht ausgeführt werden müssen, um das Verlust von Betriebssystemressourcen zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="f8830-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="f8830-170">Überprüfen Sie Ihre Finalizer sorgfältig, um sicherzustellen, dass eine wichtige Betriebssystemressource auch dann nicht verloren geht, wenn sie nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="f8830-171">Im Gegensatz zum normalen Entladen von <xref:System.AppDomain> werden Objekte während des unvorhergesehen Entladens von <xref:System.AppDomain> nicht finalisiert, wenn die Anwendung in einem stabilen Zustand ausgeführt wird oder wenn ein Server wie SQL Server heruntergefahren wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="f8830-172">Stellen Sie sicher, dass Ressourcen im Fall eines plötzlichen Entladens nicht verloren gehen, da die korrekte Ausführung der Anwendung nicht garantiert werden kann, die Integrität des Servers jedoch erhalten werden muss, indem Ressourcen nicht verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="f8830-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="f8830-173">Verwenden Sie <xref:System.Runtime.InteropServices.SafeHandle>, um Betriebssystemressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="f8830-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="f8830-174">Stellen Sie sicher, dass keine Klauseln ausgeführt werden müssen, um das Verlust von Betriebssystemressourcen zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="f8830-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="f8830-175">Für `finally`-Klauseln besteht keine Garantie, dass diese außerhalb von CERs ausgeführt werden, weshalb Bibliotheksentwickler sich nicht auf Code innerhalb eines `finally`-Blocks verlassen dürfen, um nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="f8830-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="f8830-176">Die empfohlene Lösung ist die Verwendung von <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="f8830-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-177">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-177">Code analysis rule</span></span>

<span data-ttu-id="f8830-178">Verwenden Sie <xref:System.Runtime.InteropServices.SafeHandle> anstatt `Finalize` zum Bereinigen von Betriebssystemressourcen.</span><span class="sxs-lookup"><span data-stu-id="f8830-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="f8830-179">Verwenden Sie nicht <xref:System.IntPtr>, sondern <xref:System.Runtime.InteropServices.SafeHandle> zum Kapseln von Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="f8830-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="f8830-180">Wenn die finally-Klausel ausgeführt werden muss, platzieren Sie diese in einer CER.</span><span class="sxs-lookup"><span data-stu-id="f8830-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="f8830-181">Alle Sperren sollten vorhandenen verwalteten Sperr Code durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="f8830-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="f8830-182">Der CLR muss bekannt sein, wann der Code gesperrt ist. So kann sichergestellt werden, dass die CLR die <xref:System.AppDomain> löscht, anstatt einfach den Thread abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f8830-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="f8830-183">Das Abbrechen des Threads könnte gefährlich sein, da die durch den Thread verarbeiteten Daten in einem inkonsistenten Zustand verbleiben könnten.</span><span class="sxs-lookup"><span data-stu-id="f8830-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="f8830-184">Daher muss die gesamte <xref:System.AppDomain>-Klasse wiederverwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="f8830-185">Die Konsequenzen eines Fehlers beim Identifizieren einer Sperre können Deadlocks oder falsche Ergebnisse sein.</span><span class="sxs-lookup"><span data-stu-id="f8830-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="f8830-186">Verwenden Sie die Methoden <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A>, um Sperrbereiche zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="f8830-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="f8830-187">Erstere sind statisch, befinden sich in der <xref:System.Threading.Thread>-Klasse und können nur auf den aktuellen Thread angewendet werden. Diese Methoden helfen dabei, zu verhindern, dass ein Thread die Sperrenanzahl eines anderen Threads bearbeitet.</span><span class="sxs-lookup"><span data-stu-id="f8830-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="f8830-188">In <xref:System.Threading.Monitor.Enter%2A> und <xref:System.Threading.Monitor.Exit%2A> ist diese CLR-Benachrichtigung integriert. Daher wird deren Verwendung und die Verwendung der [lock-Anweisung](../../csharp/language-reference/keywords/lock-statement.md) empfohlen, die diese Methoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="f8830-189">Andere Sperrmechanismen wie Spinlocks und <xref:System.Threading.AutoResetEvent> müssen diese Methoden aufrufen, um die CLR darüber zu benachrichtigen, dass auf einen kritischen Bereich zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="f8830-190">Diese Methoden verwenden keine Sperren. Sie informieren die CLR darüber, dass Code in einem kritischen Bereich ausgeführt wird und dass der Abbruch des Threads zu einem inkonsistenten Freigabezustand führen könnte.</span><span class="sxs-lookup"><span data-stu-id="f8830-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="f8830-191">Wenn Sie einen eigenen Sperrentyp wie z.B. eine benutzerdefinierte <xref:System.Threading.ReaderWriterLock>-Klasse definiert haben, verwenden Sie diese Methoden zur Berechnung der Sperrenanzahl.</span><span class="sxs-lookup"><span data-stu-id="f8830-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-192">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-192">Code analysis rule</span></span>

<span data-ttu-id="f8830-193">Markieren und identifizieren Sie alle Sperren mithilfe von <xref:System.Threading.Thread.BeginCriticalRegion%2A> und <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8830-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="f8830-194">Verwenden Sie nicht <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> und <xref:System.Threading.Interlocked.Decrement%2A> in einer Schleife.</span><span class="sxs-lookup"><span data-stu-id="f8830-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="f8830-195">Führen Sie keinen Plattformaufruf der Win32-Varianten dieser Methoden aus.</span><span class="sxs-lookup"><span data-stu-id="f8830-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="f8830-196">Verwenden Sie <xref:System.Threading.Thread.Sleep%2A> nicht in einer Schleife.</span><span class="sxs-lookup"><span data-stu-id="f8830-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="f8830-197">Verwenden Sie keine flüchtigen Felder (volatile-Felder).</span><span class="sxs-lookup"><span data-stu-id="f8830-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="f8830-198">Der Bereinigungs Code muss sich in einem-Block oder einem catch-Block befinden, nicht nach einem catch</span><span class="sxs-lookup"><span data-stu-id="f8830-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="f8830-199">Bereinigungscode darf nie auf einen `catch`-Block folgen. Er sollte sich in einem `finally`-Block oder im `catch`-Block selbst befinden.</span><span class="sxs-lookup"><span data-stu-id="f8830-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="f8830-200">Dies entspricht der üblichen Vorgehensweise.</span><span class="sxs-lookup"><span data-stu-id="f8830-200">This should be a normal good practice.</span></span> <span data-ttu-id="f8830-201">Ein `finally`-Block wird allgemein bevorzugt, da er den gleichen Code ausführt, wenn eine Ausnahme ausgelöst wird und wenn der Code am Ende des `try`-Blocks normal aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="f8830-202">Wenn eine unerwartete Ausnahme ausgelöst wird, z.B. eine <xref:System.Threading.ThreadAbortException>, wird der Bereinigungscode nicht ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f8830-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="f8830-203">Nicht verwaltete Ressourcen, die Sie in einem `finally`-Block bereinigen würden, sollten idealerweise in einem Objekt der <xref:System.Runtime.InteropServices.SafeHandle>-Klasse gekapselt sein, um Verluste zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f8830-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="f8830-204">Beachten Sie, dass das C#-Schlüsselwort `using` effektiv verwendet werden kann, um Objekte einschließlich Handles zu löschen.</span><span class="sxs-lookup"><span data-stu-id="f8830-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="f8830-205">Obwohl die Wiederverwendung von <xref:System.AppDomain> Ressourcen im Finalizerthread bereinigen kann, ist es dennoch wichtig, Bereinigungscode an der richtigen Stelle zu platzieren.</span><span class="sxs-lookup"><span data-stu-id="f8830-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="f8830-206">Wenn ein Thread eine asynchrone Ausnahme empfängt, ohne eine Sperre zu verwenden, sollten Sie beachten, dass die CLR versucht, den Thread selbst zu beenden, ohne <xref:System.AppDomain> wiederherstellen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="f8830-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="f8830-207">Indem sichergestellt wird, dass Ressourcen besser früh als spät bereinigt werden, können mehr Ressourcen verfügbar gemacht und die Lebensdauer besser verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="f8830-208">Wenn Sie einen Handle nicht explizit für eine Datei in einem Fehlercodepfad schließen, warten Sie darauf, dass der <xref:System.Runtime.InteropServices.SafeHandle>-Finalizer ihn bereinigt. Wenn Ihr Code das nächste Mal ausgeführt wird, tritt möglicherweise ein Fehler beim dem Versuch auf, auf dieselbe Datei zuzugreifen, falls der Finalizer nicht bereits ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="f8830-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="f8830-209">Aus diesem Grund hilft das Sicherstellen, dass Bereinigungscode vorhanden ist und korrekt funktioniert, dabei, dass die Wiederherstellung nach Fehlern besser und schneller erfolgt, obwohl es nicht unbedingt erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="f8830-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-210">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-210">Code analysis rule</span></span>

<span data-ttu-id="f8830-211">Bereinigungscode nach einem `catch`-Block muss sich in einem `finally`-Block befinden.</span><span class="sxs-lookup"><span data-stu-id="f8830-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="f8830-212">Platzieren Sie Aufrufe zum Löschen in einem finally-Block.</span><span class="sxs-lookup"><span data-stu-id="f8830-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="f8830-213">`catch`-Blöcke sollten abschließend Ausnahmen auslösen bzw. neu auslösen.</span><span class="sxs-lookup"><span data-stu-id="f8830-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="f8830-214">Es werden Ausnahmen auftreten, z.B. Code, der ermittelt, ob eine Netzwerkverbindung eingerichtet werden kann, wobei Sie eine große Anzahl von Ausnahmen erhalten könnten. Dennoch sollte jeder Code, der das Abfangen einer Reihe von Ausnahmen unter normalen Bedingungen erfordert, darauf hinweisen, dass der Code getestet werden sollte, um herauszufinden, ob er erfolgreich sein wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="f8830-215">Prozess weiter änderbarer Freigabe Zustand zwischen Anwendungs Domänen muss entfernt werden, oder es sollte ein eingeschränkter Ausführungs Bereich verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="f8830-216">Wie in der Einleitung beschrieben, kann es sehr schwierig sein, verwalteten Code zu schreiben, der den prozessübergreifenden veränderbaren Freigabezustand zwischen Anwendungsdomänen auf verlässliche Weise überwacht.</span><span class="sxs-lookup"><span data-stu-id="f8830-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="f8830-217">Ein prozessübergreifender veränderbarer Freigabezustand ist jede Art von Datenstruktur zwischen Anwendungsdomänen, entweder in Win32-Code, innerhalb der CLR oder in verwaltetem Code, der Remoting verwendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="f8830-218">Ein veränderbarer Freigabezustand ist sehr schwer in verwaltetem Code zu schreiben, und jeder statische Freigabezustand sollte nur mit großer Vorsicht erfolgen.</span><span class="sxs-lookup"><span data-stu-id="f8830-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="f8830-219">Wenn es in Ihrem Fall zu einem prozessübergreifenden oder computerübergreifenden Freigabezustand kommt, suchen Sie nach einer Möglichkeit, diesen zu beseitigen, oder schützen Sie den Freigabezustand mithilfe eines eingeschränkten Ausführungsbereichs.</span><span class="sxs-lookup"><span data-stu-id="f8830-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="f8830-220">Beachten Sie, dass jede Bibliothek mit Freigabezustand, der nicht identifiziert und korrigiert ist, dazu führen könnte, dass ein Host wie SQL Server abstürzt, der ein korrektes Entladen von <xref:System.AppDomain> erfordert.</span><span class="sxs-lookup"><span data-stu-id="f8830-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="f8830-221">Wenn in Code ein COM-Objekt verwendet wird, vermeiden Sie, dieses COM-Objekt zwischen Anwendungsdomänen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="f8830-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="f8830-222">Sperren funktionieren nicht Prozess weit oder zwischen Anwendungs Domänen.</span><span class="sxs-lookup"><span data-stu-id="f8830-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="f8830-223">In der Vergangenheit wurden <xref:System.Threading.Monitor.Enter%2A> und die [lock-Anweisung](../../csharp/language-reference/keywords/lock-statement.md) dazu verwendet, Sperren für den globalen Prozess zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="f8830-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="f8830-224">Dies ist beispielsweise beim Sperren von agilen <xref:System.AppDomain>-Klassen wie <xref:System.Type>-Instanzen von nicht freigegebenen Assemblys, <xref:System.Threading.Thread>-Objekten, internalisierten Zeichenfolgen und einigen Zeichenfolgen der Fall, die mithilfe von Remoting zwischen Anwendungsdomänen freigegeben sind.</span><span class="sxs-lookup"><span data-stu-id="f8830-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="f8830-225">Diese Sperren sind nicht mehr prozessübergreifend.</span><span class="sxs-lookup"><span data-stu-id="f8830-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="f8830-226">Überprüfen Sie, ob der Code innerhalb der Sperre eine externe, persistente Ressource wie eine Datei auf einem Datenträger oder möglicherweise eine Datenbank verwendet, um eine prozessübergreifende Sperre zwischen Anwendungsdomänen zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="f8830-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="f8830-227">Beachten Sie, dass die Verwendung einer Sperre innerhalb einer <xref:System.AppDomain>-Klasse Probleme verursachen kann, falls der geschützte Code eine externe Ressource verwendet, da dieser Code gleichzeitig in mehreren Anwendungsdomänen ausgeführt werden könnte.</span><span class="sxs-lookup"><span data-stu-id="f8830-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="f8830-228">Dies kann zum Problem werden, wenn in eine Protokolldatei geschrieben oder für den gesamten Prozess eine Bindung an einen Socket erfolgt.</span><span class="sxs-lookup"><span data-stu-id="f8830-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="f8830-229">Diese Änderungen bedeuten, dass bis auf die Verwendung einer benannten <xref:System.Threading.Mutex>- oder <xref:System.Threading.Semaphore>-Instanz keine einfache Möglichkeit besteht, verwalteten Code zu verwenden, um eine prozessglobale Sperre abzurufen.</span><span class="sxs-lookup"><span data-stu-id="f8830-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="f8830-230">Erstellen Sie Code, der nicht gleichzeitig in zwei Anwendungsdomänen ausgeführt wird, oder verwenden Sie die <xref:System.Threading.Mutex>- oder <xref:System.Threading.Semaphore>-Klassen.</span><span class="sxs-lookup"><span data-stu-id="f8830-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="f8830-231">Wenn vorhandener Code nicht geändert werden kann, verwenden Sie nicht ein benanntes Win32-Mutexobjekt für diese Synchronisierung, da das Ausführen im Fibermodus bedeutet, dass Sie nicht garantieren können, dass der gleiche Betriebssystemthread ein Mutex abrufen und freigeben wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="f8830-232">Sie müssen die verwaltete <xref:System.Threading.Mutex>-Klasse oder eine benannte <xref:System.Threading.ManualResetEvent>-, <xref:System.Threading.AutoResetEvent>- oder <xref:System.Threading.Semaphore>-Instanz verwenden, um die Codesperre so zu synchronisieren, dass die CLR die Sperre beachtet, anstatt diese mithilfe von nicht verwaltetem Code zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="f8830-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="f8830-233">Vermeiden Sie lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="f8830-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="f8830-234">Private und öffentliche <xref:System.Type>-Objekte in freigegebenen Assemblys, bei denen nur eine Kopie des Codes zwischen allen Anwendungsdomänen freigegeben wird, stellen ebenfalls Probleme dar.</span><span class="sxs-lookup"><span data-stu-id="f8830-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="f8830-235">Für freigegebene Assemblys ist nur eine Instanz einer <xref:System.Type>-Klasse pro Prozess vorhanden. Dies bedeutet, dass mehrere Anwendungsdomänen genau dieselbe <xref:System.Type>-Instanz freigeben.</span><span class="sxs-lookup"><span data-stu-id="f8830-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="f8830-236">Durch eine Sperre für eine <xref:System.Type>-Instanz wird nicht nur die <xref:System.AppDomain>, sondern der gesamte Prozess beeinflusst.</span><span class="sxs-lookup"><span data-stu-id="f8830-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="f8830-237">Wenn eine <xref:System.AppDomain> ein <xref:System.Type>-Objekt sperrt, wird der Thread unvermittelt unterbrochen, und die Sperre wird nicht aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="f8830-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="f8830-238">Diese Sperre kann dann bei anderen Anwendungsdomänen zu einem Deadlock führen.</span><span class="sxs-lookup"><span data-stu-id="f8830-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="f8830-239">Eine gute Möglichkeit zur Verwendung von Sperren in statischen Methoden besteht darin, ein statisches internes Synchronisierungsobjekt zum Code hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="f8830-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="f8830-240">Dieses kann im Klassenkonstruktor initialisiert werden, wenn ein solcher vorhanden ist. Andernfalls kann das Objekt wie folgt initialisiert werden:</span><span class="sxs-lookup"><span data-stu-id="f8830-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="f8830-241">Wenn anschließend eine Sperre verwendet wird, verwenden Sie die `InternalSyncObject`-Eigenschaft, um ein Objekt zu erhalten, auf das die Sperre angewendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="f8830-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="f8830-242">Sie müssen die Eigenschaft nicht verwenden, wenn Sie das interne Synchronisierungsobjekt im Klassenkonstruktor initialisiert haben.</span><span class="sxs-lookup"><span data-stu-id="f8830-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="f8830-243">Der zur Sperrung verwendete Initialisierungscode, der zwei Kontrollstrukturen zur Prüfung enthält, sollte wie im folgenden Beispiel aussehen:</span><span class="sxs-lookup"><span data-stu-id="f8830-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="f8830-244">Hinweis zu Lock (this)</span><span class="sxs-lookup"><span data-stu-id="f8830-244">A note about lock(this)</span></span>

<span data-ttu-id="f8830-245">Es ist im Allgemeinen zulässig, ein einzelnes Objekt zu sperren, auf das öffentlich zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="f8830-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="f8830-246">Wenn das Objekt jedoch ein Singleton-Objekt ist, das bei einem gesamten Subsystem zu einem Deadlock führen kann, empfiehlt sich ebenfalls das obige Entwurfsmuster.</span><span class="sxs-lookup"><span data-stu-id="f8830-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="f8830-247">Das Sperren des <xref:System.Security.SecurityManager>-Objekts kann z.B. zu einem Deadlock in der <xref:System.AppDomain> führen, wodurch die gesamte <xref:System.AppDomain> unbrauchbar wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="f8830-248">Es wird daher empfohlen, ein als öffentlich deklariertes Objekt dieses Typs nicht zu sperren.</span><span class="sxs-lookup"><span data-stu-id="f8830-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="f8830-249">Eine Sperre einer einzelnen Auflistung oder eines einzelnen Arrays sollte jedoch in der Regel kein Problem darstellen.</span><span class="sxs-lookup"><span data-stu-id="f8830-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-250">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-250">Code analysis rule</span></span>

<span data-ttu-id="f8830-251">Sperren Sie keine Typen, die möglicherweise über Anwendungsdomänen hinweg verwendet werden oder über eine starke Objektidentität verfügen.</span><span class="sxs-lookup"><span data-stu-id="f8830-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="f8830-252">Rufen Sie nicht <xref:System.Threading.Monitor.Enter%2A> für Objekte der Klassen <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread> oder für Objekte auf, die von <xref:System.MarshalByRefObject> abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="f8830-253">Entfernen Sie GC. KeepAlive-Aufrufe</span><span class="sxs-lookup"><span data-stu-id="f8830-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="f8830-254">In vorhandenem Code wird in vielen Fällen die <xref:System.GC.KeepAlive%2A>-Methode entweder nicht verwendet, obwohl dies erforderlich wäre, oder sie wird falsch angewendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="f8830-255">Nach der Konvertierung in <xref:System.Runtime.InteropServices.SafeHandle> müssen Klassen nicht <xref:System.GC.KeepAlive%2A> aufrufen. Die Voraussetzung dafür ist, dass sie auf <xref:System.Runtime.InteropServices.SafeHandle> anstelle eines Finalizers zurückgreifen, um die Betriebssystemhandles zu finalisieren.</span><span class="sxs-lookup"><span data-stu-id="f8830-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="f8830-256">Der Leistungsabfall, der durch das anhaltende Aufrufen von <xref:System.GC.KeepAlive%2A> zustande kommt, ist unerheblich. Durch den Eindruck, dass ein Aufruf von <xref:System.GC.KeepAlive%2A> erforderlich oder ausreichend ist, um ein Problem mit der Lebensdauer zu lösen, das möglicherweise nicht mehr vorhanden ist, wird die Verwaltung des Codes jedoch erschwert.</span><span class="sxs-lookup"><span data-stu-id="f8830-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="f8830-257">Beim Verwenden der Runtime Callable Wrapper (RCWs) von COM-Interop muss <xref:System.GC.KeepAlive%2A> allerdings dennoch im Code vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="f8830-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-258">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-258">Code analysis rule</span></span>

<span data-ttu-id="f8830-259">Entfernen Sie <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8830-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="f8830-260">Verwenden des HostProtection-Attributs</span><span class="sxs-lookup"><span data-stu-id="f8830-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="f8830-261">Das <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) stellt deklarative Sicherheitsaktionen zur Festlegung von Hostschutzanforderungen zur Verfügung. Auf diese Weise kann sogar vom Host verhindert werden, dass in voll vertrauenswürdigem Code Methoden aufgerufen werden, die für einen bestimmten Host wie <xref:System.Environment.Exit%2A> oder <xref:System.Windows.Forms.MessageBox.Show%2A> für SQL Server ungeeignet sind.</span><span class="sxs-lookup"><span data-stu-id="f8830-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="f8830-262">Das HPA wirkt sich nur auf nicht verwaltete Anwendungen aus, die die Common Language Runtime hosten und den Hostschutz implementieren. Ein Beispiel ist SQL Server.</span><span class="sxs-lookup"><span data-stu-id="f8830-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="f8830-263">Die Anwendung der Sicherheitsaktion führt basierend auf den Hostressourcen, die von der Klasse oder Methode verfügbar gemacht werden, zur Erstellung eines Linkaufrufs.</span><span class="sxs-lookup"><span data-stu-id="f8830-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="f8830-264">Wenn der Code in einer Clientanwendung oder auf einem Server ausgeführt wird, der nicht Teil eines geschützten Hostbereichs ist, „verschwindet“ das Attribut. Es wird also nicht erkannt und daher nicht angewendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f8830-265">Der Zweck dieses Attributs besteht darin, hostspezifische Richtlinien für Programmiermodelle durchzusetzen. Ein erzwungenes Sicherheitsverhalten ist jedoch nicht das Ziel.</span><span class="sxs-lookup"><span data-stu-id="f8830-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="f8830-266">Obwohl ein Linkaufruf verwendet wird, um auf Übereinstimmung mit den Programmiermodellanforderungen zu prüfen, ist das <xref:System.Security.Permissions.HostProtectionAttribute> keine Sicherheitsberechtigung.</span><span class="sxs-lookup"><span data-stu-id="f8830-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="f8830-267">Wenn für den Host keine Programmiermodellanforderungen vorliegen, kommt es nicht zu einem Linkaufruf.</span><span class="sxs-lookup"><span data-stu-id="f8830-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="f8830-268">Das Attribut identifiziert Folgendes:</span><span class="sxs-lookup"><span data-stu-id="f8830-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="f8830-269">Methoden oder Klassen, die nicht mit dem Programmiermodell des Hosts kompatibel sind, jedoch abgesehen davon keine negativen Auswirkungen haben.</span><span class="sxs-lookup"><span data-stu-id="f8830-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="f8830-270">Methoden oder Klassen, die nicht mit dem Programmiermodell des Hosts kompatibel sind und zur Destabilisierung von serververwaltetem Benutzercode führen können.</span><span class="sxs-lookup"><span data-stu-id="f8830-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="f8830-271">Methoden oder Klassen, die nicht mit dem Programmiermodell des Hosts kompatibel sind und zur Destabilisierung des Serverprozesses selbst führen können.</span><span class="sxs-lookup"><span data-stu-id="f8830-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="f8830-272">Wenn Sie eine Klassenbibliothek erstellen, die von Anwendungen aufgerufen werden soll, die in einer geschützten Hostumgebung ausgeführt werden können, sollten Sie dieses Attribut auf Member anwenden, die <xref:System.Security.Permissions.HostProtectionResource>-Kategorien verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="f8830-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="f8830-273">Die Verwendung von Membern der .NET Framework-Klassenbibliothek mit diesem Attribut führt nur dazu, dass die unmittelbar aufrufende Methode überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="f8830-274">Auch der Bibliotheksmember muss auf gleiche Weise seine aufrufende Methode überprüfen.</span><span class="sxs-lookup"><span data-stu-id="f8830-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="f8830-275">Weitere Informationen zu HPA finden Sie unter <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f8830-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-276">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-276">Code analysis rule</span></span>

<span data-ttu-id="f8830-277">Alle Methoden, in denen Synchronisierung oder Threading zur Anwendung kommt, müssen für SQL Server mit dem HPA identifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="f8830-278">Dies gilt auch für Methoden, die Zustände freigeben, synchronisiert werden oder externe Prozesse verwalten.</span><span class="sxs-lookup"><span data-stu-id="f8830-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="f8830-279">Zu den <xref:System.Security.Permissions.HostProtectionResource>-Werten, die sich auf SQL Server auswirken, gehören <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> und <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="f8830-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="f8830-280">Von einem HPA sollten nicht nur Methoden identifiziert werden, die Ressourcen verwenden, die sich auf SQL auswirken. Vielmehr sollten alle Methoden, die eine <xref:System.Security.Permissions.HostProtectionResource> verfügbar machen, von diesem Attribut identifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="f8830-281">Nicht unbegrenzt in nicht verwaltetem Code blockieren</span><span class="sxs-lookup"><span data-stu-id="f8830-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="f8830-282">Blockierungen in nicht verwaltetem Code anstatt in verwaltetem Code können zu einem Denial-of-Service-Angriff führen, da die CLR nicht in der Lage ist, den Thread abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="f8830-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="f8830-283">Durch einen blockierten Thread wird – zumindest bei Verzicht auf unsichere Vorgänge – die CLR daran gehindert, die <xref:System.AppDomain> zu entladen.</span><span class="sxs-lookup"><span data-stu-id="f8830-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="f8830-284">Die Blockierung mithilfe eines Windows-Synchronisierungs primitiven ist ein eindeutiger Beispiel dafür, was wir nicht zulassen können.</span><span class="sxs-lookup"><span data-stu-id="f8830-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="f8830-285">Das Blockieren bei einem Aufruf `ReadFile` von für einen Socket sollte nach Möglichkeit vermieden werden – im Idealfall sollte die Windows-API einen Mechanismus für einen Vorgang wie diesen bereitstellen, um ein Timeout zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="f8830-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="f8830-286">Jede Methode, die in nativem Code aufgerufen wird, sollte idealerweise einen Win32-Aufruf mit einem angemessenen, zeitlich begrenzten Timeout verwenden.</span><span class="sxs-lookup"><span data-stu-id="f8830-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="f8830-287">Wenn der Benutzer ein Timeout festlegen darf, sollte dieses nur dann zeitlich unbegrenzt sein dürfen, falls der Benutzer über bestimmte Sicherheitsberechtigungen verfügt.</span><span class="sxs-lookup"><span data-stu-id="f8830-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="f8830-288">Wenn eine Methode länger als ca. 10 Sekunden blockiert wird, benötigen Sie entweder eine Version, die Timeouts unterstützt, oder zusätzliche CLR-Unterstützung.</span><span class="sxs-lookup"><span data-stu-id="f8830-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="f8830-289">Hier finden Sie einige Beispiele für problematische APIs.</span><span class="sxs-lookup"><span data-stu-id="f8830-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="f8830-290">Sowohl anonyme als auch benannte Pipes können ohne Timeout erstellt werden. Im Code muss allerdings sichergestellt werden, dass nie `CreateNamedPipe` oder `WaitNamedPipe` mit NMPWAIT_WAIT_FOREVER aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="f8830-291">Darüber hinaus kommt es möglicherweise auch dann zu unerwarteten Blockierungen, wenn ein Timeout angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="f8830-292">Der Aufruf von `WriteFile` in einer anonymen Pipe wird blockiert, bis der Schreibvorgang für alle Bytes beendet ist. Wenn sich im Puffer ungelesene Daten befinden, wird der `WriteFile`-Aufruf blockiert, bis der Reader Speicherplatz im Puffer der Pipe freigegeben hat.</span><span class="sxs-lookup"><span data-stu-id="f8830-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="f8830-293">Für Sockets sollte immer eine API verwendet werden, die einen Timeoutmechanismus unterstützt.</span><span class="sxs-lookup"><span data-stu-id="f8830-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-294">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-294">Code analysis rule</span></span>

<span data-ttu-id="f8830-295">Eine Blockierung ohne Timeout ist in nicht verwaltetem Code ein Denial-of-Service-Angriff.</span><span class="sxs-lookup"><span data-stu-id="f8830-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="f8830-296">Führen Sie keine Plattformaufrufe von `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects` und `MsgWaitForMultipleObjectsEx` aus.</span><span class="sxs-lookup"><span data-stu-id="f8830-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="f8830-297">Verwenden Sie nicht NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="f8830-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="f8830-298">Identifizieren Sie alle STA-abhängigen Features.</span><span class="sxs-lookup"><span data-stu-id="f8830-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="f8830-299">Identifizieren Sie Code, der COM-Single-Threaded-Apartments (STAs) verwendet.</span><span class="sxs-lookup"><span data-stu-id="f8830-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="f8830-300">STAs sind für den SQL Server-Prozess deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="f8830-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="f8830-301">Von `CoInitialize` abhänge Funktionen wie z.B. Leistungsindikatoren oder die Zwischenablage müssen in SQL Server deaktiviert werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="f8830-302">Sicherstellen, dass Finalizer keine Synchronisierungs Probleme aufweisen</span><span class="sxs-lookup"><span data-stu-id="f8830-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="f8830-303">Es besteht die Möglichkeit, dass in zukünftigen Versionen von .NET Framework mehrere Finalizer-Threads vorhanden sind. Das bedeutet, dass Finalizer für verschiedene Instanzen desselben Typs gleichzeitig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="f8830-304">Finalizer müssen nicht völlig threadsicher sein, da der Garbage Collector garantiert, dass ein Finalizer für eine vorhandene Objektinstanz in nur einem Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="f8830-305">Finalizer müssen jedoch so programmiert werden, dass Racebedingungen und Deadlocks vermieden werden, wenn Finalizer gleichzeitig für unterschiedliche Objektinstanzen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="f8830-306">Wenn beispielsweise beim Schreiben in eine Protokolldatei ein externer Zustand in einem Finalizer verwendet wird, müssen Threadingprobleme behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="f8830-307">Verlassen Sie sich bei der Gewährleistung von Threadsicherheit nicht auf die Finalisierung.</span><span class="sxs-lookup"><span data-stu-id="f8830-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="f8830-308">Verwenden Sie außerdem keinen verwalteten oder nativen threadlokalen Speicher zum Speichern eines Zustands im Finalizer-Thread.</span><span class="sxs-lookup"><span data-stu-id="f8830-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-309">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-309">Code analysis rule</span></span>

<span data-ttu-id="f8830-310">In Finalizern dürfen keine Synchronisierungsprobleme auftreten.</span><span class="sxs-lookup"><span data-stu-id="f8830-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="f8830-311">Verwenden Sie keinen statischen veränderlichen Zustand in einem Finalizer.</span><span class="sxs-lookup"><span data-stu-id="f8830-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="f8830-312">Vermeiden Sie nach Möglichkeit nicht verwalteten Speicher.</span><span class="sxs-lookup"><span data-stu-id="f8830-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="f8830-313">Nicht verwalteter Speicher kann ebenso wie ein Betriebssystemhandle verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="f8830-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="f8830-314">Verwenden Sie daher falls möglich Arbeitsspeicher auf dem Stapel mit [stackalloc](../../csharp/language-reference/operators/stackalloc.md) oder ein fixiertes verwaltetes Objekt wie die [fixed-Anweisung](../../csharp/language-reference/keywords/fixed-statement.md) oder einen <xref:System.Runtime.InteropServices.GCHandle> mithilfe von „byte[]“.</span><span class="sxs-lookup"><span data-stu-id="f8830-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="f8830-315">Der <xref:System.GC> gibt diese Ressourcen abschließend frei.</span><span class="sxs-lookup"><span data-stu-id="f8830-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="f8830-316">Wenn Sie jedoch nicht verwalteten Speicher zuordnen müssen, sollten Sie eine Klasse verwenden, die von <xref:System.Runtime.InteropServices.SafeHandle> abgeleitet wird, um den Code für die Speicherbelegung zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="f8830-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="f8830-317">Beachten Sie, dass <xref:System.Runtime.InteropServices.SafeHandle> in mindestens einem Fall nicht verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="f8830-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="f8830-318">Bei COM-Methodenaufrufen, die Speicher belegen oder freigeben, ist es üblich, dass eine DLL zunächst Speicher über `CoTaskMemAlloc` belegt und eine andere DLL anschließend diesen Speicher mit `CoTaskMemFree` freigibt.</span><span class="sxs-lookup"><span data-stu-id="f8830-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="f8830-319">Die Verwendung eines <xref:System.Runtime.InteropServices.SafeHandle>-Objekts wäre hier nicht sinnvoll, da dieses versuchen würde, die Lebensdauer des nicht verwalteten Speichers mit der Lebensdauer von <xref:System.Runtime.InteropServices.SafeHandle> zu verknüpfen, anstatt zuzulassen, dass die andere DLL die Lebensdauer des Arbeitsspeichers verwaltet.</span><span class="sxs-lookup"><span data-stu-id="f8830-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="f8830-320">Alle Verwendungszwecke von catch (Exception) überprüfen</span><span class="sxs-lookup"><span data-stu-id="f8830-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="f8830-321">In catch-Blöcken zum Abfangen aller Ausnahmen anstatt einer bestimmten Ausnahme werden nun auch asynchrone Ausnahmen abgefangen.</span><span class="sxs-lookup"><span data-stu-id="f8830-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="f8830-322">Überprüfen Sie jeden catch(Exception)-Block, und achten Sie darauf, dass keine wichtigen Ressourcen freigeben werden oder Zurücksetzungscode übersprungen wird. Suchen Sie außerdem nach potenziell fehlerhaftem Verhalten innerhalb des catch-Blocks selbst für die Behandlung der Ausnahmen <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> oder <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="f8830-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="f8830-323">Beachten Sie, dass im Code möglicherweise Annahmen protokolliert oder getroffen werden, dass bestimmte Ausnahmen sichtbar sind oder eine Ausnahme aus genau einem Grund aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="f8830-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="f8830-324">Diese Annahmen müssen möglicherweise aktualisiert werden, um <xref:System.Threading.ThreadAbortException> einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="f8830-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="f8830-325">Sie sollten alle Stellen, an denen Ausnahmen jeden Typs abgefangen werden, so ändern, dass ein erwarteter Ausnahmetyp abgefangen wird. Ein Beispiel ist eine <xref:System.FormatException>, die bei einer Methode zur Formatierung von Zeichenfolgen auftritt.</span><span class="sxs-lookup"><span data-stu-id="f8830-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="f8830-326">Auf diese Weise wird verhindert, dass der catch-Block bei unerwarteten Ausnahmen ausgeführt wird. Außerdem wird sichergestellt, dass Fehler nicht durch das Abfangen unerwarteter Ausnahmen maskiert werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="f8830-327">Allgemein gilt, dass Sie nie eine Ausnahme in Bibliothekscode behandeln dürfen. Code, in dem Sie eine Ausnahme abfangen müssen, kann auf einen Entwurfsfehler im abgerufenen Code hindeuten.</span><span class="sxs-lookup"><span data-stu-id="f8830-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="f8830-328">In einigen Fällen empfiehlt es sich, eine Ausnahme abzufangen und einen anderen Ausnahmetyp auszulösen, um mehr Daten bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="f8830-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="f8830-329">Verwenden Sie in diesem Fall geschachtelte Ausnahmen, da so die tatsächliche Ursache des Fehlers in der <xref:System.Exception.InnerException%2A>-Eigenschaft der neuen Ausnahme gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-330">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-330">Code analysis rule</span></span>

<span data-ttu-id="f8830-331">Prüfen Sie in verwaltetem Code alle catch-Blöcke, die alle Objekte oder Ausnahmen abfangen.</span><span class="sxs-lookup"><span data-stu-id="f8830-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="f8830-332">In c# bedeutet dies das Kennzeichnen von `catch` {} und `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="f8830-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="f8830-333">Sie sollten entweder einen ganz bestimmten Ausnahmetyp verwenden oder den Code prüfen, um sicherzustellen, dass es beim Abfangen unerwarteter Ausnahmetypen nicht zu Fehlern kommt.</span><span class="sxs-lookup"><span data-stu-id="f8830-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="f8830-334">Gehen Sie nicht davon aus, dass ein verwalteter Thread ein Win32-Thread ist – er ist eine Fiber.</span><span class="sxs-lookup"><span data-stu-id="f8830-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="f8830-335">Die Verwendung von verwaltetem threadlokalen Speicher ist möglich. Sie können jedoch keinen nicht verwalteten threadlokalen Speicher verwenden oder davon ausgehen, dass der Code erneut im aktuellen Betriebssystemthread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="f8830-336">Ändern Sie keine Einstellungen wie das Threadgebietsschema.</span><span class="sxs-lookup"><span data-stu-id="f8830-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="f8830-337">Verwenden Sie zum Abruf der Methoden `InitializeCriticalSection` oder `CreateMutex` keinen Plattformaufruf, da diese darauf angewiesen sind, dass der gesperrte Betriebssystemthread wieder entsperrt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="f8830-338">Da dies bei der Verwendung von Fibern nicht der Fall ist, können kritische Abschnitte in Win32 und Mutex-Verfahren nicht direkt in SQL verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f8830-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="f8830-339">Beachten Sie, dass die verwaltete <xref:System.Threading.Mutex>-Klasse keine Probleme hinsichtlich der Threadaffinität behandelt.</span><span class="sxs-lookup"><span data-stu-id="f8830-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="f8830-340">Sie können den Zustand eines verwalteten <xref:System.Threading.Thread>-Objekts größtenteils sicher nutzen und dabei beispielsweise verwalteten threadlokalen Speicher und die aktuelle Benutzeroberflächenkultur des Threads verwenden.</span><span class="sxs-lookup"><span data-stu-id="f8830-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="f8830-341">Sie können auch das <xref:System.ThreadStaticAttribute> verwenden, wodurch nur der aktuell verwaltete Thread auf den Wert einer vorhandenen statischen Variable zugreifen kann. Dies ist eine alternative Methode zur Verwendung threadlokalen Speichers in einer Fiber in der CLR.</span><span class="sxs-lookup"><span data-stu-id="f8830-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="f8830-342">Aus Gründen, die mit dem Programmiermodell zusammenhängen, können Sie die aktuelle Kultur eines Threads nicht ändern, wenn dieser in SQL ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-343">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-343">Code analysis rule</span></span>

<span data-ttu-id="f8830-344">SQL Server wird im Fibermodus ausgeführt. Verwenden Sie keinen threadlokalen Speicher.</span><span class="sxs-lookup"><span data-stu-id="f8830-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="f8830-345">Führen Sie außerdem keine Plattformaufrufe von `TlsAlloc`, `TlsFree`, `TlsGetValue` und `TlsSetValue.` aus.</span><span class="sxs-lookup"><span data-stu-id="f8830-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="f8830-346">SQL Server Handle für den Identitätswechsel</span><span class="sxs-lookup"><span data-stu-id="f8830-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="f8830-347">Da der Identitätswechsel auf der Threadebene ausgeführt wird und SQL im Fibermodus ausgeführt werden kann, sollte es in verwaltetem Code zu keinem Identitätswechsel von Benutzern und zu keinem Aufruf von `RevertToSelf` kommen.</span><span class="sxs-lookup"><span data-stu-id="f8830-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-348">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-348">Code analysis rule</span></span>

<span data-ttu-id="f8830-349">Überlassen Sie den Identitätswechsel SQL Server.</span><span class="sxs-lookup"><span data-stu-id="f8830-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="f8830-350">Verwenden Sie nicht `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx` oder `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="f8830-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="f8830-351">Thread:: Suspend nicht anrufen</span><span class="sxs-lookup"><span data-stu-id="f8830-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="f8830-352">Einen Thread anzuhalten scheint ein unproblematischer Vorgang zu sein. Es kann dabei jedoch zu Deadlocks kommen.</span><span class="sxs-lookup"><span data-stu-id="f8830-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="f8830-353">Wenn ein Thread, der eine Sperre verwendet, von einem zweiten Thread angehalten wird und dieser denselben Bereich sperrt, tritt ein Deadlock auf.</span><span class="sxs-lookup"><span data-stu-id="f8830-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="f8830-354"><xref:System.Threading.Thread.Suspend%2A> kann aktuell die Sicherheit, das Laden von Klassen, Remoting und Reflektion beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="f8830-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="f8830-355">Code Analyse Regel</span><span class="sxs-lookup"><span data-stu-id="f8830-355">Code analysis rule</span></span>

<span data-ttu-id="f8830-356">Rufen Sie <xref:System.Threading.Thread.Suspend%2A> nicht auf.</span><span class="sxs-lookup"><span data-stu-id="f8830-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="f8830-357">Verwenden Sie stattdessen eine richtige Synchronisierungsprimitive wie ein <xref:System.Threading.Semaphore> oder <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="f8830-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="f8830-358">Schützen Sie kritische Vorgänge mit eingeschränkten Ausführungs Bereichen und Zuverlässigkeits Verträgen.</span><span class="sxs-lookup"><span data-stu-id="f8830-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="f8830-359">Stellen Sie bei der Ausführung eines komplexen Vorgangs, der einen freigegebenen Zustand aktualisiert oder der deterministisch entweder vollständig gelingt oder fehlschlägt, sicher, dass dieser von einem eingeschränkten Ausführungsbereich (CER) geschützt ist.</span><span class="sxs-lookup"><span data-stu-id="f8830-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="f8830-360">Auf diese Weise wird garantiert, dass der Code immer und sogar dann ausgeführt wird, wenn ein Thread unerwartet abgebrochen oder <xref:System.AppDomain> unvorhergesehen entladen wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="f8830-361">Ein CER ist ein besonderer `try/finally`-Block, dem ein Aufruf der Methode <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="f8830-362">Hierdurch wird der Just-In-Time-Compiler angewiesen, den gesamten Code im finally-Block vorzubereiten, bevor der `try`-Block ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="f8830-363">So wird sichergestellt, dass der Code im finally-Block erstellt wird und in allen Fällen ausführbar ist.</span><span class="sxs-lookup"><span data-stu-id="f8830-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="f8830-364">Es ist nicht ungewöhnlich, dass in einem CER ein leerer `try`-Block verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="f8830-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="f8830-365">Die Verwendung eines CER schützt vor asynchronen Threadabbrüchen und Ausnahmen bei unzureichendem Speicherplatz.</span><span class="sxs-lookup"><span data-stu-id="f8830-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="f8830-366">Unter <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> finden Sie einen CER, der zusätzlich Stapelüberläufe in überaus komplexem Code behandelt.</span><span class="sxs-lookup"><span data-stu-id="f8830-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="f8830-367">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="f8830-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="f8830-368">SQL Server-Programmierung und Hostschutzattribute</span><span class="sxs-lookup"><span data-stu-id="f8830-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
