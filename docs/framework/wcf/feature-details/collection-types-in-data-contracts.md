---
title: Sammlungstypen in Datenverträgen
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: a10b7c5295407cfbb36446581a4b75670e37bc6a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/09/2020
ms.locfileid: "84579748"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="cda19-102">Sammlungstypen in Datenverträgen</span><span class="sxs-lookup"><span data-stu-id="cda19-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="cda19-103">Eine *Sammlung* ist eine Liste von Elementen eines bestimmten Typs.</span><span class="sxs-lookup"><span data-stu-id="cda19-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="cda19-104">In der .NET Framework können solche Listen mithilfe von Arrays oder einer Vielzahl anderer Typen (generische Liste, generisch <xref:System.ComponentModel.BindingList%601> , <xref:System.Collections.Specialized.StringCollection> oder) dargestellt werden <xref:System.Collections.ArrayList> .</span><span class="sxs-lookup"><span data-stu-id="cda19-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="cda19-105">Eine Sammlung kann z. B. eine Liste von Adressen für einen bestimmten Kunden enthalten.</span><span class="sxs-lookup"><span data-stu-id="cda19-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="cda19-106">Solche Sammlungen werden – unabhängig von ihrem tatsächlichen Typ – als *Listensammlungen*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="cda19-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="cda19-107">Es gibt eine spezielle Sammlungsform, die eine Zuordnung zwischen einem Element (dem "Schlüssel") und einem anderen Element (dem "Wert") darstellt.</span><span class="sxs-lookup"><span data-stu-id="cda19-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="cda19-108">In der .NET Framework werden diese durch Typen wie <xref:System.Collections.Hashtable> und das generische Wörterbuch dargestellt.</span><span class="sxs-lookup"><span data-stu-id="cda19-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="cda19-109">Eine Zuordnungssammlung kann z. B. eine Stadt ("Schlüssel") der zugehörigen Bevölkerung ("Wert") zuordnen.</span><span class="sxs-lookup"><span data-stu-id="cda19-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="cda19-110">Solche Sammlungen werden – unabhängig von ihrem tatsächlichen Typ – als *Wörterbuchsammlungen*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="cda19-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="cda19-111">Sammlungen werden im Datenvertragsmodell besonders behandelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="cda19-112">Typen, die die <xref:System.Collections.IEnumerable> -Schnittstelle einschließlich Arrays und generischen Sammlungen implementieren, werden als Sammlungen erkannt.</span><span class="sxs-lookup"><span data-stu-id="cda19-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="cda19-113">Davon sind die Typen, die die Schnittstellen für das <xref:System.Collections.IDictionary> oder das generische <xref:System.Collections.Generic.IDictionary%602> implementieren, Wörterbuchsammlungen. Alle anderen sind Listensammlungen.</span><span class="sxs-lookup"><span data-stu-id="cda19-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="cda19-114">Weitere Anforderungen an Auflistungs Typen, z. b. die Verwendung einer Methode mit dem Namen `Add` und eines Parameter losen Konstruktors, werden in den folgenden Abschnitten ausführlich erläutert.</span><span class="sxs-lookup"><span data-stu-id="cda19-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="cda19-115">Dies stellt sicher, dass Sammlungstypen sowohl serialisiert als auch deserialisiert sein können.</span><span class="sxs-lookup"><span data-stu-id="cda19-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="cda19-116">Dies bedeutet, dass einige Sammlungen nicht direkt unterstützt werden, z. b. die generische <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (da Sie keinen Parameter losen Konstruktor aufweist).</span><span class="sxs-lookup"><span data-stu-id="cda19-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="cda19-117">Informationen zum Umgehen dieser Einschränkungen finden Sie im Abschnitt "Verwenden von Sammlungsschnittstellentypen und schreibgeschützten Sammlungen" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="cda19-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="cda19-118">Die in Sammlungen enthaltenen Typen müssen Datenvertragstypen oder anderweitig serialisierbar sein.</span><span class="sxs-lookup"><span data-stu-id="cda19-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="cda19-119">Weitere Informationen finden Sie [unter vom Datenvertragsserialisierer unterstützte Typen](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="cda19-119">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="cda19-120">Weitere Informationen dazu, was und was nicht als gültige Sammlung betrachtet wird, sowie darüber, wie Sammlungen serialisiert werden, finden Sie im Abschnitt Informationen zum Serialisieren von Sammlungen im Abschnitt "Erweiterte Sammlungs Regeln" dieses Themas.</span><span class="sxs-lookup"><span data-stu-id="cda19-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="cda19-121">Austauschbare Sammlungen</span><span class="sxs-lookup"><span data-stu-id="cda19-121">Interchangeable Collections</span></span>

<span data-ttu-id="cda19-122">Bei allen Listensammlungen des gleichen Typs wird davon ausgegangen, dass sie den gleichen Datenvertrag haben (es sei denn, sie wurden mit dem <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut individuell angepasst, wie weiter unten in diesem Thema beschrieben).</span><span class="sxs-lookup"><span data-stu-id="cda19-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="cda19-123">Daher stimmen beispielsweise die folgenden Datenverträge überein:</span><span class="sxs-lookup"><span data-stu-id="cda19-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="cda19-124">Beide Datenverträge führen zu XML-Code, ähnlich dem folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="cda19-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="cda19-125">Die Austauschbarkeit von Sammlungen ermöglicht Ihnen beispielsweise die Verwendung eines für die Leistung auf dem Server optimierten Sammlungstyps sowie eines Sammlungstyps, der für die Bindung an Benutzerschnittstellenkomponenten auf dem Client entwickelt wurde.</span><span class="sxs-lookup"><span data-stu-id="cda19-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="cda19-126">Ähnlich wie bei den Listensammlungen haben alle Wörterbuchsammlungen, die die gleichen Schlüssel- und Werttypen aufweisen, den gleichen Datenvertrag (es sei denn, sie wurden mit dem <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut individuell angepasst).</span><span class="sxs-lookup"><span data-stu-id="cda19-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="cda19-127">Nur der Datenvertragstyp ist, was die Sammlungsäquivalenz betrifft, wichtig, nicht die .NET-Typen,</span><span class="sxs-lookup"><span data-stu-id="cda19-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="cda19-128">d. h. eine Sammlung vom Typ1 gilt als äquivalent zu einer Sammlung vom Typ2, wenn Typ1 und Typ2 die gleichen Datenverträge aufweisen.</span><span class="sxs-lookup"><span data-stu-id="cda19-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="cda19-129">Bei nicht generischen Sammlungen wird davon ausgegangen, dass sie den gleichen Datenvertrag wie generische Sammlungen des Typs `Object`aufweisen.</span><span class="sxs-lookup"><span data-stu-id="cda19-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="cda19-130">(Beispielsweise sind die Datenverträge für die <xref:System.Collections.ArrayList> und die generische <xref:System.Collections.Generic.List%601> von `Object` gleich.)</span><span class="sxs-lookup"><span data-stu-id="cda19-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="cda19-131">Verwenden von Sammlungsschnittstellentypen und schreibgeschützten Sammlungen</span><span class="sxs-lookup"><span data-stu-id="cda19-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="cda19-132">Bei Sammlungsschnittstellentypen (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generische <xref:System.Collections.Generic.IDictionary%602>oder von diesen Schnittstellen abgeleiteten Schnittstellen) wird ebenfalls davon ausgegangen, dass sie die gleichen Sammlungsdatenverträge aufweisen wie die tatsächlichen Sammlungstypen.</span><span class="sxs-lookup"><span data-stu-id="cda19-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="cda19-133">Daher ist es möglich, den serialisierten Typ als einen Sammlungsschnittstellentyp zu deklarieren. Die Ergebnisse sind die gleichen wie bei der Verwendung eines tatsächlichen Sammlungstyps.</span><span class="sxs-lookup"><span data-stu-id="cda19-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="cda19-134">So stimmen beispielsweise die folgenden Datenverträge überein:</span><span class="sxs-lookup"><span data-stu-id="cda19-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="cda19-135">Wenn der deklarierte Typ eine Schnittstelle ist, kann der derzeit verwendete Instanzentyp während der Serialisierung ein beliebiger Typ sein, der diese Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="cda19-136">Die zuvor beschriebenen Einschränkungen (mit einem Parameter losen Konstruktor und einer- `Add` Methode) gelten nicht.</span><span class="sxs-lookup"><span data-stu-id="cda19-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="cda19-137">Beispielsweise können Sie Adressen in Customer2 auf eine Instanz einer generischen <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> von "Adress" einstellen, auch wenn es Ihnen nicht möglich ist, einen Datenmember des Typs "Generische <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>" direkt zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="cda19-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="cda19-138">Wenn der deklarierte Typ eine Schnittstelle ist, wählt die Serialisierungs-Engine während der Deserialisierung einen Typ, der die deklarierte Schnittstelle implementiert, und der Typ wird instanziiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="cda19-139">Der Mechanismus der bekannten Typen (beschrieben in " [Data Contract Known Types](data-contract-known-types.md)") hat hier keine Auswirkung. die Auswahl des Typs ist in WCF integriert.</span><span class="sxs-lookup"><span data-stu-id="cda19-139">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="cda19-140">Anpassen von Sammlungstypen</span><span class="sxs-lookup"><span data-stu-id="cda19-140">Customizing Collection Types</span></span>

<span data-ttu-id="cda19-141">Sie können Sammlungstypen anpassen, indem Sie das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut verwenden, das auf verschiedene Weise genutzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="cda19-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="cda19-142">Beachten Sie, dass das Anpassen von Sammlungstypen die Austauschbarkeit von Sammlungen beeinträchtigt. Daher wird empfohlen, das Anwenden dieses Attributs wenn möglich zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="cda19-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="cda19-143">Weitere Informationen zu diesem Problem finden Sie im Abschnitt "Erweiterte Sammlungs Regeln" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="cda19-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="cda19-144">Benennen von Sammlungsdatenverträgen</span><span class="sxs-lookup"><span data-stu-id="cda19-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="cda19-145">Die Regeln für das Benennen von Sammlungstypen ähneln den Regeln für das Benennen von Datenvertragstypen, wie unter [Data Contract Names](data-contract-names.md)beschrieben. Es bestehen jedoch einige wichtige Unterschiede:</span><span class="sxs-lookup"><span data-stu-id="cda19-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="cda19-146">Zum Anpassen des Namens wird das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut verwendet und nicht das <xref:System.Runtime.Serialization.DataContractAttribute> -Attribut.</span><span class="sxs-lookup"><span data-stu-id="cda19-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="cda19-147">Das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut weist außerdem `Name` - und `Namespace` -Eigenschaften auf.</span><span class="sxs-lookup"><span data-stu-id="cda19-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="cda19-148">Wenn das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut nicht angewendet wird, hängen der Standardname und der Standardnamespace für Sammlungstypen von den Namen und Namespaces der Typen ab, die in der Sammlung enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="cda19-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="cda19-149">Sie werden nicht vom Namen und dem Namespace des Sammlungstyps selbst beeinflusst.</span><span class="sxs-lookup"><span data-stu-id="cda19-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="cda19-150">Ein Beispiel finden Sie in den folgenden Typen:</span><span class="sxs-lookup"><span data-stu-id="cda19-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="cda19-151">Die Datenvertragsnamen beider Typen lauten "ArrayOfstring" (und nicht "CustomerList1" oder "StringList1"),</span><span class="sxs-lookup"><span data-stu-id="cda19-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="cda19-152">d. h., dass sich durch die Serialisierung eines dieser Typen auf der Stammebene XML-Code ähnlich dem folgenden Code ergibt:</span><span class="sxs-lookup"><span data-stu-id="cda19-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="cda19-153">Diese Benennungsregel wurde gewählt, um sicherzustellen, dass sämtliche nicht benutzerdefinierten Typen, die eine Liste von Zeichenfolgen darstellen, den gleichen Datenvertrag und die gleiche XML-Darstellung haben.</span><span class="sxs-lookup"><span data-stu-id="cda19-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="cda19-154">Dies macht Sammlungsaustauschbarkeit möglich.</span><span class="sxs-lookup"><span data-stu-id="cda19-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="cda19-155">In diesem Beispiel sind "CustomerList1" und "StringList1" vollständig austauschbar.</span><span class="sxs-lookup"><span data-stu-id="cda19-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="cda19-156">Wenn jedoch das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut angewendet wird, wird die Sammlung zu einem benutzerdefinierten Sammlungsdatenvertrag, auch wenn keine Eigenschaften für das Attribut festgelegt wurden.</span><span class="sxs-lookup"><span data-stu-id="cda19-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="cda19-157">Der Name und der Namespace des Sammlungsdatenvertrags hängen dann vom Sammlungstyp selbst ab.</span><span class="sxs-lookup"><span data-stu-id="cda19-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="cda19-158">Ein Beispiel finden Sie im folgenden Typ:</span><span class="sxs-lookup"><span data-stu-id="cda19-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="cda19-159">Nach der Serialisierung ähneln die resultierenden XML-Daten Folgendem:</span><span class="sxs-lookup"><span data-stu-id="cda19-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="cda19-160">Beachten Sie, dass dies nicht mehr der XML-Darstellung der nicht benutzerdefinierten Typen entspricht.</span><span class="sxs-lookup"><span data-stu-id="cda19-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="cda19-161">Sie können die `Name` - und die `Namespace` -Eigenschaft verwenden, um die Benennung noch weiter anzupassen.</span><span class="sxs-lookup"><span data-stu-id="cda19-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="cda19-162">Siehe folgende Klasse.</span><span class="sxs-lookup"><span data-stu-id="cda19-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="cda19-163">Die resultierenden XML-Daten ähneln Folgendem:</span><span class="sxs-lookup"><span data-stu-id="cda19-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="cda19-164">Weitere Informationen finden Sie im Abschnitt "Erweiterte Sammlungs Regeln" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="cda19-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="cda19-165">Anpassen des sich wiederholenden Elementnamens in Listensammlungen</span><span class="sxs-lookup"><span data-stu-id="cda19-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="cda19-166">Listensammlungen enthalten sich wiederholende Einträge.</span><span class="sxs-lookup"><span data-stu-id="cda19-166">List collections contain repeating entries.</span></span> <span data-ttu-id="cda19-167">In der Regel wird jeder sich wiederholende Eintrag als Element dargestellt, das gemäß dem Datenvertragsnamen des in der Sammlung enthaltenen Typs benannt ist.</span><span class="sxs-lookup"><span data-stu-id="cda19-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="cda19-168">In den `CustomerList` -Beispielen enthielten die Sammlungen Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="cda19-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="cda19-169">Der Daten Vertrags Name für den primitiven Typ der Zeichenfolge ist "String", sodass das sich wiederholende Element " \<string> " lautet.</span><span class="sxs-lookup"><span data-stu-id="cda19-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="cda19-170">Wenn jedoch die <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> -Eigenschaft auf dem <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut verwendet wird, kann dieser sich wiederholende Elementname angepasst werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="cda19-171">Ein Beispiel finden Sie im folgenden Typ:</span><span class="sxs-lookup"><span data-stu-id="cda19-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="cda19-172">Die resultierenden XML-Daten ähneln Folgendem:</span><span class="sxs-lookup"><span data-stu-id="cda19-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="cda19-173">Der Namespace des sich wiederholenden Elements entspricht stets dem Namespace des Sammlungsdatenvertrags, der mithilfe der `Namespace` -Eigenschaft angepasst werden kann, wie zuvor beschrieben.</span><span class="sxs-lookup"><span data-stu-id="cda19-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="cda19-174">Anpassen von Wörterbuchsammlungen</span><span class="sxs-lookup"><span data-stu-id="cda19-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="cda19-175">Wörterbuchsammlungen sind im Grunde Listen von Einträgen, bei denen jeder Eintrag über einen Schlüssel gefolgt von einem Wert verfügt.</span><span class="sxs-lookup"><span data-stu-id="cda19-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="cda19-176">Genau wie bei normalen Listen können Sie den dem sich wiederholenden Element entsprechenden Elementnamen mit der <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> -Eigenschaft ändern.</span><span class="sxs-lookup"><span data-stu-id="cda19-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="cda19-177">Darüber hinaus können Sie die Elementnamen ändern, die für den Schlüssel und den Wert stehen, indem Sie die <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> - und die <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> -Eigenschaft verwenden.</span><span class="sxs-lookup"><span data-stu-id="cda19-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="cda19-178">Die Namespaces für diese Elemente entsprechen dem Namespace des Sammlungsdatenvertrags.</span><span class="sxs-lookup"><span data-stu-id="cda19-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="cda19-179">Ein Beispiel finden Sie im folgenden Typ:</span><span class="sxs-lookup"><span data-stu-id="cda19-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="cda19-180">Nach der Serialisierung ähneln die resultierenden XML-Daten Folgendem:</span><span class="sxs-lookup"><span data-stu-id="cda19-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="cda19-181">Weitere Informationen zu Wörterbuch Sammlungen finden Sie weiter unten in diesem Thema im Abschnitt "Erweiterte Sammlungs Regeln".</span><span class="sxs-lookup"><span data-stu-id="cda19-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="cda19-182">Sammlungen und bekannte Typen</span><span class="sxs-lookup"><span data-stu-id="cda19-182">Collections and Known Types</span></span>

<span data-ttu-id="cda19-183">Sie müssen Sammlungstypen nicht bekannten Typen hinzufügen, wenn sie polymorph anstelle von anderen Sammlungen oder Sammlungsschnittstellen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="cda19-184">Wenn Sie beispielsweise einen Datenmember des Typs <xref:System.Collections.IEnumerable> deklarieren und dazu verwenden, eine Instanz von <xref:System.Collections.ArrayList>zu senden, müssen Sie <xref:System.Collections.ArrayList> nicht bekannten Typen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="cda19-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="cda19-185">Wenn Sie anstelle von Typen polymorphe Sammlungen verwenden, bei denen es sich nicht um Sammlungstypen handelt, müssen sie bekannten Typen hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="cda19-186">Wenn Sie beispielsweise einen Datenmember des Typs `Object` deklarieren und dazu verwenden, eine Instanz von <xref:System.Collections.ArrayList>zu senden, müssen Sie <xref:System.Collections.ArrayList> bekannten Typen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="cda19-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="cda19-187">Dies ermöglicht es Ihnen nicht, eine äquivalente Sammlung polymorph zu serialisieren.</span><span class="sxs-lookup"><span data-stu-id="cda19-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="cda19-188">Wenn Sie beispielsweise <xref:System.Collections.ArrayList> der Liste bekannter Typen im vorherigen Beispiel hinzufügen, ist es Ihnen nicht möglich, die `Array of Object` -Klasse zuzuweisen, obwohl sie den gleichen Datenvertrag aufweist.</span><span class="sxs-lookup"><span data-stu-id="cda19-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="cda19-189">Dieses Verhalten unterscheidet sich nicht vom regulären Verhalten bekannter Typen bei der Serialisierung für Typen, bei denen es sich nicht um Sammlungstypen handelt. Es ist jedoch besonders wichtig, sich im Falle von Sammlungen hierüber im Klaren zu sein, da Sammlungen sehr häufig äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="cda19-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="cda19-190">Während der Serialisierung kann lediglich ein Typ in einem bestimmten Bereich für einen bestimmten Datenvertrag bekannt sein, und äquivalente Sammlungen besitzen alle die gleichen Datenverträge.</span><span class="sxs-lookup"><span data-stu-id="cda19-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="cda19-191">Das bedeutet, dass Sie im vorherigen Beispiel nicht beide Elemente ( <xref:System.Collections.ArrayList> und `Array of Object` ) bekannten Typen im gleichen Bereich hinzufügen können.</span><span class="sxs-lookup"><span data-stu-id="cda19-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="cda19-192">Dies entspricht erneut dem Verhalten bekannter Typen für Typen, bei denen es sich nicht um Sammlungstypen handelt. Es ist jedoch besonders wichtig, sich im Falle von Sammlungen hierüber im Klaren zu sein.</span><span class="sxs-lookup"><span data-stu-id="cda19-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="cda19-193">Bekannte Typen sind möglicherweise auch für Inhalte von Sammlungen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="cda19-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="cda19-194">Wenn beispielsweise eine <xref:System.Collections.ArrayList> wirklich Instanzen eines `Type1` und eines `Type2`enthält, sollten beide Typen bekannten Typen hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="cda19-195">Im folgenden Beispiel wird ein ordnungsgemäß erstelltes Objektdiagramm mit Sammlungen und bekannten Typen dargestellt.</span><span class="sxs-lookup"><span data-stu-id="cda19-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="cda19-196">(Das Beispiel ist frei erfunden, da Sie in einer echten Anwendung normalerweise die folgenden Datenmember nicht als `Object`definieren und daher auch keine Probleme mit bekannten Typen/Polymorphie auftreten würden.)</span><span class="sxs-lookup"><span data-stu-id="cda19-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="cda19-197">Wenn der deklarierte Typ ein Sammlungstyp ist, wird der deklarierte Typ bei der Deserialisierung instanziiert, unabhängig vom Typ, der tatsächlich gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="cda19-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="cda19-198">Wenn der deklarierte Typ eine Sammlungsschnittstelle ist, wählt das Deserialisierungsprogramm einen zu instanziierenden Typ aus, unabhängig von bekannten Typen.</span><span class="sxs-lookup"><span data-stu-id="cda19-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="cda19-199">Wenn der deklarierte Typ bei der Deserialisierung kein Sammlungstyp ist, jedoch ein Sammlungstyp gesendet wird, wird ein entsprechender Sammlungstyp aus der Liste der bekannten Typen ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="cda19-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="cda19-200">Es ist möglich, bei der Deserialisierung der Liste bekannter Typen Sammlungsschnittstellentypen hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="cda19-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="cda19-201">In diesem Fall wählt die Deserialisierungs-Engine erneut einen Typ aus, der instanziiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="cda19-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="cda19-202">Sammlungen und die NetDataContractSerializer-Klasse</span><span class="sxs-lookup"><span data-stu-id="cda19-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="cda19-203">Wenn die <xref:System.Runtime.Serialization.NetDataContractSerializer> -Klasse verwendet wird, verlieren nicht benutzerdefinierte Sammlungstypen (ohne das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut), bei denen es sich nicht um Arrays handelt, ihre spezielle Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="cda19-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="cda19-204">Nicht benutzerdefinierte Sammlungstypen, die mit dem <xref:System.SerializableAttribute> -Attribut gekennzeichnet sind, können dennoch von der <xref:System.Runtime.Serialization.NetDataContractSerializer> -Klasse gemäß den Regeln für das <xref:System.SerializableAttribute> -Attribut oder die <xref:System.Runtime.Serialization.ISerializable> -Schnittstelle serialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="cda19-205">Benutzerdefinierte Sammlungstypen, Sammlungsschnittstellen und Arrays werden weiterhin als Sammlungen behandelt, selbst wenn die <xref:System.Runtime.Serialization.NetDataContractSerializer> -Klasse verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="cda19-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="cda19-206">Sammlungen und Schema</span><span class="sxs-lookup"><span data-stu-id="cda19-206">Collections and Schema</span></span>

<span data-ttu-id="cda19-207">Alle äquivalenten Sammlungen verfügen über die gleiche Darstellung im XSD-Schema (XML Schema Definition Language).</span><span class="sxs-lookup"><span data-stu-id="cda19-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="cda19-208">Daher erhalten Sie im generierten Clientcode normalerweise nicht den gleichen Sammlungstyp wie auf dem Server.</span><span class="sxs-lookup"><span data-stu-id="cda19-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="cda19-209">Beispielsweise kann der Server einen Datenvertrag mit einer generischen <xref:System.Collections.Generic.List%601> für den Datenmember "Integer" verwenden, im generierten Clientcode kann der gleiche Datenmember jedoch ein Array von ganzen Zahlen werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="cda19-210">Wörterbuch Sammlungen sind mit einer WCF-spezifischen Schema Anmerkung gekennzeichnet, die darauf hinweist, dass es sich um Wörterbücher handelt. Andernfalls können Sie nicht von einfachen Listen unterschieden werden, die Einträge mit einem Schlüssel und einem Wert enthalten.</span><span class="sxs-lookup"><span data-stu-id="cda19-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="cda19-211">Eine genaue Beschreibung, wie Sammlungen in einem Datenvertragsschema dargestellt werden, finden Sie unter [Data Contract Schema Reference](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="cda19-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="cda19-212">Standardmäßig werden Typen nicht für nicht benutzerdefinierte Sammlungen in importiertem Code generiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="cda19-213">Datenmember von Listensammlungstypen werden als Arrays importiert, und Datenmember von Wörterbuchsammlungstypen werden als generisches Wörterbuch importiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="cda19-214">Für benutzerdefinierte Sammlungen werden jedoch separate Typen generiert, die mit dem <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="cda19-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="cda19-215">(Ein benutzerdefinierter Sammlungstyp im Schema ist eine, die nicht den Standard Namespace, den Namen, den Namen des wiederholten Elements oder die Schlüssel-Wert-Elementnamen verwendet.) Bei diesen Typen handelt es sich um leere Typen, die von generisch <xref:System.Collections.Generic.List%601> für Listen Typen und generisches Wörterbuch für Wörterbuchtypen abgeleitet</span><span class="sxs-lookup"><span data-stu-id="cda19-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="cda19-216">Es können z. B. folgende Typen auf dem Server vorliegen:</span><span class="sxs-lookup"><span data-stu-id="cda19-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="cda19-217">Wenn das Schema exportiert und anschließend wieder importiert wird, ähnelt der generierte Clientcode dem folgenden Code (statt Eigenschaften werden zur Erleichterung des Lesens Felder angezeigt).</span><span class="sxs-lookup"><span data-stu-id="cda19-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="cda19-218">Möglicherweise möchten Sie andere Typen als die Standardtypen in generiertem Code verwenden.</span><span class="sxs-lookup"><span data-stu-id="cda19-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="cda19-219">Es könnte z. B. sein, dass Sie die generische <xref:System.ComponentModel.BindingList%601> statt regulärer Arrays für Ihre Datenmember verwenden möchten, um sie leichter an Benutzerschnittstellenkomponenten binden zu können.</span><span class="sxs-lookup"><span data-stu-id="cda19-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="cda19-220">Übergeben Sie zum Auswählen der zu generierenden Sammlungstypen eine Liste der Sammlungstypen, die Sie verwenden möchten, in die <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> -Eigenschaft des <xref:System.Runtime.Serialization.ImportOptions> -Objekts, wenn Sie das Schema importieren.</span><span class="sxs-lookup"><span data-stu-id="cda19-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="cda19-221">Diese Typen werden als *referenzierte Sammlungstypen*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="cda19-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="cda19-222">Wenn auf generische Typen verwiesen wird, müssen sie entweder vollständig offene oder vollständig geschlossene Generics sein.</span><span class="sxs-lookup"><span data-stu-id="cda19-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="cda19-223">Wenn Sie das Tool „Svcutil.exe“ verwenden, kann dieser Verweis über den **/collectionType** -Befehlszeilenschalter (Kurzform: **/ct**) erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="cda19-224">Denken Sie daran, dass Sie auch die Assembly für die referenzierten Sammlungstypen über den **/reference** -Schalter (Kurzform: **/r**) angeben müssen.</span><span class="sxs-lookup"><span data-stu-id="cda19-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="cda19-225">Bei generischen Typen folgt auf den Namen des Typs ein Graviszeichen und die Anzahl der generischen Parameter.</span><span class="sxs-lookup"><span data-stu-id="cda19-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="cda19-226">Das backanführungs \` Zeichen () muss nicht mit dem einfachen Anführungszeichen (') verwechselt werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="cda19-227">Sie können mehrere referenzierte Sammlungstypen angeben, indem Sie den **/collectionType** -Schalter mehrmals verwenden.</span><span class="sxs-lookup"><span data-stu-id="cda19-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="cda19-228">Beispielsweise, um zu bewirken, dass alle Listen als generische <xref:System.Collections.Generic.List%601>importiert werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="cda19-229">Beim Importieren einer beliebigen Sammlung wird die Liste der referenzierten Sammlungstypen gescannt, und die am besten passende Sammlung wird verwendet (sofern vorhanden) – entweder als Datenmembertyp (für nicht benutzerdefinierte Sammlungen) oder als Basistyp, von dem abgeleitet wird (für benutzerdefinierte Sammlungen).</span><span class="sxs-lookup"><span data-stu-id="cda19-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="cda19-230">Wörterbücher werden nur Wörterbüchern gegenübergestellt, während Listen Listen gegenübergestellt werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="cda19-231">Wenn Sie beispielsweise die generische <xref:System.ComponentModel.BindingList%601> und <xref:System.Collections.Hashtable> der Liste referenzierter Typen hinzufügen, ähnelt der generierte Clientcode für das vorangegangene Beispiel dem folgenden.</span><span class="sxs-lookup"><span data-stu-id="cda19-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="cda19-232">Sie können Sammlungsschnittstellentypen als Teil Ihrer referenzierten Sammlungstypen angeben, jedoch können Sie keine ungültigen Sammlungstypen angeben (wie diejenigen ohne `Add` -Methode oder öffentlichen Konstruktor).</span><span class="sxs-lookup"><span data-stu-id="cda19-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="cda19-233">Ein geschlossener generischer Typ wird als beste Übereinstimmung betrachtet.</span><span class="sxs-lookup"><span data-stu-id="cda19-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="cda19-234">(Nicht generische Typen werden als äquivalent zu geschlossenen Generics von `Object`betrachtet).</span><span class="sxs-lookup"><span data-stu-id="cda19-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="cda19-235">Wenn beispielsweise die Typen "Generische <xref:System.Collections.Generic.List%601> von <xref:System.DateTime>", "Generische <xref:System.ComponentModel.BindingList%601> " (offener generischer Typ) und " <xref:System.Collections.ArrayList> " die referenzierten Sammlungstypen sind, wird Folgendes generiert:</span><span class="sxs-lookup"><span data-stu-id="cda19-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="cda19-236">Für Listensammlungen werden nur die Fälle aus der folgenden Tabelle unterstützt:</span><span class="sxs-lookup"><span data-stu-id="cda19-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="cda19-237">Referenzierter Typ</span><span class="sxs-lookup"><span data-stu-id="cda19-237">Referenced type</span></span>|<span data-ttu-id="cda19-238">Vom referenzierten Typ implementierte Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="cda19-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="cda19-239">Beispiel</span><span class="sxs-lookup"><span data-stu-id="cda19-239">Example</span></span>|<span data-ttu-id="cda19-240">Typ behandelt als:</span><span class="sxs-lookup"><span data-stu-id="cda19-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="cda19-241">Nicht generisch oder geschlossen generisch (beliebige Anzahl von Parametern)</span><span class="sxs-lookup"><span data-stu-id="cda19-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="cda19-242">Nicht generisch</span><span class="sxs-lookup"><span data-stu-id="cda19-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="cda19-243">oder</span><span class="sxs-lookup"><span data-stu-id="cda19-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="cda19-244">, wobei T= `int`</span><span class="sxs-lookup"><span data-stu-id="cda19-244">where T= `int`</span></span>|<span data-ttu-id="cda19-245">Geschlossen generisch von `Object` (z. B. `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="cda19-246">Nicht generisch oder geschlossen generisch (beliebige Anzahl von Parametern, die nicht notwendigerweise mit dem Sammlungstyp übereinstimmen)</span><span class="sxs-lookup"><span data-stu-id="cda19-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="cda19-247">Geschlossen generisch</span><span class="sxs-lookup"><span data-stu-id="cda19-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="cda19-248">oder</span><span class="sxs-lookup"><span data-stu-id="cda19-248">or</span></span><br /><br /> <span data-ttu-id="cda19-249">`MyType<T> : IList<string>` , wobei T=`int`</span><span class="sxs-lookup"><span data-stu-id="cda19-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="cda19-250">Geschlossen generisch (z. B. `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="cda19-251">Geschlossen generisch mit einer beliebigen Anzahl an Parametern</span><span class="sxs-lookup"><span data-stu-id="cda19-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="cda19-252">Offen generisch mit einem beliebigen Parameter des Typs</span><span class="sxs-lookup"><span data-stu-id="cda19-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="cda19-253">, wobei T=`int`, U=`string`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="cda19-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="cda19-254">Geschlossen generisch (z. B. `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="cda19-255">Offen generisch mit einem Parameter</span><span class="sxs-lookup"><span data-stu-id="cda19-255">Open generic with one parameter</span></span>|<span data-ttu-id="cda19-256">Offen generisch mit dem Parameter des Typs</span><span class="sxs-lookup"><span data-stu-id="cda19-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="cda19-257">`MyType<T> : IList<T>`, T ist offen</span><span class="sxs-lookup"><span data-stu-id="cda19-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="cda19-258">Offen generisch (z. B. `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="cda19-259">Wenn ein Typ mehr als eine Listensammlungsschnittstelle implementiert, gelten die folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="cda19-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="cda19-260">Wenn der Typ das generische <xref:System.Collections.Generic.IEnumerable%601> (oder die davon abgeleiteten Schnittstellen) mehrfach für verschiedene Typen implementiert, gilt der Typ nicht als gültiger referenzierter Sammlungstyp und wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="cda19-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="cda19-261">Dies gilt auch, wenn einige Implementierungen ungültig sind oder offene Generics verwenden.</span><span class="sxs-lookup"><span data-stu-id="cda19-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="cda19-262">Beispielsweise würde ein Typ, der das generische <xref:System.Collections.Generic.IEnumerable%601> von `int` und das generische <xref:System.Collections.Generic.IEnumerable%601> von T implementiert, niemals als referenzierte Sammlung von `int` oder eines anderen Typs verwendet werden, unabhängig davon, ob der Typ eine `Add` -Methode, die `int` akezptiert, oder eine `Add` -Methode, die einen Parameter vom Typ T akzeptiert, oder beides aufweist.</span><span class="sxs-lookup"><span data-stu-id="cda19-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="cda19-263">Wenn der Typ eine generische Sammlungsschnittstelle sowie <xref:System.Collections.IList>implementiert, wird er niemals als referenzierter Sammlungstyp verwendet, es sei denn, die generische Sammlungsschnittstelle ist ein geschlossener generischer Typ vom Typ <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="cda19-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="cda19-264">Für Wörterbuchsammlungen werden nur die Fälle aus der folgenden Tabelle unterstützt:</span><span class="sxs-lookup"><span data-stu-id="cda19-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="cda19-265">Referenzierter Typ</span><span class="sxs-lookup"><span data-stu-id="cda19-265">Referenced type</span></span>|<span data-ttu-id="cda19-266">Vom referenzierten Typ implementierte Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="cda19-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="cda19-267">Beispiel</span><span class="sxs-lookup"><span data-stu-id="cda19-267">Example</span></span>|<span data-ttu-id="cda19-268">Typ behandelt als</span><span class="sxs-lookup"><span data-stu-id="cda19-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="cda19-269">Nicht generisch oder geschlossen generisch (beliebige Anzahl von Parametern)</span><span class="sxs-lookup"><span data-stu-id="cda19-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="cda19-270">oder</span><span class="sxs-lookup"><span data-stu-id="cda19-270">or</span></span><br /><br /> <span data-ttu-id="cda19-271">`MyType<T> : IDictionary` , wobei T=`int`</span><span class="sxs-lookup"><span data-stu-id="cda19-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="cda19-272">Geschlossenes generisches `IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="cda19-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="cda19-273">Geschlossen generisch (beliebigen Anzahl an Parametern)</span><span class="sxs-lookup"><span data-stu-id="cda19-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="cda19-274"><xref:System.Collections.Generic.IDictionary%602>, geschlossen</span><span class="sxs-lookup"><span data-stu-id="cda19-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="cda19-275">`MyType<T> : IDictionary<string, bool>` , wobei T=`int`</span><span class="sxs-lookup"><span data-stu-id="cda19-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="cda19-276">Geschlossen generisch (z. B. `IDIctionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="cda19-277">Geschlossen generisch (beliebigen Anzahl an Parametern)</span><span class="sxs-lookup"><span data-stu-id="cda19-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="cda19-278">Generisches <xref:System.Collections.Generic.IDictionary%602>, entweder der Schlüssel oder der Wert ist geschlossen, das andere Element ist offen und verwendet einen Parameter des Typs</span><span class="sxs-lookup"><span data-stu-id="cda19-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="cda19-279">`MyType<T,U,V> : IDictionary<string,V>` , wobei T=`int`, U=`float`, V=`bool`</span><span class="sxs-lookup"><span data-stu-id="cda19-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="cda19-280">oder</span><span class="sxs-lookup"><span data-stu-id="cda19-280">or</span></span><br /><br /> <span data-ttu-id="cda19-281">`MyType<Z> : IDictionary<Z,bool>` , wobei Z=`string`</span><span class="sxs-lookup"><span data-stu-id="cda19-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="cda19-282">Geschlossen generisch (z. B. `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="cda19-283">Geschlossen generisch (beliebigen Anzahl an Parametern)</span><span class="sxs-lookup"><span data-stu-id="cda19-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="cda19-284">Generisches <xref:System.Collections.Generic.IDictionary%602>, sowohl Schlüssel als auch Wert sind geöffnet und verwenden beide jeweils einen Parameter des Typs</span><span class="sxs-lookup"><span data-stu-id="cda19-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="cda19-285">`MyType<T,U,V> : IDictionary<V,U>` , wobei T=`int`, U=`bool`, V=`string`</span><span class="sxs-lookup"><span data-stu-id="cda19-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="cda19-286">Geschlossen generisch (z. B. `IDictionary<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="cda19-287">Offen generisch (zwei Parameter)</span><span class="sxs-lookup"><span data-stu-id="cda19-287">Open generic (two parameters)</span></span>|<span data-ttu-id="cda19-288">Generisches <xref:System.Collections.Generic.IDictionary%602>, offen, verwendet beide generischen Parametern des Typs in der Reihenfolge, in der sie angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="cda19-289">`MyType<K,V> : IDictionary<K,V>`, K und V beide offen</span><span class="sxs-lookup"><span data-stu-id="cda19-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="cda19-290">Offen generisch (z. B. `IDictionary<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="cda19-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="cda19-291">Wenn der Typ sowohl das <xref:System.Collections.IDictionary> als auch das generische <xref:System.Collections.Generic.IDictionary%602>implementiert, wird nur das generische <xref:System.Collections.Generic.IDictionary%602> betrachtet.</span><span class="sxs-lookup"><span data-stu-id="cda19-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="cda19-292">Das Verweisen auf teilweise generische Typen wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="cda19-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="cda19-293">Duplikate sind nicht zulässig. Beispielsweise können Sie nicht sowohl die generische <xref:System.Collections.Generic.List%601> von `Integer` als auch die generische Sammlung von `Integer`<xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>hinzufügen, da anschließend nicht mehr festgestellt werden kann, was verwendet werden soll, wenn eine Liste mit ganzen Zahlen im Schema auftritt.</span><span class="sxs-lookup"><span data-stu-id="cda19-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="cda19-294">Duplikate werden nur erkannt, wenn es einen Typ im Schema gibt, der das Duplikatproblem offenlegt.</span><span class="sxs-lookup"><span data-stu-id="cda19-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="cda19-295">Wenn z. B. das importierte Schema keine Liste mit ganzen Zahlen enthält, kann es sowohl über die generische <xref:System.Collections.Generic.List%601> von `Integer` als auch über die generische Sammlung von `Integer` in den <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>verfügen, doch nichts davon zeigt eine Wirkung.</span><span class="sxs-lookup"><span data-stu-id="cda19-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="cda19-296">Erweiterte Sammlungsregeln</span><span class="sxs-lookup"><span data-stu-id="cda19-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="cda19-297">Serialisieren von Sammlungen</span><span class="sxs-lookup"><span data-stu-id="cda19-297">Serializing Collections</span></span>

<span data-ttu-id="cda19-298">Im Folgenden finden Sie eine Liste mit Sammlungsregeln für die Serialisierung:</span><span class="sxs-lookup"><span data-stu-id="cda19-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="cda19-299">Das Kombinieren von Sammlungstypen (das Erstellen von Sammlungen von Sammlungen) ist zulässig.</span><span class="sxs-lookup"><span data-stu-id="cda19-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="cda19-300">Verzweigte Arrays werden als Sammlungen von Sammlungen behandelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="cda19-301">Arrays mit mehreren Dimensionen werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="cda19-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="cda19-302">Byte- und <xref:System.Xml.XmlNode> -Arrays sind besondere Arraytypen, die als Primitive und nicht als Sammlungen behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="cda19-303">Die Serialisierung eines Bytearrays führt zu einem einzelnen XML-Element, das statt eines separaten Elements für jedes Byte einen Abschnitt aus Base64-codierten Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="cda19-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="cda19-304">Weitere Informationen zur Behandlung eines Arrays von finden Sie unter <xref:System.Xml.XmlNode> [XML-und ADO.NET-Typen in Daten Verträgen](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="cda19-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="cda19-305">Natürlich können diese besonderen Typen selbst Teil von Sammlungen sein: Ein Bytearray führt zu mehreren XML-Elementen, die jeweils einen Abschnitt aus Base64-codierten Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="cda19-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="cda19-306">Wenn das <xref:System.Runtime.Serialization.DataContractAttribute> -Attribut auf einen Sammlungstyp angewendet wird, wird der Typ als regulärer Datenvertragstyp und nicht als Sammlung behandelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="cda19-307">Wenn ein Sammlungstyp die <xref:System.Xml.Serialization.IXmlSerializable> -Schnittstelle implementiert, dann gelten die folgenden Regeln, wenn ein `myType:IList<string>, IXmlSerializable`-Typ vorliegt:</span><span class="sxs-lookup"><span data-stu-id="cda19-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="cda19-308">Wird als Typ `IList<string>`deklariert, wird der Typ als Liste serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="cda19-309">Wird als Typ `myType`deklariert, wird der Typ als `IXmlSerializable`serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="cda19-310">Wenn der deklarierte Typ `IXmlSerializable`lautet, wird der Typ nur dann als `IXmlSerializable`serialisiert, wenn Sie `myType` der Liste bekannter Typen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="cda19-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="cda19-311">Sammlungen werden mit den Methoden aus der folgenden Tabelle serialisiert und deserialisiert:</span><span class="sxs-lookup"><span data-stu-id="cda19-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="cda19-312">Sammlungstyp implementiert</span><span class="sxs-lookup"><span data-stu-id="cda19-312">Collection type implements</span></span>|<span data-ttu-id="cda19-313">Bei der Serialisierung aufgerufene Methode(n)</span><span class="sxs-lookup"><span data-stu-id="cda19-313">Method(s) called on serialization</span></span>|<span data-ttu-id="cda19-314">Bei der Deserialisierung aufgerufene Methode(n)</span><span class="sxs-lookup"><span data-stu-id="cda19-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="cda19-315">Generisches <xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="cda19-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="cda19-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="cda19-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="cda19-317">Generisches Hinzufügen</span><span class="sxs-lookup"><span data-stu-id="cda19-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="cda19-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="cda19-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="cda19-319">Generisches <xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="cda19-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="cda19-320">Generischer <xref:System.Collections.Generic.IList%601> -Indexer</span><span class="sxs-lookup"><span data-stu-id="cda19-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="cda19-321">Generisches Hinzufügen</span><span class="sxs-lookup"><span data-stu-id="cda19-321">Generic Add</span></span>|
|<span data-ttu-id="cda19-322">Generisches <xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="cda19-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="cda19-323">Enumerator</span><span class="sxs-lookup"><span data-stu-id="cda19-323">Enumerator</span></span>|<span data-ttu-id="cda19-324">Generisches Hinzufügen</span><span class="sxs-lookup"><span data-stu-id="cda19-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="cda19-325"><xref:System.Collections.IList> -Indexer</span><span class="sxs-lookup"><span data-stu-id="cda19-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="cda19-326">Generisches <xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="cda19-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="cda19-327">Eine nicht statische Methode mit dem Namen `Add` , die einen Parameter des entsprechenden Typs annimmt (den Typ des generischen Parameters oder einen der Basistypen).</span><span class="sxs-lookup"><span data-stu-id="cda19-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="cda19-328">Eine solche Methode ist erforderlich, damit das Serialisierungsprogramm einen Sammlungstyp sowohl während der Serialisierung als auch während der Deserialisierung als Sammlung behandelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="cda19-329"><xref:System.Collections.IEnumerable> (und daher <xref:System.Collections.ICollection>, die sich daraus ableitet)</span><span class="sxs-lookup"><span data-stu-id="cda19-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="cda19-330">Eine nicht statische Methode namens `Add` , die einen Parameter des Typs `Object`annimmt.</span><span class="sxs-lookup"><span data-stu-id="cda19-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="cda19-331">Eine solche Methode ist erforderlich, damit das Serialisierungsprogramm einen Sammlungstyp sowohl während der Serialisierung als auch während der Deserialisierung als Sammlung behandelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="cda19-332">In der vorangehenden Tabelle werden in absteigender Reihenfolge Sammlungsschnittstellen aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="cda19-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="cda19-333">Das bedeutet beispielsweise, dass die Sammlung gemäß den <xref:System.Collections.IList> -Regeln serialisiert und deserialisiert wird, wenn ein Typ sowohl die <xref:System.Collections.Generic.IEnumerable%601>als auch das generische <xref:System.Collections.IList> implementiert:</span><span class="sxs-lookup"><span data-stu-id="cda19-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="cda19-334">Bei der Deserialisierung werden alle Sammlungen deserialisiert, indem zuerst eine Instanz des Typs erstellt wird, indem der Parameter lose Konstruktor aufgerufen wird, der vorhanden sein muss, damit das Serialisierungsprogramm einen Sammlungstyp während der Serialisierung und Deserialisierung als Auflistung behandelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="cda19-335">Wenn die gleiche generische Sammlungsschnittstelle mehrmals implementiert wird (z. B. wenn ein Typ sowohl die generische <xref:System.Collections.Generic.ICollection%601> von `Integer` als auch die generische <xref:System.Collections.Generic.ICollection%601> von <xref:System.String>implementiert) und keine Schnittstelle mit höherer Rangfolge gefunden wird, wird die Sammlung nicht als gültige Sammlung behandelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="cda19-336">Auf Sammlungstypen kann das <xref:System.SerializableAttribute> -Attribut angewendet sein, und sie können die <xref:System.Runtime.Serialization.ISerializable> -Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="cda19-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="cda19-337">Beide werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="cda19-337">Both of these are ignored.</span></span> <span data-ttu-id="cda19-338">Wenn jedoch der Typ die Sammlungstypanforderungen nicht vollständig erfüllt (z. B. wenn der Sammlungstyp und die `Add` -Methode fehlen), wird der Typ nicht als Sammlungstyp betrachtet. Daher werden das <xref:System.SerializableAttribute> -Attribut und die <xref:System.Runtime.Serialization.ISerializable> -Schnittstelle verwendet, um die Serialisierbarkeit des Typs zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="cda19-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="cda19-339">Durch Anwenden des <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attributs auf eine Sammlung, um diese anzupassen, wird der oben genannte <xref:System.SerializableAttribute> -Fallback-Mechanismus entfernt.</span><span class="sxs-lookup"><span data-stu-id="cda19-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="cda19-340">Stattdessen wird eine <xref:System.Runtime.Serialization.InvalidDataContractException> -Ausnahme ausgelöst, wenn eine benutzerdefinierte Sammlung keine Sammlungstypanforderungen erfüllt,.</span><span class="sxs-lookup"><span data-stu-id="cda19-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="cda19-341">Die Ausnahme Zeichenfolge enthält häufig Informationen, die erläutern, warum ein bestimmter Typ nicht als gültige Auflistung angesehen wird (keine `Add` Methode, kein Parameter loser Konstruktor usw.). Daher ist es häufig hilfreich, das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> Attribut zu Debuggingzwecken anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="cda19-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="cda19-342">Sammlungsbenennung</span><span class="sxs-lookup"><span data-stu-id="cda19-342">Collection Naming</span></span>

<span data-ttu-id="cda19-343">Im Folgenden finden Sie eine Liste von Regeln für die Sammlungsbenennung:</span><span class="sxs-lookup"><span data-stu-id="cda19-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="cda19-344">Der Standard Namespace für alle Datenverträge für Wörterbuch Sammlungen sowie für Datenverträge für Listen Sammlungen, die primitive Typen enthalten, ist, `http://schemas.microsoft.com/2003/10/Serialization/Arrays` Wenn nicht mithilfe von Namespace überschrieben.</span><span class="sxs-lookup"><span data-stu-id="cda19-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="cda19-345">Typen, die integrierten XSD-Typen zugeordnet werden, sowie `char`-, `Timespan`- und `Guid` -Typen, gelten zu diesem Zweck als primitive Typen.</span><span class="sxs-lookup"><span data-stu-id="cda19-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="cda19-346">Der Standardnamespace für Sammlungstypen, die nicht primitive Typen enthalten, ist der gleiche wie der Namespace für die Datenverträge des in der Sammlung enthaltenen Typs, sofern er nicht von "Namespace" überschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="cda19-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="cda19-347">Der Standardname für Datenverträge für Sammlungstypen ist die Zeichenfolge "ArrayOf" in Kombination mit dem Datenvertragsnamen des in der Sammlung enthaltenen Typs, sofern er nicht von "Name" überschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="cda19-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="cda19-348">Der Datenvertragsname einer generischen Liste von ganzen Zahlen lautet z. B. "ArrayOfint".</span><span class="sxs-lookup"><span data-stu-id="cda19-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="cda19-349">Beachten Sie, dass der Datenvertragsname von `Object` "anyType" lautet, sodass der Datenvertragsname für nicht generische Listen wie <xref:System.Collections.ArrayList> "ArrayOfanyType" lautet.</span><span class="sxs-lookup"><span data-stu-id="cda19-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="cda19-350">Der Standardname für Datenverträge für Wörterbuchsammlungen ist die Zeichenfolge "ArrayOfKeyValueOf" in Kombination mit dem Datenvertragsnamen für den Schlüsseltyp, gefolgt vom Datenvertragsnamen des Werttyps, sofern er nicht von `Name`überschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="cda19-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="cda19-351">Der Datenvertragsname für ein generisches Wörterbuch für Zeichenfolge und ganze Zahl lautet z. B. "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="cda19-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="cda19-352">Wenn darüber hinaus der Schlüssel- oder der Werttyp kein primitiver Typ ist, wird an den Namen ein Namespacehash der Datenvertragsnamespaces für den Schlüssel- und Werttyp angefügt.</span><span class="sxs-lookup"><span data-stu-id="cda19-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="cda19-353">Weitere Informationen zu Namespace-Hashes finden Sie unter [Daten Vertrags Namen](data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="cda19-353">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="cda19-354">Jeder Wörterbuchsammlungsdatenvertrag weist einen Begleitdatenvertrag auf, der einen Eintrag im Wörterbuch darstellt.</span><span class="sxs-lookup"><span data-stu-id="cda19-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="cda19-355">Der Name ist der gleiche wie der des Wörterbuchdatenvertrags, bis auf das Präfix "ArrayOf", und der Namespace ist ebenfalls der gleiche wie für den Wörterbuchdatenvertrag.</span><span class="sxs-lookup"><span data-stu-id="cda19-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="cda19-356">Beispielsweise kann für den "ArrayOfKeyValueOfstringint"-Wörterbuchdatenvertrag der "KeyValueofstringint"-Datenvertrag einen Eintrag im Wörterbuch darstellen.</span><span class="sxs-lookup"><span data-stu-id="cda19-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="cda19-357">Sie können den Namen dieses Datenvertrags individuell anpassen, indem Sie die `ItemName` -Eigenschaft verwenden, wie im nächsten Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="cda19-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="cda19-358">Benennungsregeln für generische Typen, wie unter [Data Contract Names](data-contract-names.md)beschrieben, gelten vollständig für Sammlungstypen, d. h. Sie können geschweifte Klammern innerhalb von "Name" verwenden, um generische Parametertypen anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="cda19-358">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="cda19-359">Die Zahlen innerhalb der Klammern verweisen jedoch auf generische Parameter und nicht auf Typen, die in der Sammlung enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="cda19-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="cda19-360">Sammlungsanpassung</span><span class="sxs-lookup"><span data-stu-id="cda19-360">Collection Customization</span></span>

<span data-ttu-id="cda19-361">Die folgenden Verwendungen des <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attributs sind unzulässig und führen zu einer <xref:System.Runtime.Serialization.InvalidDataContractException> -Ausnahme:</span><span class="sxs-lookup"><span data-stu-id="cda19-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="cda19-362">Das Anwenden des <xref:System.Runtime.Serialization.DataContractAttribute> -Attributs auf einen Typ, auf den das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut angewendet wurde, oder auf einen von diesem abgeleiteten Typ.</span><span class="sxs-lookup"><span data-stu-id="cda19-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="cda19-363">Das Anwenden des <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attributs auf einen Typ, der die <xref:System.Xml.Serialization.IXmlSerializable> -Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="cda19-364">Das Anwenden des <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attributs auf einen Typ, bei dem es sich nicht um einen Sammlungstyp handelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="cda19-365">Der Versuch, <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> oder <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> auf einem <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut festzulegen, das auf einen Typ angewendet wird, bei dem es sich nicht um einen Wörterbuchtyp handelt.</span><span class="sxs-lookup"><span data-stu-id="cda19-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="cda19-366">Polymorphieregeln</span><span class="sxs-lookup"><span data-stu-id="cda19-366">Polymorphism Rules</span></span>

<span data-ttu-id="cda19-367">Wie bereits erwähnt, behindert das Anpassen von Sammlungen mit dem <xref:System.Runtime.Serialization.CollectionDataContractAttribute> -Attribut möglicherweise die Austauschbarkeit der Sammlungen.</span><span class="sxs-lookup"><span data-stu-id="cda19-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="cda19-368">Zwei benutzerdefinierte Sammlungstypen gelten nur als gleich, wenn ihre Namen, ihr Namespace, ihr Elementname und ihre Schlüssel- und Wertnamen (sofern es sich um Wörterbuchsammlungen handelt) übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="cda19-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="cda19-369">Aufgrund der Anpassungen ist es möglich, einen Sammlungsdatenvertrag, wo noch ein weiterer erwartet wird, versehentlich zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="cda19-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="cda19-370">Dies sollte vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-370">This should be avoided.</span></span> <span data-ttu-id="cda19-371">Siehe folgende Typen:</span><span class="sxs-lookup"><span data-stu-id="cda19-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="cda19-372">In diesem Fall kann eine Instanz von `Marks1``testMarks`zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="cda19-373">`Marks2` sollte jedoch nicht verwendet werden: Der zugehörige Datenvertrag stimmt nicht mit dem `IList<int>` -Datenvertrag überein.</span><span class="sxs-lookup"><span data-stu-id="cda19-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="cda19-374">Der Name des Daten Vertrags lautet "Marks2" und nicht "ArrayOfint", und der Name des wiederholten Elements lautet " \<mark> " und nicht " \<int> ".</span><span class="sxs-lookup"><span data-stu-id="cda19-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="cda19-375">Die Regeln in der folgenden Tabelle gelten für die polymorphe Zuweisung von Sammlungen:</span><span class="sxs-lookup"><span data-stu-id="cda19-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="cda19-376">Deklarierter Typ</span><span class="sxs-lookup"><span data-stu-id="cda19-376">Declared type</span></span>|<span data-ttu-id="cda19-377">Zuweisen einer nicht benutzerdefinierten Sammlung</span><span class="sxs-lookup"><span data-stu-id="cda19-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="cda19-378">Zuweisen einer benutzerdefinierten Sammlung</span><span class="sxs-lookup"><span data-stu-id="cda19-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="cda19-379">Object</span><span class="sxs-lookup"><span data-stu-id="cda19-379">Object</span></span>|<span data-ttu-id="cda19-380">Vertragsname wird serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-380">Contract name is serialized.</span></span>|<span data-ttu-id="cda19-381">Vertragsname wird serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="cda19-382">Anpassung wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="cda19-382">Customization is used.</span></span>|
|<span data-ttu-id="cda19-383">Sammlungsschnittstelle</span><span class="sxs-lookup"><span data-stu-id="cda19-383">Collection interface</span></span>|<span data-ttu-id="cda19-384">Vertragsname wird nicht serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-384">Contract name is not serialized.</span></span>|<span data-ttu-id="cda19-385">Vertragsname wird nicht serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="cda19-386">Anpassung wird nicht verwendet.\*</span><span class="sxs-lookup"><span data-stu-id="cda19-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="cda19-387">Nicht benutzerdefinierte Sammlung</span><span class="sxs-lookup"><span data-stu-id="cda19-387">Non-customized collection</span></span>|<span data-ttu-id="cda19-388">Vertragsname wird nicht serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-388">Contract name is not serialized.</span></span>|<span data-ttu-id="cda19-389">Vertragsname wird serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="cda19-390">Anpassung wird verwendet.\*\*</span><span class="sxs-lookup"><span data-stu-id="cda19-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="cda19-391">Benutzerdefinierte Sammlung</span><span class="sxs-lookup"><span data-stu-id="cda19-391">Customized collection</span></span>|<span data-ttu-id="cda19-392">Vertragsname wird serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-392">Contract name is serialized.</span></span> <span data-ttu-id="cda19-393">Anpassung wird nicht verwendet.\*\*</span><span class="sxs-lookup"><span data-stu-id="cda19-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="cda19-394">Vertragsname wird serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="cda19-395">Die Anpassung des zugewiesenen Typs wird verwendet.\*\*</span><span class="sxs-lookup"><span data-stu-id="cda19-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="cda19-396">\*Mit der- <xref:System.Runtime.Serialization.NetDataContractSerializer> Klasse wird die Anpassung in diesem Fall verwendet.</span><span class="sxs-lookup"><span data-stu-id="cda19-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="cda19-397">Die <xref:System.Runtime.Serialization.NetDataContractSerializer> -Klasse serialisiert auch den tatsächlichen Typnamen in diesem Fall, sodass die Deserialisierung wie erwartet funktioniert.</span><span class="sxs-lookup"><span data-stu-id="cda19-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="cda19-398">\*\*Diese Fälle führen zu Schema ungültigen Instanzen und sollten daher vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="cda19-399">In Fällen, in denen der Vertragsname serialisiert wird, sollte die Liste der bekannten Typen den zugewiesenen Sammlungstyp enthalten.</span><span class="sxs-lookup"><span data-stu-id="cda19-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="cda19-400">Auch der entgegengesetzte Fall trifft zu: In Fällen, in denen der Name nicht serialisiert wird, muss der Typ nicht der Liste der bekannten Typen hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="cda19-401">Einem Array eines Basistyps kann ein Array eines abgeleiteten Typs zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="cda19-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="cda19-402">In diesem Fall wird der Vertragsname für den abgeleiteten Typ für jedes sich wiederholende Element serialisiert.</span><span class="sxs-lookup"><span data-stu-id="cda19-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="cda19-403">Wenn z. B. ein Typ `Book` vom Typ `LibraryItem`abgeleitet wurde, können Sie ein Array von `Book` einem Array von `LibraryItem`hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="cda19-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="cda19-404">Dies gilt nicht für andere Sammlungstypen.</span><span class="sxs-lookup"><span data-stu-id="cda19-404">This does not apply to other collection types.</span></span> <span data-ttu-id="cda19-405">Sie können z. B. eine `Generic List of Book` nicht einem `Generic List of LibraryItem`zuweisen.</span><span class="sxs-lookup"><span data-stu-id="cda19-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="cda19-406">Sie können aber ein `Generic List of LibraryItem` zuweisen, das `Book` -Instanzen enthält.</span><span class="sxs-lookup"><span data-stu-id="cda19-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="cda19-407">Sowohl im Fall mit Array als auch im Fall ohne Array sollte `Book` in der Liste der bekannten Typen enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="cda19-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="cda19-408">Sammlungen und Beibehaltung von Objektverweisen</span><span class="sxs-lookup"><span data-stu-id="cda19-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="cda19-409">Wenn ein Serialisierungsprogramm in einem Modus ausgeführt wird, in dem es Objektverweise beibehält, gilt die Beibehaltung der Objektverweise auch für Sammlungen.</span><span class="sxs-lookup"><span data-stu-id="cda19-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="cda19-410">Insbesondere wird Objektidentität sowohl für ganze Sammlungen als auch für einzelne Elemente beibehalten, die in Sammlungen enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="cda19-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="cda19-411">Für Wörterbücher wird Objektidentität sowohl für Schlüssel- und Wertepaarobjekte als auch für die einzelnen Schlüssel- und Werteobjekte beibehalten.</span><span class="sxs-lookup"><span data-stu-id="cda19-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="cda19-412">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="cda19-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
