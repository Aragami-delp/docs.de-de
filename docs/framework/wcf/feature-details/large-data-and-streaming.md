---
title: Umfangreiche Daten und Streaming
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 21993f230b19a76020807e1f17bd6256f2ee0b1c
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/09/2020
ms.locfileid: "84586324"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="c7917-102">Umfangreiche Daten und Streaming</span><span class="sxs-lookup"><span data-stu-id="c7917-102">Large Data and Streaming</span></span>

<span data-ttu-id="c7917-103">Windows Communication Foundation (WCF) ist eine XML-basierte Kommunikationsinfrastruktur.</span><span class="sxs-lookup"><span data-stu-id="c7917-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="c7917-104">Da XML-Daten in der Regel im Standardtext Format codiert sind, das in der [XML 1,0-Spezifikation](https://www.w3.org/TR/REC-xml/)definiert ist, haben Entwickler und Architekten von verbundenen Systemen in der Regel den Übertragungs Bedarf (oder die Größe) von Nachrichten, die über das Netzwerk gesendet werden, und die textbasierte Codierung von XML stellt besondere Herausforderungen für die effiziente Übertragung von Binärdaten dar.</span><span class="sxs-lookup"><span data-stu-id="c7917-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="c7917-105">Allgemeine Überlegungen</span><span class="sxs-lookup"><span data-stu-id="c7917-105">Basic Considerations</span></span>  
 <span data-ttu-id="c7917-106">Um Hintergrundinformationen zu den folgenden Informationen für WCF bereitzustellen, werden in diesem Abschnitt einige allgemeine Aspekte und Überlegungen zu Codierungen, Binärdaten und Streaming, die im Allgemeinen für verbundene System Infrastrukturen gelten, hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="c7917-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="c7917-107">Codieren von Daten: Text oder binär</span><span class="sxs-lookup"><span data-stu-id="c7917-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="c7917-108">Zu den verbreiteten Bedenken von Entwicklern gehört die Annahme, dass XML im Vergleich zu binären Formaten einen erheblichen Mehraufwand mit sich bringt, angesichts der sich wiederholenden Natur von Starttags und Endtags. Die Codierung numerische Werte scheint ihnen wesentlich umfangreicher, da diese Werte in Textwerten ausgedrückt werden, und sie fürchten, dass binäre Daten nicht effizient ausgedrückt werden, da sie speziell codiert werden müssen, um in ein Textformat eingebettet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="c7917-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="c7917-109">Zwar treffen diese und ähnliche Bedenken zu, doch ist der tatsächliche Unterschied zwischen XML-textcodierten Nachrichten in einer XML-Webdienstumgebung und binärcodierten Nachrichten in einer älteren RPC-Umgebung (Remote Procedure Call) häufig wesentlich geringer als auf den ersten Blick vermutet.</span><span class="sxs-lookup"><span data-stu-id="c7917-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="c7917-110">Während XML-textcodierte Nachrichten transparent und "lesbar" sind, sind binäre Nachrichten im Vergleich dazu häufig reichlich obskur und ohne Tools nur schwer zu decodieren.</span><span class="sxs-lookup"><span data-stu-id="c7917-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="c7917-111">Der Unterschied in der Lesbarkeit verschleiert leicht die Tatsache, dass auch binäre Nachrichten häufig Inline-Metadaten in der Nutzlast enthalten, was genau wie bei XML-Textnachrichten zu Mehraufwand führt.</span><span class="sxs-lookup"><span data-stu-id="c7917-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="c7917-112">Das trifft besonders auf binäre Formate zu, die Funktionen für lose Verknüpfungen und dynamische Aufrufe bieten sollen.</span><span class="sxs-lookup"><span data-stu-id="c7917-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="c7917-113">Binäre Formate führen in der Regel solche beschreibenden Metadateninformationen in einem "Header", in dem auch das Datenlayout für die folgenden Datensätze deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="c7917-114">Dieser allgemeinen Metadatenblockdeklaration folgt in der Regel die Nutzlast mit nur minimalem weiteren Mehraufwand.</span><span class="sxs-lookup"><span data-stu-id="c7917-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="c7917-115">Im Gegensatz dazu schließt XML jedes Datenelement in ein Element oder Attribut ein, sodass das Einschließen von Metadaten für jedes serialisierte Nutzlastobjekt wiederholt erfolgt.</span><span class="sxs-lookup"><span data-stu-id="c7917-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="c7917-116">Letztendlich ist die Größe eines einzelnen serialisierten Nutzlastobjekts bei einem Vergleich zwischen Text- und Binärdarstellungen ähnlich, da einige beschreibende Metadaten bei beidem ausgedrückt werden müssen. Das binäre Format profitiert jedoch von der gemeinsame Metadatenbeschreibung bei jedem zusätzlichen Nutzlastobjekt, das übertragen wird, aufgrund der des niedrigeren Gesamtaufwands.</span><span class="sxs-lookup"><span data-stu-id="c7917-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="c7917-117">Bei bestimmten Datentypen, wie z. B. Zahlen, kann die Verwendung binärer numerischer Darstellungen fester Größe, wie ein dezimaler 128-Bit-Typ anstelle von Nur-Text, allerdings ein gewisser Nachteil sein, da die Nur-Text-Darstellung einige Byte kleiner sein kann.</span><span class="sxs-lookup"><span data-stu-id="c7917-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="c7917-118">Die normalerweise flexiblerern Optionen zur XML-Textcodierung können Textdaten auch Größenvorteile bescheren, während einige binäre Formate vielleicht standardmäßig das 16-Bit- oder sogar 32-Bit-Unicode-Format verwenden, was auf das .NET Binary XML-Format nicht zutrifft.</span><span class="sxs-lookup"><span data-stu-id="c7917-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="c7917-119">Somit ist die Entscheidung zwischen Text- oder Binärformat nicht ganz so einfach wie die Annahme, dass binäre Nachrichten immer kleiner sind als XML-Textnachrichten.</span><span class="sxs-lookup"><span data-stu-id="c7917-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="c7917-120">Ein eindeutiger Vorteil von XML-Textnachrichten besteht jedoch darin, dass sie auf Standards basieren und eine breite Palette an Interoperabilitätsoptionen und Plattformunterstützung bieten.</span><span class="sxs-lookup"><span data-stu-id="c7917-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="c7917-121">Weitere Informationen finden Sie im Abschnitt "Codierungen" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="c7917-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="c7917-122">Binärer Inhalt</span><span class="sxs-lookup"><span data-stu-id="c7917-122">Binary Content</span></span>  
 <span data-ttu-id="c7917-123">Es gibt einen Bereich, in dem binäre Codierungen textbasierten Codierungen in Hinblick auf die resultierende Nachrichtengröße überlegen sind, und zwar bei großen binären Datenelementen. Dazu gehören Bilder, Videos, Soundclips und jede sonstige Form von nicht transparenten, binären Daten, die zwischen einem Dienst und seinem Consumer ausgetauscht werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="c7917-124">Damit diese Typen in XML-Text passen, werden sie in der Regel mit Base64 codiert.</span><span class="sxs-lookup"><span data-stu-id="c7917-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="c7917-125">In einer Base64-codierten Zeichenfolge stellt jedes Zeichen 6 Bits der ursprünglichen 8-Bit-Daten dar. Das ergibt ein Codierung-Mehraufwand-Verhältnis von 4:3 für Base64, wobei üblicherweise bei der Konvertierung hinzugefügte zusätzliche Formatierungszeichen (Wagenrücklauf/Zeilenvorschub) nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="c7917-126">Während die Bedeutung der Unterschiede zwischen XML und binären Codierungen normalerweise vom Szenario abhängen, ist die Größenzunahme von über 33&#160;% beim Übertragen einer 500-MB-Nutzlast in der Regel nicht akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="c7917-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="c7917-127">Um diesen Codierungsaufwand zu verhindern, ermöglicht der MTOM-Standard (Message Transmission Optimization Mechanism) eine Externalisierung großer Datenelement, die in einer Nachrichten enthalten sind. Dabei können die Elemente als Binärdaten ohne spezielle Codierung mit der Nachricht gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="c7917-128">Mit MTOM werden Nachrichten auf ähnliche Weise wie Simple Mail Transfer Protocol (SMTP)-e-Mail-Nachrichten mit Anlagen oder eingebettetem Inhalt (Bilder und anderer eingebetteter Inhalt) ausgetauscht. MTOM-Nachrichten werden als mehrteilige/zugehörige MIME-Sequenzen verpackt, wobei der Stammteil die tatsächliche SOAP-Nachricht ist.</span><span class="sxs-lookup"><span data-stu-id="c7917-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="c7917-129">Eine MTOM-SOAP-Nachricht wird in ihrer uncodierten Version geändert. Dabei ersetzen spezielle Elementtags, die sich auf die jeweiligen MIME-Teile beziehen, die ursprünglichen Elemente in der Nachricht, die binäre Daten enthielten.</span><span class="sxs-lookup"><span data-stu-id="c7917-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="c7917-130">Als Ergebnis bezieht sich die SOAP-Nachricht auf binären Inhalt, indem auf die mit ihr gesendeten MIME-Teile verwiesen wird, ansonsten jedoch nur XML-Textdaten enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="c7917-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="c7917-131">Da dieses Model eng an das weit verbreiteten SMTP-Modell anlehnt, gibt es ein breites Angebot an Tools zur Codierung und Decodierung von MTOM-Nachrichten für viele Pattformen, was eine hohe Interoperabilität gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="c7917-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="c7917-132">Doch wie bei Base64 ist auch bei MTOM ein gewisser Mehraufwand für das MIME-Format erforderlich, sodass sich die Vorteile von MTOM nur dann bemerkbar machen, wenn die Größe eines binären Datenelements ungefähr 1 KB überschreitet.</span><span class="sxs-lookup"><span data-stu-id="c7917-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="c7917-133">Aufgrund dieses Mehraufwands sind MTOM-codierte Nachrichten möglicherweise größer als Nachrichten, die eine Base64-Codierung für binäre Daten verwenden, wenn die binäre Nutzlast diese Schwelle nicht überschreitet.</span><span class="sxs-lookup"><span data-stu-id="c7917-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="c7917-134">Weitere Informationen finden Sie im Abschnitt "Codierungen" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="c7917-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="c7917-135">Inhalte mit umfangreichen Daten</span><span class="sxs-lookup"><span data-stu-id="c7917-135">Large Data Content</span></span>  
 <span data-ttu-id="c7917-136">Abgesehen von der Übertragungsgröße stellt die oben erwähnte 500-MB-Nutzlast für den Dienst und den Client auch lokal ein nicht unerhebliches Problem dar.</span><span class="sxs-lookup"><span data-stu-id="c7917-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="c7917-137">Standardmäßig verarbeitet WCF Nachrichten im *Puffer Modus*.</span><span class="sxs-lookup"><span data-stu-id="c7917-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="c7917-138">Dabei befindet sich der gesamte Inhalt vor dem Senden oder nach dem Empfang im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="c7917-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="c7917-139">In den meisten Szenarien ist das zwar eine gute Strategie, und für Messagingfunktionen wie digitale Signaturen sowie für eine zuverlässige Zustellung ist das sogar eine Notwendigkeit, doch bei großen Nachrichten erschöpfen sich dadurch leicht die Systemressourcen.</span><span class="sxs-lookup"><span data-stu-id="c7917-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="c7917-140">Die bei großen Nutzlasten einzuschlagende Strategie ist Streaming.</span><span class="sxs-lookup"><span data-stu-id="c7917-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="c7917-141">Obwohl Nachrichten, insbesondere in XML ausgedrückt, allgemein als relativ kompakte Datenpakete angesehen werden, kann eine Nachricht mehrere Gigabyte groß sein und eher einem durchgehenden Datenstrom ähneln statt einem Datenpaket.</span><span class="sxs-lookup"><span data-stu-id="c7917-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="c7917-142">Wenn Daten im Streamingmodus anstatt im Puffermodus übertragen werden, macht der Absender den Inhalt des Nachrichtentextes in der Form eines Streams für den Empfänger verfügbar. Dabei leitet die Nachrichteninfrastruktur die Daten fortlaufend vom Absender an den Empfänger weiter.</span><span class="sxs-lookup"><span data-stu-id="c7917-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="c7917-143">Das häufigste Szenario, bei dem Inhalte mit umfangreichen Daten übertragen werden, sind Übertragungen von binären Datenobjekten, die folgende Merkmale aufweisen:</span><span class="sxs-lookup"><span data-stu-id="c7917-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="c7917-144">Die Objekte können nur schwer in eine Nachrichtensequenz unterteilt werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-144">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="c7917-145">Die Zustellung muss schnell erfolgen.</span><span class="sxs-lookup"><span data-stu-id="c7917-145">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="c7917-146">Die Objekte sind noch nicht vollständig verfügbar, wenn die Übertragung beginnt.</span><span class="sxs-lookup"><span data-stu-id="c7917-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="c7917-147">Bei Daten, die diesen Einschränkungen nicht unterliegen, ist es in der Regel besser, anstatt einer großen Nachricht Sequenzen der Nachrichten im Rahmen einer Sitzung zu senden.</span><span class="sxs-lookup"><span data-stu-id="c7917-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="c7917-148">Weitere Informationen finden Sie im Abschnitt "Streaming von Daten" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="c7917-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="c7917-149">Wenn Sie große Datenmengen senden, müssen Sie die `maxAllowedContentLength` IIS-Einstellung (Weitere Informationen finden Sie unter [Konfigurieren von IIS-Anforderungs Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) und die `maxReceivedMessageSize` Bindungseinstellung (z. b. [System. Service Model. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) oder <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> ) festlegen.</span><span class="sxs-lookup"><span data-stu-id="c7917-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="c7917-150">Die `maxAllowedContentLength` -Eigenschaft ist standardmäßig auf 28,6 MB und die- `maxReceivedMessageSize` Eigenschaft standardmäßig auf 64 KB eingestellt.</span><span class="sxs-lookup"><span data-stu-id="c7917-150">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="c7917-151">Codierungen</span><span class="sxs-lookup"><span data-stu-id="c7917-151">Encodings</span></span>  
 <span data-ttu-id="c7917-152">Eine *Codierung* definiert einen Satz von Regeln für die Darstellung von Nachrichten im Netzwerk.</span><span class="sxs-lookup"><span data-stu-id="c7917-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="c7917-153">Ein *Encoder* implementiert eine solche Codierung und ist auf der Absender Seite dafür verantwortlich, dass ein in-Memory-Objekt in <xref:System.ServiceModel.Channels.Message> einen Bytestream oder Byte Puffer verwandelt wird, der über das Netzwerk gesendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c7917-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="c7917-154">Auf der Empfängerseite wandelt der Encoder die Bytesequenz wieder in eine Nachricht im Arbeitsspeicher um.</span><span class="sxs-lookup"><span data-stu-id="c7917-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="c7917-155">WCF enthält drei Encoder und ermöglicht das Schreiben und Einbinden Ihrer eigenen Encoder, falls erforderlich.</span><span class="sxs-lookup"><span data-stu-id="c7917-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="c7917-156">Jede der Standardbindungen schließt einen vorkonfigurierten Encoder ein. Dabei verwenden standardmäßig die Bindungen mit dem Präfix Net\* den binären Encoder (indem die <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>-Klasse eingeschlossen wird), und die Klassen <xref:System.ServiceModel.BasicHttpBinding> und <xref:System.ServiceModel.WSHttpBinding> verwenden den Textnachrichtenencoder (anhand der <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>-Klasse).</span><span class="sxs-lookup"><span data-stu-id="c7917-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="c7917-157">Bindungselement des Encoders</span><span class="sxs-lookup"><span data-stu-id="c7917-157">Encoder binding element</span></span>|<span data-ttu-id="c7917-158">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="c7917-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="c7917-159">Der Textnachrichtencoder ist der Standardencoder für alle HTTP-basierten Bindungen. Er empfiehlt sich für alle benutzerdefinierten Bindungen, bei denen besonders auf Interoperabilität Wert gelegt wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="c7917-160">Dieser Encoder liest und schreibt auf SOAP 1.1/SOAP 1.2 basierende Standardtextnachrichten ohne spezielle Behandlung von binären Daten.</span><span class="sxs-lookup"><span data-stu-id="c7917-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="c7917-161">Wenn die- <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> Eigenschaft einer Nachricht auf festgelegt ist <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType> , wird der SOAP-Umschlag Wrapper in der Ausgabe weggelassen, und nur der Nachrichtentext Inhalt wird serialisiert.</span><span class="sxs-lookup"><span data-stu-id="c7917-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="c7917-162">Der MTOM-Nachrichtenencoder ist ein Textencoder, der eine spezielle Behandlung binärer Daten implementiert und nicht standardmäßig in den Standardbindungen verwendet wird, da es sich um ein extrem fallabhängiges Hilfsprogramm für Optimierungen handelt.</span><span class="sxs-lookup"><span data-stu-id="c7917-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="c7917-163">Wenn die Nachricht binäre Daten enthält, die einen Schwellenwert überschreiten, nach dem die MTOM-Codierung vorteilhafter ist, werden die Daten in einen MIME-Teil externalisiert, der auf den Nachrichtenumschlag folgt.</span><span class="sxs-lookup"><span data-stu-id="c7917-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="c7917-164">Siehe "Aktivieren von MTOM" weiten unten in diesem Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="c7917-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="c7917-165">Der binäre Nachrichten Encoder ist der Standard Encoder für die Net \*-Bindungen und die geeignete Wahl, wenn beide Kommunikationspartner auf WCF basieren.</span><span class="sxs-lookup"><span data-stu-id="c7917-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="c7917-166">Der binäre Nachrichtenencoder verwendet das .NET Binary XML-Format. Dieses Format ist eine spezielle Binärdarstellung für XML-Informationssets (Infosets) von Microsoft, die in der Regel kompakter ist als die entsprechende XML 1.0-Darstellung und binäre Daten als Bytestream codiert.</span><span class="sxs-lookup"><span data-stu-id="c7917-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="c7917-167">Die Textnachrichtencodierung empfiehlt sich in der Regel für Kommunikationspfade, die Interoperabilität erfordern, während die binäre Nachrichtencodierung für jeden anderen Kommunikationspfad die optimale Lösung ist.</span><span class="sxs-lookup"><span data-stu-id="c7917-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="c7917-168">Die binäre Nachrichtencodierung führt im Vergleich zu Text bei einzelnen Nachrichten meist zu einer geringeren Größe und progressiv im Verlauf einer Kommunikationssitzung sogar zu noch kleineren Nachrichten.</span><span class="sxs-lookup"><span data-stu-id="c7917-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="c7917-169">Im Unterschied zur Textcodierung gibt es bei der binären Codierung keine spezielle Behandlung von binären Daten, wie die Verwendung von Base64, sondern Bytes werden als Bytes dargestellt.</span><span class="sxs-lookup"><span data-stu-id="c7917-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="c7917-170">Wenn Sie für Ihre Lösung keine Interoperabilität benötigen, aber trotzdem den HTTP-Transport verwenden möchten, machen Sie <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> zu einer benutzerdefinierten Bindung, die die <xref:System.ServiceModel.Channels.HttpTransportBindingElement>-Klasse für den Transport verwendet.</span><span class="sxs-lookup"><span data-stu-id="c7917-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="c7917-171">Wenn verschiedene Clients Ihres Dienstes Interoperabilität benötigen, sollten Sie parallele Endpunkte verfügbar machen, bei denen jeweils die geeigneten Transport- und Codieroptionen für den entsprechenden Client aktiviert sind.</span><span class="sxs-lookup"><span data-stu-id="c7917-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="c7917-172">Aktivieren von MTOM</span><span class="sxs-lookup"><span data-stu-id="c7917-172">Enabling MTOM</span></span>  
 <span data-ttu-id="c7917-173">Wenn Interoperabilität erforderlich ist und umfangreiche binäre Daten gesendet werden müssen, stellt die MTOM-Nachrichtencodierung die alternative Codierungsstrategie dar, die Sie für die Standardbindungen <xref:System.ServiceModel.BasicHttpBinding> oder <xref:System.ServiceModel.WSHttpBinding> aktivieren können. Legen Sie dazu die jeweilige `MessageEncoding`-Eigenschaft auf <xref:System.ServiceModel.WSMessageEncoding.Mtom> fest, oder machen Sie <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> zu einer <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="c7917-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="c7917-174">Der folgende Beispielcode, der aus dem [MTOM-Codierungs](../samples/mtom-encoding.md) Beispiel extrahiert wurde, veranschaulicht, wie MTOM in der Konfiguration aktiviert wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-174">The following example code, extracted from the [MTOM Encoding](../samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="c7917-175">Wie bereits erwähnt, hängt die Entscheidung für die MTOM-Codierung vom zu sendenden Datenvolumen ab.</span><span class="sxs-lookup"><span data-stu-id="c7917-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="c7917-176">Da MTOM auf der Bindungsebene aktiviert wird, wirkt sich diese Codierung auf alle Vorgänge eines bestimmten Endpunkts aus.</span><span class="sxs-lookup"><span data-stu-id="c7917-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="c7917-177">Der MTOM-Encoder gibt unabhängig davon, ob binäre Daten letztendlich externalisiert werden, immer MTOM-codierte MIME-Multipart-Nachrichten aus. Aktivieren Sie deshalb MTOM nur für Endpunkte, die Nachrichten mit über 1&#160;KB binärer Daten austauschen.</span><span class="sxs-lookup"><span data-stu-id="c7917-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="c7917-178">Außerdem sollten die Dienstverträge, die für die Verwendung mit für MTOM aktivierten Endpunkten möglichst darauf beschränkt sein, dass sie nur Vorgänge zu solchen Datenübertragungen angeben.</span><span class="sxs-lookup"><span data-stu-id="c7917-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="c7917-179">Die zugehörigen Steuerungsfunktionen sollten sich in einem gesonderten Vertrag befinden.</span><span class="sxs-lookup"><span data-stu-id="c7917-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="c7917-180">Diese "Nur-MTOM"-Regel gilt nur für Nachrichten, die über einen für MTOM aktivierten Endpunkt gesendet werden. Der MTOM-Encoder kann auch eingehende Nachrichten decodieren und analysieren, die nicht auf MTOM basieren.</span><span class="sxs-lookup"><span data-stu-id="c7917-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="c7917-181">Die Verwendung des MTOM-Encoders entspricht allen anderen WCF-Features.</span><span class="sxs-lookup"><span data-stu-id="c7917-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="c7917-182">Beachten Sie jedoch, dass diese Regel nicht in allen Fällen gelten kann, wie z. B. bei einer erforderlichen Sitzungsunterstützung.</span><span class="sxs-lookup"><span data-stu-id="c7917-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="c7917-183">Programmiermodell</span><span class="sxs-lookup"><span data-stu-id="c7917-183">Programming Model</span></span>  
 <span data-ttu-id="c7917-184">Unabhängig davon, welchen der drei integrierten Encoder Sie in Ihrer Anwendung verwenden, erfolgt die Programmierung zur Übertragung binärer Daten in allen Fällen auf die gleiche Weise.</span><span class="sxs-lookup"><span data-stu-id="c7917-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="c7917-185">Der Unterschied besteht darin, wie WCF die Daten auf Grundlage ihrer Datentypen verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="c7917-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="c7917-186">Bei der Verwendung von MTOM wird der vorausgehende Datenvertrag nach den folgenden Regeln serialisiert:</span><span class="sxs-lookup"><span data-stu-id="c7917-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="c7917-187">Wenn `binaryBuffer` nicht `null` ist und im Einzelfall genügend Daten enthält, um den MTOM-Externalisierungsmehraufwand (MIME-Header usw.) im Vergleich zur Base64-Codierung zu rechtfertigen, werden die Daten externalisiert und als binärer MIME-Teil mit der Nachricht gesendet.</span><span class="sxs-lookup"><span data-stu-id="c7917-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="c7917-188">Wird der Schwellenwert nicht überschritten, werden die Daten als Base64 codiert.</span><span class="sxs-lookup"><span data-stu-id="c7917-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="c7917-189">Die Zeichenfolge (und alle anderen nicht binären Typen) wird unabhängig von der Größe immer als Zeichenfolge innerhalb des Nachrichtentextes dargestellt.</span><span class="sxs-lookup"><span data-stu-id="c7917-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="c7917-190">Die Auswirkungen auf die MTOM-Codierung bleiben gleich, unabhängig davon, ob Sie einen expliziten Datenvertrag wie im vorherigen Beispiel, eine Parameterliste in einem Vorgang oder geschachtelte Datenverträge verwenden oder ob Sie Datenvertragsobjekte innerhalb einer Auflistung übertragen.</span><span class="sxs-lookup"><span data-stu-id="c7917-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="c7917-191">Bytearrays eignen sich immer für eine Optimierung und werden optimiert, wenn die Optimierungsschwellenwerte erreicht sind.</span><span class="sxs-lookup"><span data-stu-id="c7917-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c7917-192">Verwenden Sie keine von <xref:System.IO.Stream?displayProperty=nameWithType> abgeleiteten Typen in Datenverträgen.</span><span class="sxs-lookup"><span data-stu-id="c7917-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="c7917-193">Streamdaten sollten nach einem Streamingmodell übermittelt werden, wie im folgenden Abschnitt "Streaming von Daten" erläutert wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="c7917-194">Streaming von Daten</span><span class="sxs-lookup"><span data-stu-id="c7917-194">Streaming Data</span></span>  
 <span data-ttu-id="c7917-195">Wenn Sie über eine große Datenmenge verfügen, ist der Streamingübertragungsmodus in WCF eine mögliche Alternative zum Standardverhalten, bei dem Nachrichten im Arbeitsspeicher vollständig gepuffert und verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="c7917-196">Aktivieren Sie bei großen Nachrichten (mit Text oder binärem Inhalt) die Streamingfunktion, wenn die Daten nicht segmentiert werden können, schnell zugestellt werden müssen oder wenn die Daten beim Beginn der Übertragung noch nicht vollständig verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="c7917-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="c7917-197">Beschränkungen</span><span class="sxs-lookup"><span data-stu-id="c7917-197">Restrictions</span></span>  
 <span data-ttu-id="c7917-198">Wenn Streaming aktiviert ist, ist es nicht möglich, eine große Anzahl von WCF-Funktionen zu verwenden:</span><span class="sxs-lookup"><span data-stu-id="c7917-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="c7917-199">Digitale Signaturen für den Nachrichtentext sind nicht möglich, da sie Berechnungen oder einen Hash zum gesamten Nachrichteninhalt erfordern.</span><span class="sxs-lookup"><span data-stu-id="c7917-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="c7917-200">Beim Streaming ist der Inhalt nicht vollständig verfügbar, wenn die Nachrichtenheader erstellt und gesendet werden, weshalb keine digitale Signatur berechnet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c7917-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="c7917-201">Die Verschlüsselung hängt von digitalen Signaturen ab, mit denen überprüft wird, ob die Daten ordnungsgemäß rekonstruiert wurden.</span><span class="sxs-lookup"><span data-stu-id="c7917-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="c7917-202">Zuverlässige Sitzungen müssen gesendete Nachrichten für den Client puffen, damit bei der Übertragung verlorgen gegangene Nachrichten neu gesendet werden können. Außerdem müssen sie Nachrichten vor einer Weitergabe an die Dienstimplementierung für den Dienst zurückhalten, um die richtige Nachrichtenfolge beizubehalten, falls Nachrichten nicht in der richtigen Folge eingehen.</span><span class="sxs-lookup"><span data-stu-id="c7917-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="c7917-203">Wegen dieser funktionalen Einschränkungen können Sie nur Sicherheitsoptionen auf Transportebene für das Streaming verwenden. Zuverlässige Sitzungen können nicht bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="c7917-204">Das Streaming ist nur mit den folgenden vom System definierten Bindungen verfügbar:</span><span class="sxs-lookup"><span data-stu-id="c7917-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="c7917-205">Da die zugrunde liegenden Transporte von <xref:System.ServiceModel.NetTcpBinding> und <xref:System.ServiceModel.NetNamedPipeBinding> im Unterschied zu HTTP naturgemäß eine zuverlässige Zustellung und verbindungsbasierte Sitzungsunterstützung aufweisen, sind diese Bindungen in der Praxis nur minimal von diesen Einschränkungen betroffen.</span><span class="sxs-lookup"><span data-stu-id="c7917-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="c7917-206">Streaming ist für den MSMQ-Transport (Message Queuing) nicht verfügbar und kann deshalb nicht mit der <xref:System.ServiceModel.NetMsmqBinding>- oder der <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>-Klasse verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="c7917-207">Der MSMQ-Transport unterstützt nur gepufferte Datenübertragungen mit einer eingeschränkten Nachrichtengröße. Alle anderen Transporte unterliegen in den meisten Szenarien jedoch keiner speziellen Einschränkung hinsichtlich der Nachrichtengröße.</span><span class="sxs-lookup"><span data-stu-id="c7917-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="c7917-208">Streaming ist auch beim Peerkanaltransport nicht verfügbar und kann deshalb nicht mit <xref:System.ServiceModel.NetPeerTcpBinding> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="c7917-209">Streaming und Sitzungen</span><span class="sxs-lookup"><span data-stu-id="c7917-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="c7917-210">Möglicherweise tritt beim Streaming von Aufrufen mit einer sitzungsbasierten Bindung ein unerwartetes Verhalten auf.</span><span class="sxs-lookup"><span data-stu-id="c7917-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="c7917-211">Alle Streamingaufrufe erfolgen über einen einzigen Kanal (den Datagrammkanal), der keine Sitzungen unterstützt, selbst wenn die verwendete Bindung für die Verwendung von Sitzungen konfiguriert ist.</span><span class="sxs-lookup"><span data-stu-id="c7917-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="c7917-212">Wenn mehrere Clients Streamingaufrufe an dasselbe Dienstobjekt über eine sitzungsbasierte Bindung durchführen und der Parallelitätsmodus des Dienstobjekts auf „single“ und sein Instanzkontextmodus auf „PerSession“ festgelegt ist, müssen alle Aufrufe den Datagrammkanal passieren, sodass immer nur jeweils ein Aufruf verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="c7917-213">Für mindestens einen Client kann ein Timeout auftreten. Sie können dieses Problem umgehen, indem Sie entweder den Instanzkontextmodus des Dienst Objekts auf "Recall" oder "Parallelität" auf "Multiple" festlegen.</span><span class="sxs-lookup"><span data-stu-id="c7917-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c7917-214">MaxConcurrentSessions hat in diesem Fall keine Auswirkungen, da nur eine "Sitzung" verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="c7917-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="c7917-215">Aktivieren des Streaming</span><span class="sxs-lookup"><span data-stu-id="c7917-215">Enabling Streaming</span></span>  
 <span data-ttu-id="c7917-216">Das Streaming kann in folgender Weise aktiviert werden:</span><span class="sxs-lookup"><span data-stu-id="c7917-216">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="c7917-217">Anforderungen werden im Streamingmodus gesendet und akzeptiert, und Antworten werden im Puffermodus akzeptiert und zurückgegeben (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="c7917-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="c7917-218">Anforderungen werden im Puffermodus gesendet und akzeptiert, und Antworten werden im Streamingmodus akzeptiert und zurückgegeben (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="c7917-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="c7917-219">Anforderungen und Antworten werden in beiden Richtungen im Streamingmodus gesendet und empfangen.</span><span class="sxs-lookup"><span data-stu-id="c7917-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="c7917-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="c7917-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="c7917-221">Sie können das Streaming deaktivieren, indem Sie den Übertragungsmodus auf <xref:System.ServiceModel.TransferMode.Buffered>, die Standardeinstellungen für alle Bindungen, festlegen.</span><span class="sxs-lookup"><span data-stu-id="c7917-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="c7917-222">Im folgenden Codebeispiel wird veranschaulicht, wie der Übertragungsmodus in der Konfiguration festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
</system.serviceModel>  
```  
  
 <span data-ttu-id="c7917-223">Wenn Sie eine Bindung im Code instanziieren, müssen Sie die jeweilige `TransferMode`-Eigenschaft der Bindung (oder das Transportbindungselement, wenn Sie eine benutzerdefinierte Bindung erstellen) auf einen der oben erwähnten Werte festlegen.</span><span class="sxs-lookup"><span data-stu-id="c7917-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="c7917-224">Sie können Streaming ohne Funktionseinschränkung für Anforderungen und Antworten, oder für beide Richtungen unabhängig, auf jeder Seite der Kommunikation aktivieren.</span><span class="sxs-lookup"><span data-stu-id="c7917-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="c7917-225">Gehen Sie jedoch immer davon aus, dass die übertragene Datenmenge groß genug ist, um eine Aktivierung des Streaming für beide Endpunkte einer Kommunikationsverbindung zu rechtfertigen.</span><span class="sxs-lookup"><span data-stu-id="c7917-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="c7917-226">Für die plattformübergreifende Kommunikation, bei der einer der Endpunkte nicht mit WCF implementiert ist, hängt die Möglichkeit der Verwendung von Streaming von den Streamingfunktionen der Plattform ab.</span><span class="sxs-lookup"><span data-stu-id="c7917-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="c7917-227">Eine weitere seltene Ausnahme kann eine Szenario sein, das auf dem Arbeitsspeicherverbrauch basiert, wobei der Client oder Dienst die Arbeitsseiten minimieren muss und nur geringe Puffergrößen möglich sind.</span><span class="sxs-lookup"><span data-stu-id="c7917-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="c7917-228">Aktivieren von asynchronem Streaming</span><span class="sxs-lookup"><span data-stu-id="c7917-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="c7917-229">Um das asynchrone Streaming zu aktivieren, fügen Sie dem Diensthost das <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior>-Endpunktverhalten hinzu und legen dessen <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A>-Eigenschaft auf `true` fest.</span><span class="sxs-lookup"><span data-stu-id="c7917-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="c7917-230">Die Funktion für echtes asynchrones Streaming auf der Senderseite wurde ebenfalls hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="c7917-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="c7917-231">Dies verbessert die Skalierbarkeit des Diensts in Szenarien, in denen Nachrichten an mehrere Clients gestreamt werden, von denen einige eine langsame Lesegeschwindigkeit haben, möglicherweise aufgrund von Netzwerküberlastung, oder überhaupt nicht lesen.</span><span class="sxs-lookup"><span data-stu-id="c7917-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="c7917-232">In diesen Szenarien werden nicht einzelne Threads für den Dienst pro Client blockiert.</span><span class="sxs-lookup"><span data-stu-id="c7917-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="c7917-233">Dadurch wird sichergestellt, dass der Dienst in der Lage ist, viel mehr Clients zu verarbeiten und somit die Skalierbarkeit des Diensts zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="c7917-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="c7917-234">Programmiermodell für Streamingübertragungen</span><span class="sxs-lookup"><span data-stu-id="c7917-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="c7917-235">Das Programmiermodell für Streaming ist unkompliziert.</span><span class="sxs-lookup"><span data-stu-id="c7917-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="c7917-236">Geben Sie für eingehende Streamingdaten einen Vorgangsvertrag mit einem einzelnen Eingabeparameter vom Typ <xref:System.IO.Stream> an.</span><span class="sxs-lookup"><span data-stu-id="c7917-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="c7917-237">Geben Sie für zurückgehende Streamingdaten einen <xref:System.IO.Stream>-Verweis an.</span><span class="sxs-lookup"><span data-stu-id="c7917-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="c7917-238">Im Vorgang `Echo` im obigen Beispiel wird ein Stream empfangen und zurückgegeben und sollte deshalb für eine Bindung mit <xref:System.ServiceModel.TransferMode.Streamed> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="c7917-239">Für den Vorgang `RequestInfo` eignet sich <xref:System.ServiceModel.TransferMode.StreamedResponse> am besten, da nur <xref:System.IO.Stream> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="c7917-240">Der unidirektionale Vorgang eignet sich für <xref:System.ServiceModel.TransferMode.StreamedRequest> am besten.</span><span class="sxs-lookup"><span data-stu-id="c7917-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="c7917-241">Wenn Sie den folgenden `Echo`- oder `ProvideInfo`-Vorgängen einen zweiten Parameter hinzufügen, wird das Dienstmodell auf eine Pufferstrategie zurückgesetzt und verwendet die Laufzeitserialisierungsdarstellung des Streams.</span><span class="sxs-lookup"><span data-stu-id="c7917-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="c7917-242">Nur Vorgänge mit einem Eingabestreamparameter sind mit einem End-to-End-Anforderungsstreaming kompatibel.</span><span class="sxs-lookup"><span data-stu-id="c7917-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="c7917-243">Diese Regel gilt in ähnlicher Weise für Nachrichtenverträge.</span><span class="sxs-lookup"><span data-stu-id="c7917-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="c7917-244">Wie im folgenden Nachrichtenvertrag dargestellt, kann der Nachrichtenvertrag nur einen einzigen Textmember enthalten, der ein Stream ist.</span><span class="sxs-lookup"><span data-stu-id="c7917-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="c7917-245">Wenn Sie zusätzliche Informationen mit dem Stream übermitteln möchten, müssen diese Informationen in Nachrichtenheadern übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="c7917-246">Der Nachrichtentext ist ausschließlich für Streaminginhalt reserviert.</span><span class="sxs-lookup"><span data-stu-id="c7917-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="c7917-247">Streamingübertragungen sind beendet und die Nachricht wird geschlossen, wenn der Stream das Ende der Datei (End of File, EOF) erreicht.</span><span class="sxs-lookup"><span data-stu-id="c7917-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="c7917-248">Wenn Sie eine Nachricht senden (einen Wert zurückgeben oder einen Vorgang aufrufen), können Sie übergeben, <xref:System.IO.FileStream> und die WCF-Infrastruktur ruft anschließend alle Daten aus diesem Stream ab, bis der Stream vollständig gelesen und mit EOF erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="c7917-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="c7917-249">Um Streamingdaten für die Quelle zu übertragen, die über keine integrierte, von <xref:System.IO.Stream> abgeleitete Klasse dieser Art verfügt, erstellen sie eine solche Klasse, überlagern Sie die Streamquelle mit dieser Klasse, und verwenden Sie das als Argument oder Rückgabewert.</span><span class="sxs-lookup"><span data-stu-id="c7917-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="c7917-250">Beim Empfang einer Nachricht erstellt WCF einen Stream über den Base64-codierten Nachrichtentext Inhalt (oder den entsprechenden MIME-Teil, wenn MTOM verwendet wird), und der Stream erreicht EOF, wenn der Inhalt gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="c7917-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="c7917-251">Streaming auf Transportebene funktioniert auch mit jedem anderen Nachrichtenvertragstyp (Parameterlisten, Datenvertragsargumente und explizitem Nachrichtenvertrag). Da jedoch die Serialisierung und Deserialisierung von Nachrichten dieses Typs eine Pufferung durch das Serialisierungsprogramm erfordert, ist die Verwendung dieser Vertragsvarianten nicht ratsam.</span><span class="sxs-lookup"><span data-stu-id="c7917-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="c7917-252">Besondere Sicherheitsüberlegungen für umfangreiche Daten</span><span class="sxs-lookup"><span data-stu-id="c7917-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="c7917-253">Sie können mit allen Bindungen die Größe eingehender Nachrichten einschränken, um Denial-of-Service-Angriffe zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="c7917-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="c7917-254">Beispiels <xref:System.ServiceModel.BasicHttpBinding> Weise macht eine [System. Service Model. BasicHttpBinding. MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) -Eigenschaft verfügbar, die die Größe der eingehenden Nachricht einschränkt, und begrenzt außerdem die maximale Menge an Arbeitsspeicher, auf die beim Verarbeiten der Nachricht zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="c7917-255">Diese Wert wird in Byte festgelegt, mit einem Standardwert von 65.536 Bytes.</span><span class="sxs-lookup"><span data-stu-id="c7917-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="c7917-256">Ein Sicherheitsrisiko, das speziell beim Streaming umfangreicher Daten entsteht, und einen Denial-of-Service-Angriff bedeuten kann, besteht darin, wenn Daten gepuffert werden, während der Empfänger ein Streaming erwartet.</span><span class="sxs-lookup"><span data-stu-id="c7917-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="c7917-257">Beispielsweise puffert WCF immer die SOAP-Header einer Nachricht, sodass ein Angreifer eine große böswillige Nachricht erstellen kann, die vollständig aus Headern besteht, um zu erzwingen, dass die Daten gepuffert werden.</span><span class="sxs-lookup"><span data-stu-id="c7917-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="c7917-258">Legen Sie bei aktiviertem Streaming `MaxReceivedMessageSize` auf einen extrem hohen Wert fest, da der Empfänger nicht davon ausgeht, dass die gesamte Nachricht gleichzeitig im Arbeitsspeicher gepuffert wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="c7917-259">Wenn WCF gezwungen wird, die Nachricht zu puffern, tritt ein Speicher Überlauf auf.</span><span class="sxs-lookup"><span data-stu-id="c7917-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="c7917-260">Deshalb reicht es in diesem Fall nicht aus, die maximale Größe eingehender Nachrichten einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="c7917-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="c7917-261">Die- `MaxBufferSize` Eigenschaft ist erforderlich, um den Arbeitsspeicher einzuschränken, den WCF puffert.</span><span class="sxs-lookup"><span data-stu-id="c7917-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="c7917-262">Legen Sie beim Streaming dafür einen sicheren Wert fest (oder behalten Sie den Standardwert bei).</span><span class="sxs-lookup"><span data-stu-id="c7917-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="c7917-263">Angenommen, der Dienst muss Dateien bis zu einer Größe von 4 GB empfangen und auf der lokalen Festplatte speichern.</span><span class="sxs-lookup"><span data-stu-id="c7917-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="c7917-264">Der Arbeitsspeicher ist in diesem Szenario so eingeschränkt, dass immer nur 64 KB gepuffert werden können.</span><span class="sxs-lookup"><span data-stu-id="c7917-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="c7917-265">Sie würden dann `MaxReceivedMessageSize` auf 4 GB und `MaxBufferSize` auf 64 KB festlegen.</span><span class="sxs-lookup"><span data-stu-id="c7917-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="c7917-266">Außerdem müssen Sie in der Dienstimplementierung sicherstellen, dass nur aus dem eingehenden Stream in 64-KB-Segmenten gelesen wird und das nächste Segment erst gelesen wird, nachdem das vorherige auf die Festplatte geschrieben wurde und es dann aus dem Arbeitspeicher gelöscht wird.</span><span class="sxs-lookup"><span data-stu-id="c7917-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="c7917-267">Es ist auch wichtig zu verstehen, dass dieses Kontingent nur die Pufferung von WCF einschränkt und Sie nicht vor Puffern schützen können, die Sie in ihrer eigenen Dienst-oder Client Implementierung durchführen.</span><span class="sxs-lookup"><span data-stu-id="c7917-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="c7917-268">Weitere Informationen zu zusätzlichen Sicherheitsüberlegungen finden Sie unter [Sicherheitsüberlegungen für Daten](security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="c7917-268">For more information about additional security considerations, see [Security Considerations for Data](security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c7917-269">Die Entscheidung über die Verwendung der gepufferten oder der Streamingübertragung wird lokal am Endpunkt getroffen.</span><span class="sxs-lookup"><span data-stu-id="c7917-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="c7917-270">Bei HTTP-Übertragungen wird der Übertragungsmodus nicht über Verbindungen oder an Proxyserver oder andere Vermittler weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="c7917-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="c7917-271">Das Festlegen des Übertragungsmodus spiegelt sich nicht in der Beschreibung der Dienstschnittstelle wider.</span><span class="sxs-lookup"><span data-stu-id="c7917-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="c7917-272">Nachdem Sie einen WCF-Client für einen Dienst erstellt haben, müssen Sie die Konfigurationsdatei für Dienste bearbeiten, die mit Stream-Übertragungen verwendet werden sollen, um den Modus festzulegen.</span><span class="sxs-lookup"><span data-stu-id="c7917-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="c7917-273">Bei TCP und Named Pipe-Transporten wird der Übertragungsmodus als Richtlinienassertion weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="c7917-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c7917-274">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="c7917-274">See also</span></span>

- [<span data-ttu-id="c7917-275">Vorgehensweise: Aktivieren des Streamingmodus</span><span class="sxs-lookup"><span data-stu-id="c7917-275">How to: Enable Streaming</span></span>](how-to-enable-streaming.md)
