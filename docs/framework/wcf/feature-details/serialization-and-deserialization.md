---
title: Serialisierung und Deserialisierung
description: Erfahren Sie mehr über die WCF-Serialisierungs-Engine, die in beide Richtungen zwischen .NET Framework Objekten und XML übersetzt.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: 3927c17a2548a094a63ffd95ff8a3701403de281
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/23/2020
ms.locfileid: "85244906"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="de8ab-103">Serialisierung und Deserialisierung</span><span class="sxs-lookup"><span data-stu-id="de8ab-103">Serialization and Deserialization</span></span>
<span data-ttu-id="de8ab-104">Windows Communication Foundation (WCF) umfasst ein neues Serialisierungsmodul, das <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="de8ab-104">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="de8ab-105">Der <xref:System.Runtime.Serialization.DataContractSerializer> übersetzt zwischen .NET Framework-Objekten und XML in beide Richtungen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-105">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="de8ab-106">In diesem Thema wird die Funktionsweise des Serialisierungsprogramms erklärt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-106">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="de8ab-107">Beim Serialisieren von .NET Framework Objekten versteht das Serialisierungsprogramm eine Reihe von Programmier Modellen für die Serialisierung, einschließlich des neuen *Daten Vertrags* Modells.</span><span class="sxs-lookup"><span data-stu-id="de8ab-107">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="de8ab-108">Eine vollständige Liste der unterstützten Typen finden Sie unter [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="de8ab-108">For a full list of supported types, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="de8ab-109">Eine Einführung in Datenverträge finden Sie unter [Using Data Contracts](using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="de8ab-109">For an introduction to data contracts, see [Using Data Contracts](using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="de8ab-110">Beim Deserialisieren von XML verwendet das Serialisierungsprogramm die <xref:System.Xml.XmlReader> -Klasse und die <xref:System.Xml.XmlWriter> -Klasse.</span><span class="sxs-lookup"><span data-stu-id="de8ab-110">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="de8ab-111">Außerdem unterstützt es <xref:System.Xml.XmlDictionaryReader> die <xref:System.Xml.XmlDictionaryWriter> Klassen und, damit es in einigen Fällen optimierte XML-Daten erzeugt, z. b. wenn das binäre WCF-XML-Format verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-111">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="de8ab-112">WCF enthält auch einen begleitenden Serialisierer, den <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="de8ab-112">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="de8ab-113">Das <xref:System.Runtime.Serialization.NetDataContractSerializer> -Element ähnelt dem <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> -und dem- <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> Serialisierungstyp, da es auch .NET Framework Typnamen als Teil der serialisierten Daten ausgibt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-113">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span> <span data-ttu-id="de8ab-114">Es wird verwendet, wenn die Endpunkte, die die Serialisierung und die Deserialisierung durchführen, die gleichen Datentypen verwenden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-114">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="de8ab-115">Sowohl <xref:System.Runtime.Serialization.DataContractSerializer> als auch <xref:System.Runtime.Serialization.NetDataContractSerializer> sind von der gemeinsamen Basisklasse <xref:System.Runtime.Serialization.XmlObjectSerializer>abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="de8ab-115">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
> <span data-ttu-id="de8ab-116">Der <xref:System.Runtime.Serialization.DataContractSerializer> serialisiert Zeichenfolgen mit Steuerzeichen mit einem Hexadezimalwert kleiner als 20 als XML-Entitäten.</span><span class="sxs-lookup"><span data-stu-id="de8ab-116">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="de8ab-117">Dies kann zu einem Problem mit einem nicht-WCF-Client führen, wenn solche Daten an einen WCF-Dienst gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-117">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="de8ab-118">Erstellen einer DataContractSerializer-Instanz</span><span class="sxs-lookup"><span data-stu-id="de8ab-118">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="de8ab-119">Das Erstellen einer <xref:System.Runtime.Serialization.DataContractSerializer> -Instanz ist ein wichtiger Schritt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-119">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="de8ab-120">Sie können nach der Erstellung dieser Instanz keine Einstellungen mehr ändern.</span><span class="sxs-lookup"><span data-stu-id="de8ab-120">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="de8ab-121">Angeben des Stammtyps</span><span class="sxs-lookup"><span data-stu-id="de8ab-121">Specifying the Root Type</span></span>  
 <span data-ttu-id="de8ab-122">Der *Stammtyp* ist der Typ, von dem Instanzen serialisiert oder deserialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-122">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="de8ab-123">Für <xref:System.Runtime.Serialization.DataContractSerializer> sind viele überladene Konstruktoren verfügbar; aber mindestens ein Stammtyp muss mit dem Parameter `type` angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-123">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="de8ab-124">Ein für einen bestimmten Stammtyp erstelltes Serialisierungsprogramm kann nur dann zum Serialisieren (oder Deserialisieren) eines anderen Typs verwendet werden, wenn dieser Typ vom Stammtyp abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="de8ab-124">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="de8ab-125">Das folgende Beispiel zeigt zwei Klassen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-125">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="de8ab-126">In diesem Code wird eine Instanz der `DataContractSerializer` -Klasse erstellt, die lediglich zum Serialisieren und Deserialisieren der `Person` -Klasse verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="de8ab-126">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="de8ab-127">Angeben von bekannten Typen</span><span class="sxs-lookup"><span data-stu-id="de8ab-127">Specifying Known Types</span></span>  
 <span data-ttu-id="de8ab-128">Wenn die serialisierten Typen polymorph sind und die Polymorphie nicht bereits mithilfe des <xref:System.Runtime.Serialization.KnownTypeAttribute> -Attributs oder eines anderen Mechanismus gehandhabt wird, dann muss dem Konstruktor der Serializer-Instanz im `knownTypes` -Parameter eine Liste der möglichen bekannten Typen übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-128">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="de8ab-129">Weitere Informationen zu bekannten Typen finden Sie unter [Data Contract Known Types](data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="de8ab-129">For more information about known types, see [Data Contract Known Types](data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="de8ab-130">Im folgenden Codebeispiel wird die Klasse namens `LibraryPatron`veranschaulicht, die eine Auflistung des Typs `LibraryItem`enthält.</span><span class="sxs-lookup"><span data-stu-id="de8ab-130">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="de8ab-131">Die zweite Klasse definiert den `LibraryItem` -Typ.</span><span class="sxs-lookup"><span data-stu-id="de8ab-131">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="de8ab-132">Die dritte Klasse und die vierte Klasse (`Book` und `Newspaper`) sind von der `LibraryItem` -Klasse abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="de8ab-132">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="de8ab-133">Im folgenden Code wird unter Angabe des `knownTypes` -Parameters eine Serializer-Instanz erstellt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-133">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="de8ab-134">Angeben von Standardstammnamen und -namespace</span><span class="sxs-lookup"><span data-stu-id="de8ab-134">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="de8ab-135">Wenn ein Objekt serialisiert wird, werden der Standardname und der Namespace des äußersten XML-Elements in der Regel anhand des Namens und Namespace des Datenvertrags bestimmt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-135">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="de8ab-136">Die Namen aller inneren Elemente werden aus den Datenmembernamen ermittelt, und als Namespace wird ihnen der Namespace des Datenvertrags zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="de8ab-136">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="de8ab-137">Im folgenden Beispiel werden die Werte für `Name` und `Namespace` in den Konstruktoren für die <xref:System.Runtime.Serialization.DataContractAttribute> -Klasse und die <xref:System.Runtime.Serialization.DataMemberAttribute> -Klasse festgelegt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-137">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="de8ab-138">Durch die Serialisierung einer Instanz der `Person` -Klasse wird eine XML-Ausgabe erzeugt, die folgendem XML-Code ähnelt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-138">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="de8ab-139">Sie können den Standardnamen und den Namespace des Stammelements anpassen, indem Sie Werte für den `rootName` -Parameter und den `rootNamespace` -Parameter dem <xref:System.Runtime.Serialization.DataContractSerializer> -Konstruktor übergeben.</span><span class="sxs-lookup"><span data-stu-id="de8ab-139">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="de8ab-140">Beachten Sie, dass sich der `rootNamespace` -Parameter nicht auf den Namespace der darin enthaltenen Elemente auswirkt, die Datenmembern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-140">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="de8ab-141">Die Parameterangabe betrifft nur den Namespace des äußersten Elements.</span><span class="sxs-lookup"><span data-stu-id="de8ab-141">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="de8ab-142">Diese Werte können als Zeichenfolgen oder als Instanzen der <xref:System.Xml.XmlDictionaryString> -Klasse übergeben werden, damit sie unter Verwendung des binären XML-Formats optimiert werden können.</span><span class="sxs-lookup"><span data-stu-id="de8ab-142">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="de8ab-143">Festlegen des maximalen Objektkontingents</span><span class="sxs-lookup"><span data-stu-id="de8ab-143">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="de8ab-144">Einige `DataContractSerializer` -Konstruktorüberladungen verfügen über den `maxItemsInObjectGraph` -Parameter.</span><span class="sxs-lookup"><span data-stu-id="de8ab-144">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="de8ab-145">Dieser Parameter legt die maximale Anzahl von Objekten fest, die das Serialisierungsprogramm in einem <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> -Methodenaufruf serialisieren oder deserialisieren kann.</span><span class="sxs-lookup"><span data-stu-id="de8ab-145">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="de8ab-146">(Die Methode liest immer ein Stammobjekt, aber dieses Objekt kann in seinen Datenmembern andere Objekte enthalten.</span><span class="sxs-lookup"><span data-stu-id="de8ab-146">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="de8ab-147">Diese Objekte verfügen möglicherweise über andere Objekte usw.) Der Standardwert ist 65536.</span><span class="sxs-lookup"><span data-stu-id="de8ab-147">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="de8ab-148">Beachten Sie, dass beim Serialisieren und Deserialisieren von Arrays jeder Arrayeintrag als separates Objekt betrachtet wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-148">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="de8ab-149">Beachten Sie zudem, dass einige Objekte über eine große Speicherdarstellung verfügen und dass dieses Kontingent allein daher möglicherweise nicht ausreicht, um einen Denial-of-Service-Angriff zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="de8ab-149">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="de8ab-150">Weitere Informationen finden Sie unter [Sicherheitsüberlegungen für Daten](security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="de8ab-150">For more information, see [Security Considerations for Data](security-considerations-for-data.md).</span></span> <span data-ttu-id="de8ab-151">Wenn Sie das Kontingent über die Standardeinstellung hinaus erhöhen müssen, müssen Sie dies unbedingt sowohl auf der sendenden (serialisierenden) als auch der empfangenden (deserialisierenden) Seite tun, da das Kontingent sowohl für das Lesen als auch das Schreiben von Daten gilt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-151">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="de8ab-152">Roundtrips</span><span class="sxs-lookup"><span data-stu-id="de8ab-152">Round Trips</span></span>  
 <span data-ttu-id="de8ab-153">Ein *Roundtrip* tritt auf, wenn ein Objekt in einem Vorgang deserialisiert und erneut serialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-153">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="de8ab-154">Das heißt, Daten werden aus XML in eine Objektinstanz und wieder zurück in einen XML-Stream umgewandelt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-154">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="de8ab-155">Einige `DataContractSerializer` -Konstruktorüberladungen verfügen über den `ignoreExtensionDataObject` -Parameter, der standardmäßig auf `false` festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="de8ab-155">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="de8ab-156">In diesem Standardmodus können Daten von einer neueren Version des Datenvertrags zu einer älteren Datenvertragsversion und wieder zurück zur neueren Version geschickt werden, ohne dass Datenverluste auftreten, sofern der Datenvertrag die <xref:System.Runtime.Serialization.IExtensibleDataObject> -Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="de8ab-156">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="de8ab-157">Nehmen wir beispielsweise an, Version 1 des `Person` -Datenvertrags enthält die Datenmember `Name` und `PhoneNumber` , und in Version 2 wurde der Member `Nickname` hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-157">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="de8ab-158">Wenn `IExtensibleDataObject` implementiert wurde, dann werden beim Senden der Daten von Version 2 an Version 1 die `Nickname` -Daten gespeichert und beim erneuten Serialisieren der Daten wieder ausgegeben. Daher gehen in Roundtrips keine Daten verloren.</span><span class="sxs-lookup"><span data-stu-id="de8ab-158">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="de8ab-159">Weitere Informationen finden Sie unter [Forward-kompatible Datenverträge](forward-compatible-data-contracts.md) und [Versions](data-contract-versioning.md)Verwaltung von Daten Verträgen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-159">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md) and [Data Contract Versioning](data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="de8ab-160">Bedenken hinsichtlich der Sicherheit und Schemavalidierung bei Roundtrips</span><span class="sxs-lookup"><span data-stu-id="de8ab-160">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="de8ab-161">Roundtrips beeinträchtigen möglicherweise die Sicherheit.</span><span class="sxs-lookup"><span data-stu-id="de8ab-161">Round trips may have security implications.</span></span> <span data-ttu-id="de8ab-162">Beispielsweise kann das Deserialisieren und Speichern von großen Mengen externer Daten ein Sicherheitsrisiko darstellen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-162">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="de8ab-163">Es kann Sicherheitsbedenken in Bezug auf die erneute Ausgabe dieser Daten geben, weil sich diese nicht verifizieren lassen, insbesondere wenn sie digital signiert sind.</span><span class="sxs-lookup"><span data-stu-id="de8ab-163">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="de8ab-164">Beispielsweise könnte im obigen Szenario der Endpunkt mit Version&#160;1 einen `Nickname` -Wert signieren, der bösartige Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="de8ab-164">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="de8ab-165">Schließlich kann es Bedenken hinsichtlich der Schemavalidierung geben: Es kann wünschenswert sein, dass ein Endpunkt nur Daten, die genau dem angegebenen Datenvertrag entsprechen, und keine zusätzlichen Werte ausgibt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-165">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="de8ab-166">Im vorigen Beispiel besagt der Datenvertrag des Endpunkts mit Version&#160;1, dass dieser nur `Name` und `PhoneNumber`ausgibt, und bei Verwendung einer Schemavalidierung verursacht die Ausgabe des zusätzlichen `Nickname` -Werts einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="de8ab-166">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="de8ab-167">Aktivieren und Deaktivieren von Roundtrips</span><span class="sxs-lookup"><span data-stu-id="de8ab-167">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="de8ab-168">Wenn Sie Roundtrips deaktivieren möchten, implementieren Sie die <xref:System.Runtime.Serialization.IExtensibleDataObject> -Schnittstelle nicht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-168">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="de8ab-169">Falls Sie keine Kontrolle über die Typen haben, legen Sie den `ignoreExtensionDataObject` -Parameter auf `true` fest, um Roundtrips zu unterbinden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-169">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="de8ab-170">Objektdiagrammbeibehaltung</span><span class="sxs-lookup"><span data-stu-id="de8ab-170">Object Graph Preservation</span></span>  
 <span data-ttu-id="de8ab-171">Normalerweise befasst sich das Serialisierungsprogramm nicht mit der Objektidentität, wie im folgenden Code gezeigt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-171">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="de8ab-172">Im folgenden Code wird ein PurchaseOrder-Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-172">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="de8ab-173">Beachten Sie, dass das `billTo` -Feld und `shipTo` -Feld auf die gleiche Objektinstanz festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-173">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="de8ab-174">Das generierte XML dupliziert allerdings die doppelt vorhandenen Informationen und ähnelt dem folgenden XML.</span><span class="sxs-lookup"><span data-stu-id="de8ab-174">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="de8ab-175">Dieser Ansatz verfügt über die folgenden Eigenschaften, die möglicherweise unerwünscht sind:</span><span class="sxs-lookup"><span data-stu-id="de8ab-175">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="de8ab-176">Leistung.</span><span class="sxs-lookup"><span data-stu-id="de8ab-176">Performance.</span></span> <span data-ttu-id="de8ab-177">Die Datenreplizierung ist ineffizient.</span><span class="sxs-lookup"><span data-stu-id="de8ab-177">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="de8ab-178">Zirkuläre Verweise.</span><span class="sxs-lookup"><span data-stu-id="de8ab-178">Circular references.</span></span> <span data-ttu-id="de8ab-179">Wenn Objekte auf sich selbst verweisen, resultiert die Serialisierung durch Replizierung auch dann in einer Endlosschleife, wenn die Verweise über andere Objekte führen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-179">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="de8ab-180">(Das Serialisierungsprogramm löst in diesem Fall eine <xref:System.Runtime.Serialization.SerializationException> aus.)</span><span class="sxs-lookup"><span data-stu-id="de8ab-180">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="de8ab-181">Semantik.</span><span class="sxs-lookup"><span data-stu-id="de8ab-181">Semantics.</span></span> <span data-ttu-id="de8ab-182">Gelegentlich ist es wichtig, die Tatsache zu vermerken, dass zwei Verweise auf das gleiche Objekt und nicht auf zwei identische Objekte zeigen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-182">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="de8ab-183">Aus diesem Grund verfügen einige `DataContractSerializer` -Konstruktorüberladungen über den `preserveObjectReferences` -Parameter (dessen Standardwert lautet `false`).</span><span class="sxs-lookup"><span data-stu-id="de8ab-183">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="de8ab-184">Wenn dieser Parameter auf festgelegt ist `true` , wird eine spezielle Methode zur Codierung von Objekt verweisen verwendet, die nur WCF versteht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-184">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="de8ab-185">Wenn der Parameter auf `true`festgelegt wird, sieht das XML-Codebeispiel etwa wie folgt aus.</span><span class="sxs-lookup"><span data-stu-id="de8ab-185">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="de8ab-186">Der "ser"-Namespace verweist auf den Standardserialisierungsnamespace `http://schemas.microsoft.com/2003/10/Serialization/` .</span><span class="sxs-lookup"><span data-stu-id="de8ab-186">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="de8ab-187">Jedes Datenelement wird nur einmal serialisiert und erhält eine ID-Nummer. Bei nachfolgender Verwendung wird ein Verweis auf die bereits serialisierten Daten erzeugt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-187">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="de8ab-188">Ist sowohl das Attribut "id" als auch das Attribut "ref" im `XMLElement`des Datenvertrags vorhanden, wird das Attribut "ref" berücksichtigt, und das Attribut "id" wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="de8ab-188">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="de8ab-189">Es ist wichtig, die Einschränkungen dieses Modus zu kennen:</span><span class="sxs-lookup"><span data-stu-id="de8ab-189">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="de8ab-190">Das XML, das der `DataContractSerializer` erzeugt, wenn der `preserveObjectReferences` -Parameter auf `true` festgelegt ist, kann von keiner anderen Technologie verarbeitet werden. Nur eine andere `DataContractSerializer` -Instanz, bei der der `preserveObjectReferences` -Parameter auch auf `true`festgelegt ist, kann darauf zugreifen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-190">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="de8ab-191">Es ist keine Metadaten- (Schema)-Unterstützung für diese Funktion verfügbar.</span><span class="sxs-lookup"><span data-stu-id="de8ab-191">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="de8ab-192">Das Schema, das erzeugt wird, ist nur in dem Fall gültig, in dem `preserveObjectReferences` auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="de8ab-192">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="de8ab-193">Diese Funktion bewirkt möglicherweise, dass Serialisierung und Deserialisierung langsamer ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-193">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="de8ab-194">Obwohl die Daten nicht repliziert werden müssen, müssen in diesem Modus zusätzliche Objektvergleiche angestellt werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-194">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="de8ab-195">Wenn der `preserveObjectReferences` -Modus aktiviert ist, muss der `maxItemsInObjectGraph` -Wert unbedingt auf das richtige Kontingent festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-195">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="de8ab-196">Aufgrund der Art und Weise, wie Arrays in diesem Modus behandelt werden, ist es für Angreifer einfach, eine kleine bösartige Nachricht zu erstellen, die in zu einem hohen Speicherverbrauch führt, der nur durch das `maxItemsInObjectGraph` -Kontingent begrenzt wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-196">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="de8ab-197">Angeben eines Datenvertrag-Ersatzzeichens</span><span class="sxs-lookup"><span data-stu-id="de8ab-197">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="de8ab-198">Einige `DataContractSerializer` -Konstruktorüberladungen verfügen über den `dataContractSurrogate` -Parameter, der möglicherweise auf `null`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="de8ab-198">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="de8ab-199">Andernfalls können Sie mit diesem Parameter ein *Datenvertrag-Ersatzzeichen*festlegen, d.&#160;h. einen Typ, der die <xref:System.Runtime.Serialization.IDataContractSurrogate> -Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="de8ab-199">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="de8ab-200">Sie können dann mithilfe dieser Schnittstelle die Serialisierung und Deserialisierung anpassen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-200">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="de8ab-201">Weitere Informationen finden Sie unter [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span><span class="sxs-lookup"><span data-stu-id="de8ab-201">For more information, see [Data Contract Surrogates](../extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="de8ab-202">Serialisierung</span><span class="sxs-lookup"><span data-stu-id="de8ab-202">Serialization</span></span>  
 <span data-ttu-id="de8ab-203">Die folgenden Ausführungen gelten für alle von <xref:System.Runtime.Serialization.XmlObjectSerializer>abgeleiteten Klassen, einschließlich der <xref:System.Runtime.Serialization.DataContractSerializer> -Klasse und der <xref:System.Runtime.Serialization.NetDataContractSerializer> -Klasse.</span><span class="sxs-lookup"><span data-stu-id="de8ab-203">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="de8ab-204">Einfache Serialisierung</span><span class="sxs-lookup"><span data-stu-id="de8ab-204">Simple Serialization</span></span>  
 <span data-ttu-id="de8ab-205">Die grundlegendste Möglichkeit, ein Objekt zu serialisieren, besteht darin, es der <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> -Methode zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="de8ab-205">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="de8ab-206">Es gibt drei Überladungen, jeweils eine zum Schreiben in ein <xref:System.IO.Stream>-Objekt, ein <xref:System.Xml.XmlWriter>-Objekt oder ein <xref:System.Xml.XmlDictionaryWriter>-Objekt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-206">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="de8ab-207">Bei Verwendung der <xref:System.IO.Stream> -Überladung enthält die Ausgabe XML in UTF-8-Codierung.</span><span class="sxs-lookup"><span data-stu-id="de8ab-207">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="de8ab-208">Bei Verwendung der <xref:System.Xml.XmlDictionaryWriter> -Überladung optimiert das Serialisierungsprogramm seine Ausgabe für binäres XML.</span><span class="sxs-lookup"><span data-stu-id="de8ab-208">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="de8ab-209">Bei Verwendung der- <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> Methode verwendet das Serialisierungsprogramm den Standardnamen und-Namespace für das Wrapper Element und schreibt es zusammen mit dem Inhalt (Weitere Informationen finden Sie im vorherigen Abschnitt "angeben des Standard Stamms und Namespace").</span><span class="sxs-lookup"><span data-stu-id="de8ab-209">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="de8ab-210">Im folgenden Codebeispiel wird der Schreibvorgang mit <xref:System.Xml.XmlDictionaryWriter>veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-210">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="de8ab-211">Damit wird XML generiert, das etwa wie folgt aussieht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-211">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="de8ab-212">Schrittweise Serialisierung</span><span class="sxs-lookup"><span data-stu-id="de8ab-212">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="de8ab-213">Verwenden Sie die Methoden <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>und <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> , um das Endelement und den Inhalt des Objekts zu schreiben bzw. das Wrapperelement zu schließen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-213">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="de8ab-214">Es sind keine <xref:System.IO.Stream> -Überladungen für diese Methoden verfügbar.</span><span class="sxs-lookup"><span data-stu-id="de8ab-214">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="de8ab-215">Diese schrittweise Serialisierung wird üblicherweise in zwei Fällen eingesetzt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-215">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="de8ab-216">Erstens wird sie verwendet, um Inhalte wie Attribute oder Kommentare zwischen `WriteStartObject` und `WriteObjectContent`einzufügen. Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-216">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="de8ab-217">Damit wird XML generiert, das etwa wie folgt aussieht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-217">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="de8ab-218">Sie wird auch häufig verwendet, um die Verwendung von <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> und <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> zu vermeiden und ein eigenes, benutzerdefiniertes Wrapperelement zu schreiben (oder die Erstellung eines Wrapperelements ganz zu umgehen), wie im folgenden Code gezeigt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-218">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="de8ab-219">Damit wird XML generiert, das etwa wie folgt aussieht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-219">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="de8ab-220">Die Verwendung der schrittweisen Serialisierung kann in XML resultieren, das keinem gültigen Schema entspricht.</span><span class="sxs-lookup"><span data-stu-id="de8ab-220">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="de8ab-221">Deserialisierung</span><span class="sxs-lookup"><span data-stu-id="de8ab-221">Deserialization</span></span>  
 <span data-ttu-id="de8ab-222">Die folgenden Ausführungen gelten für alle von <xref:System.Runtime.Serialization.XmlObjectSerializer>abgeleiteten Klassen, einschließlich der <xref:System.Runtime.Serialization.DataContractSerializer> -Klasse und der <xref:System.Runtime.Serialization.NetDataContractSerializer> -Klasse.</span><span class="sxs-lookup"><span data-stu-id="de8ab-222">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="de8ab-223">Die grundlegendste Möglichkeit, ein Objekt zu deserialisieren, besteht im Aufruf einer der Überladungen der <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> -Methode.</span><span class="sxs-lookup"><span data-stu-id="de8ab-223">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="de8ab-224">Es sind drei Überladungen verfügbar, jeweils eine zum Lesen mit einem <xref:System.Xml.XmlDictionaryReader>-Objekt, einem `XmlReader`-Objekt oder einem `Stream`-Objekt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-224">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="de8ab-225">Beachten Sie, dass die `Stream` -Überladung einen textbasierten <xref:System.Xml.XmlDictionaryReader> erstellt, der nicht durch Kontingente geschützt wird und nur zum Lesen vertrauenswürdiger Daten verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="de8ab-225">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="de8ab-226">Beachten Sie außerdem, dass das von der `ReadObject` -Methode zurückgegebene Objekt in den entsprechenden Typ umgewandelt werden muss.</span><span class="sxs-lookup"><span data-stu-id="de8ab-226">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="de8ab-227">Im folgenden Code wird eine Instanz der <xref:System.Runtime.Serialization.DataContractSerializer> -Klasse und ein <xref:System.Xml.XmlDictionaryReader>erzeugt, und dann eine `Person` -Instanz deserialisiert.</span><span class="sxs-lookup"><span data-stu-id="de8ab-227">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="de8ab-228">Positionieren Sie den XML-Reader vor dem Aufruf der <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> -Methode auf dem Wrapperelement oder einem Knoten, der keinen Inhalt enthält und sich vor dem Wrapperelement befindet.</span><span class="sxs-lookup"><span data-stu-id="de8ab-228">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="de8ab-229">Sie können zu diesem Zweck die <xref:System.Xml.XmlReader.Read%2A> -Methode der <xref:System.Xml.XmlReader> -Klasse oder der davon abgeleiteten Klasse aufrufen und den <xref:System.Xml.XmlReader.NodeType%2A>testen, wie im folgenden Code gezeigt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-229">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="de8ab-230">Beachten Sie, dass Sie Attribute dieses Wrapperelements lesen können, bevor der Reader an `ReadObject`übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-230">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="de8ab-231">Wenn Sie eine der einfachen `ReadObject` über Ladungen verwenden, sucht das Deserialisierungsprogramm im Wrapper Element nach dem Standardnamen und-Namespace (siehe den vorherigen Abschnitt "angeben des standardmäßigen Stamm namens und Namespace") und löst eine Ausnahme aus, wenn ein unbekanntes Element gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-231">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="de8ab-232">Im vorstehenden Beispiel wird das Wrapperelement `<Person>` erwartet.</span><span class="sxs-lookup"><span data-stu-id="de8ab-232">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="de8ab-233">Die <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> -Methode wird aufgerufen, um zu überprüfen, ob der Reader auf einem Element mit dem erwarteten Namen positioniert wurde.</span><span class="sxs-lookup"><span data-stu-id="de8ab-233">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="de8ab-234">Es gibt eine Möglichkeit, diese Namensüberprüfung des Wrapperelements zu deaktivieren. Einige Überladungen der `ReadObject` -Methode akzeptieren den Booleschen Parameter `verifyObjectName`, der standardmäßig auf `true` festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="de8ab-234">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="de8ab-235">Wenn der Parameter auf `false`festgelegt wird, werden Name und Namespace des Wrapperelements ignoriert.</span><span class="sxs-lookup"><span data-stu-id="de8ab-235">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="de8ab-236">Dies ist beim Lesen von XML hilfreich, das mit dem oben beschriebenen schrittweisen Serialisierungsmechanismus geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="de8ab-236">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="de8ab-237">Verwenden von NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="de8ab-237">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="de8ab-238">Der Hauptunterschied zwischen `DataContractSerializer` und <xref:System.Runtime.Serialization.NetDataContractSerializer> besteht darin, dass der `DataContractSerializer` Daten Vertrags Namen verwendet, während der `NetDataContractSerializer` vollständige .NET Framework Assembly und Typnamen in der serialisierten XML ausgibt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-238">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="de8ab-239">Dies bedeutet, dass die Endpunkte für Serialisierung und Deserialisierung genau die gleichen Datentypen verwenden müssen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-239">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="de8ab-240">Folglich muss der Mechanismus der bekannten Typen nicht in Verbindung mit `NetDataContractSerializer` verwendet werden, weil stets bekannt ist, welche Typen im Einzelnen deserialisiert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-240">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="de8ab-241">Es können jedoch verschiedene Probleme auftreten:</span><span class="sxs-lookup"><span data-stu-id="de8ab-241">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="de8ab-242">Sicherheit.</span><span class="sxs-lookup"><span data-stu-id="de8ab-242">Security.</span></span> <span data-ttu-id="de8ab-243">Jeder Typ, der in dem zu deserialisierenden XML gefunden wird, wird geladen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-243">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="de8ab-244">Dies kann ausgenutzt werden, um das Laden bösartiger Typen zu erzwingen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-244">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="de8ab-245">`NetDataContractSerializer` sollte nur dann für nicht vertrauenswürdige Daten eingesetzt werden, wenn ein *Serialisierungsbinder* verwendet wird (über die <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> -Eigenschaft oder einen Konstruktorparameter).</span><span class="sxs-lookup"><span data-stu-id="de8ab-245">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="de8ab-246">Die Binder lässt nur das Laden sicherer Typen zu.</span><span class="sxs-lookup"><span data-stu-id="de8ab-246">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="de8ab-247">Der Bindermechanismus ist mit dem Mechanismus identisch, den die im <xref:System.Runtime.Serialization> -Namespace definierten Typen verwenden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-247">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="de8ab-248">Versionskontrolle.</span><span class="sxs-lookup"><span data-stu-id="de8ab-248">Versioning.</span></span> <span data-ttu-id="de8ab-249">Die Angabe vollständiger Typ- und Assemblynamen im XML schränkt die Verfahren zur Versionskontrolle der Typen schwerwiegend ein.</span><span class="sxs-lookup"><span data-stu-id="de8ab-249">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="de8ab-250">Folgendes kann nicht geändert werden: Typnamen, Namespaces, Assemblynamen und Assemblyversionen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-250">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="de8ab-251">Wenn die <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> -Eigenschaft oder der Konstruktorparameter auf <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> statt den Standardwert <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> festgelegt wird, sind Änderungen der Assemblyversion, jedoch keine generischen Parametertypen zulässig.</span><span class="sxs-lookup"><span data-stu-id="de8ab-251">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="de8ab-252">Interoperabilität.</span><span class="sxs-lookup"><span data-stu-id="de8ab-252">Interoperability.</span></span> <span data-ttu-id="de8ab-253">Da .NET Framework Typ-und Assemblynamen in der XML-Datei enthalten sind, können andere Plattformen als die .NET Framework nicht auf die resultierenden Daten zugreifen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-253">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="de8ab-254">Leistung.</span><span class="sxs-lookup"><span data-stu-id="de8ab-254">Performance.</span></span> <span data-ttu-id="de8ab-255">Die Ausgabe von Typ- und Assemblynamen vergrößert den Umfang des resultierenden XML bedeutend.</span><span class="sxs-lookup"><span data-stu-id="de8ab-255">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="de8ab-256">Dieser Mechanismus ähnelt der binären Serialisierung oder der SOAP-Serialisierung, die von .NET Framework Remoting verwendet wird (insbesondere von <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> und <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> ).</span><span class="sxs-lookup"><span data-stu-id="de8ab-256">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="de8ab-257">Die Verwendung von `NetDataContractSerializer` unterscheidet sich von der Verwendung von `DataContractSerializer`lediglich in folgender Hinsicht:</span><span class="sxs-lookup"><span data-stu-id="de8ab-257">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="de8ab-258">Die Konstruktoren erfordern keine Angabe des Stammtyps.</span><span class="sxs-lookup"><span data-stu-id="de8ab-258">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="de8ab-259">Sie können jeden Typ mit der gleichen Instanz von `NetDataContractSerializer`serialisieren.</span><span class="sxs-lookup"><span data-stu-id="de8ab-259">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="de8ab-260">Die Konstruktoren akzeptieren keine Liste bekannter Typen an.</span><span class="sxs-lookup"><span data-stu-id="de8ab-260">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="de8ab-261">Der Mechanismus der bekannten Typen ist unnötig, wenn die Typnamen in XML serialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-261">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="de8ab-262">Die Konstruktoren akzeptieren kein Datenvertrag-Ersatzzeichen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-262">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="de8ab-263">Stattdessen akzeptieren sie einen <xref:System.Runtime.Serialization.ISurrogateSelector> -Parameter namens `surrogateSelector` (welcher der <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> -Eigenschaft zugeordnet wird).</span><span class="sxs-lookup"><span data-stu-id="de8ab-263">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="de8ab-264">Dies ist ein älterer Ersatzzeichenmechanismus.</span><span class="sxs-lookup"><span data-stu-id="de8ab-264">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="de8ab-265">Die Konstruktoren akzeptieren einen Parameter namens `assemblyFormat` vom <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> , welcher der <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> -Eigenschaft zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-265">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="de8ab-266">Wie oben erläutert, lassen sich damit die Versionskontrollfähigkeiten des Serialisierungsprogramms verbessern.</span><span class="sxs-lookup"><span data-stu-id="de8ab-266">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="de8ab-267">Dies entspricht dem <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> -Mechanismus in der binären Serialisierung oder der SOAP-Serialisierung.</span><span class="sxs-lookup"><span data-stu-id="de8ab-267">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="de8ab-268">Die Konstruktoren akzeptieren einen <xref:System.Runtime.Serialization.StreamingContext> -Parameter namens `context` , welcher der <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> -Eigenschaft zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-268">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="de8ab-269">Sie können diesen zur Übergabe von Informationen an Typen nutzen, die serialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="de8ab-269">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="de8ab-270">Diese Art der Verwendung entspricht dem <xref:System.Runtime.Serialization.StreamingContext> -Mechanismus, der in anderen <xref:System.Runtime.Serialization> -Klassen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="de8ab-270">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="de8ab-271">Die <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> -Methode und die <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> -Methode sind Aliase für die <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> -Methode bzw. die <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> -Methode.</span><span class="sxs-lookup"><span data-stu-id="de8ab-271">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="de8ab-272">Sie sollen ein konsistenteres Programmiermodell für die binäre Serialisierung oder SOAP-Serialisierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="de8ab-272">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="de8ab-273">Weitere Informationen zu diesen Funktionen finden Sie unter [binäre Serialisierung](../../../standard/serialization/binary-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="de8ab-273">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="de8ab-274">Die von der `NetDataContractSerializer` -Klasse und der `DataContractSerializer` -Klasse verwendeten XML-Formate sind normalerweise nicht kompatibel.</span><span class="sxs-lookup"><span data-stu-id="de8ab-274">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="de8ab-275">Das heißt, es ist nicht möglich, Daten mit einem dieser Serialisierungsprogramme zu serialisieren und sie mit dem anderen Serialisierungsprogramm zu deserialisieren.</span><span class="sxs-lookup"><span data-stu-id="de8ab-275">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="de8ab-276">Beachten Sie außerdem, dass `NetDataContractSerializer` nicht den vollständigen .NET Framework-und Assemblynamen für jeden Knoten im Objekt Diagramm ausgibt.</span><span class="sxs-lookup"><span data-stu-id="de8ab-276">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="de8ab-277">Diese Informationen werden nur im Fall möglicher Mehrdeutigkeiten ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="de8ab-277">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="de8ab-278">Das heißt, sie werden auf der Stammobjektebene und für polymorphe Fälle ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="de8ab-278">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="de8ab-279">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="de8ab-279">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="de8ab-280">Binäre Serialisierung</span><span class="sxs-lookup"><span data-stu-id="de8ab-280">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="de8ab-281">Vom Datenvertragsserialisierer unterstützte Typen</span><span class="sxs-lookup"><span data-stu-id="de8ab-281">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
