---
title: Eigenständige JSON-Serialisierung mit DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 259d5da544262b5cae08e1be9e8ea6e077d5b947
ms.sourcegitcommit: ee5b798427f81237a3c23d1fd81fff7fdc21e8d3
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 05/28/2020
ms.locfileid: "84144928"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="ab192-102">Eigenständige JSON-Serialisierung mit DataContractJsonSerializer</span><span class="sxs-lookup"><span data-stu-id="ab192-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="ab192-103">In diesem Artikel geht es um <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .</span><span class="sxs-lookup"><span data-stu-id="ab192-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="ab192-104">In den meisten Szenarien, in denen JSON serialisiert und deserialisiert wird, empfehlen wir die APIs im [System. Text. Json-Namespace](../../../standard/serialization/system-text-json-overview.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="ab192-105">JSON (JavaScript Object Notation) ist ein Datenformat, das speziell zur Verwendung von JavaScript-Code entworfen wurde, der auf Webseiten innerhalb des Browsers ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ab192-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="ab192-106">Dies ist das Standarddatenformat, das von ASP.NET AJAX-Diensten verwendet wird, die in Windows Communication Foundation (WCF) erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="ab192-107">Dieses Format kann auch für AJAX-Dienste verwendet werden, die nicht in ASP.NET integriert sind. In diesem Fall ist zwar XML der Standard, jedoch kann JSON gewählt werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="ab192-108">Und wenn Sie schließlich JSON-Unterstützung benötigen, aber keinen AJAX-Dienst erstellen, ermöglicht Ihnen der <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, .NET-Objekte direkt in JSON-Daten zu serialisieren und diese Daten wieder in Instanzen von .NET-Typen zu deserialisieren.</span><span class="sxs-lookup"><span data-stu-id="ab192-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="ab192-109">Eine Beschreibung der Vorgehensweise finden Sie unter Gewusst [wie: Serialisieren und Deserialisieren von JSON-Daten](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="ab192-110">Bei der Arbeit mit JSON werden mit wenigen Ausnahmen dieselben .NET-Typen unterstützt, die auch vom <xref:System.Runtime.Serialization.DataContractSerializer> unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="ab192-111">Eine Liste der unterstützten Typen finden Sie unter [vom Datenvertragsserialisierer unterstützte Typen](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="ab192-112">Dazu gehören die meisten primitiven Typen, die meisten Array- und Auflistungstypen sowie die komplexen Typen, die das <xref:System.Runtime.Serialization.DataContractAttribute> und das <xref:System.Runtime.Serialization.DataMemberAttribute> verwenden.</span><span class="sxs-lookup"><span data-stu-id="ab192-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="ab192-113">Zuordnung von .NET-Typen zu JSON-Typen</span><span class="sxs-lookup"><span data-stu-id="ab192-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="ab192-114">Die folgende Tabelle zeigt die Entsprechungen zwischen .NET-Typen und JSON/JavaScript-Typen, die für die Zuordnung während der Serialisierung und Deserialisierung gelten.</span><span class="sxs-lookup"><span data-stu-id="ab192-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="ab192-115">.NET-Typen</span><span class="sxs-lookup"><span data-stu-id="ab192-115">.NET Types</span></span>|<span data-ttu-id="ab192-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="ab192-116">JSON/JavaScript</span></span>|<span data-ttu-id="ab192-117">Hinweise</span><span class="sxs-lookup"><span data-stu-id="ab192-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="ab192-118">Alle numerischen Typen, z.&#160;B. <xref:System.Int32>, <xref:System.Decimal> oder <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="ab192-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="ab192-119">Zahl</span><span class="sxs-lookup"><span data-stu-id="ab192-119">Number</span></span>|<span data-ttu-id="ab192-120">Spezielle Werte, z.&#160;B. `Double.NaN`, `Double.PositiveInfinity` und `Double.NegativeInfinity` werden nicht unterstützt und führen zu ungültigen JSON-Daten.</span><span class="sxs-lookup"><span data-stu-id="ab192-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="ab192-121">Zahl</span><span class="sxs-lookup"><span data-stu-id="ab192-121">Number</span></span>|<span data-ttu-id="ab192-122">Siehe "Enumerationen und JSON" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="ab192-123">Boolescher Wert</span><span class="sxs-lookup"><span data-stu-id="ab192-123">Boolean</span></span>|--|
|<span data-ttu-id="ab192-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="ab192-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="ab192-125">String</span><span class="sxs-lookup"><span data-stu-id="ab192-125">String</span></span>|--|
|<span data-ttu-id="ab192-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="ab192-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="ab192-127">String</span><span class="sxs-lookup"><span data-stu-id="ab192-127">String</span></span>|<span data-ttu-id="ab192-128">Das Format dieser Typen in JSON entspricht dem Format in XML (im wesentlichen TimeSpan im Format der ISO 8601-Dauer, GUID im Format "12345678-ABCD-ABCD-ABCD-1234567890AB" und URI in der natürlichen Zeichen folgen Form wie " http://www.example.com ").</span><span class="sxs-lookup"><span data-stu-id="ab192-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="ab192-129">Genaue Informationen finden Sie unter [Daten Vertrags Schema-Referenz](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="ab192-130">String</span><span class="sxs-lookup"><span data-stu-id="ab192-130">String</span></span>|<span data-ttu-id="ab192-131">Das Format ist "name:namespace" (sämtliche Zeichen vor dem ersten Doppelpunkt bilden den Namen).</span><span class="sxs-lookup"><span data-stu-id="ab192-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="ab192-132">Der Name oder der Namespace kann fehlen.</span><span class="sxs-lookup"><span data-stu-id="ab192-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="ab192-133">Wenn kein Namespace angegeben wird, kann auch der Doppelpunkt weggelassen werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="ab192-134"><xref:System.Array> vom Typ <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="ab192-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="ab192-135">Array von Zahlen</span><span class="sxs-lookup"><span data-stu-id="ab192-135">Array of numbers</span></span>|<span data-ttu-id="ab192-136">Jede Zahl stellt den Wert eines Bytes dar.</span><span class="sxs-lookup"><span data-stu-id="ab192-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="ab192-137">DateTime oder Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="ab192-137">DateTime or String</span></span>|<span data-ttu-id="ab192-138">Siehe "Datums-/Uhrzeitangaben und JSON" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="ab192-139">Komplexer Typ</span><span class="sxs-lookup"><span data-stu-id="ab192-139">Complex type</span></span>|<span data-ttu-id="ab192-140">Siehe "Datums-/Uhrzeitangaben und JSON" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="ab192-141">XML- und ADO.NET-Typen (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="ab192-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="ab192-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="ab192-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="ab192-143">Arrays von <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="ab192-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="ab192-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="ab192-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="ab192-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="ab192-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="ab192-146">String</span><span class="sxs-lookup"><span data-stu-id="ab192-146">String</span></span>|<span data-ttu-id="ab192-147">Siehe den Abschnitt "XML-Typen und JSON" in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="ab192-148">Leerer komplexer Typ</span><span class="sxs-lookup"><span data-stu-id="ab192-148">Empty complex type</span></span>|--|
|<span data-ttu-id="ab192-149">Auflistungen, Wörterbücher und Arrays</span><span class="sxs-lookup"><span data-stu-id="ab192-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="ab192-150">Array</span><span class="sxs-lookup"><span data-stu-id="ab192-150">Array</span></span>|<span data-ttu-id="ab192-151">Siehe den Abschnitt "Auflistungen, Wörterbücher und Arrays" in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="ab192-152">Komplexe Typen (mit angewendetem <xref:System.Runtime.Serialization.DataContractAttribute> oder <xref:System.SerializableAttribute>)</span><span class="sxs-lookup"><span data-stu-id="ab192-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="ab192-153">Komplexer Typ</span><span class="sxs-lookup"><span data-stu-id="ab192-153">Complex type</span></span>|<span data-ttu-id="ab192-154">Datenmember werden Member des komplexen JavaScript-Typs.</span><span class="sxs-lookup"><span data-stu-id="ab192-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="ab192-155">Komplexe Typen (die die <xref:System.Runtime.Serialization.ISerializable>-Schnittstelle implementieren)</span><span class="sxs-lookup"><span data-stu-id="ab192-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="ab192-156">Komplexer Typ</span><span class="sxs-lookup"><span data-stu-id="ab192-156">Complex type</span></span>|<span data-ttu-id="ab192-157">Entspricht anderen komplexen Typen, jedoch werden einige <xref:System.Runtime.Serialization.ISerializable>-Typen nicht unterstützt. Weitere Informationen finden Sie in den Hinweisen zur ISerializable-Unterstützung im Abschnitt "Weitere Informationen" in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="ab192-158">`Null`-Wert für jeden Typ</span><span class="sxs-lookup"><span data-stu-id="ab192-158">`Null` value for any type</span></span>|<span data-ttu-id="ab192-159">NULL</span><span class="sxs-lookup"><span data-stu-id="ab192-159">Null</span></span>|<span data-ttu-id="ab192-160">Werttypen, die NULL-Werte zulassen, werden ebenfalls unterstützt und JSON-Code auf die gleiche Weise wie nicht auf NULL festleg Bare Werttypen</span><span class="sxs-lookup"><span data-stu-id="ab192-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="ab192-161">Enumerationen und JSON</span><span class="sxs-lookup"><span data-stu-id="ab192-161">Enumerations and JSON</span></span>

<span data-ttu-id="ab192-162">Enumerationsmemberwerte werden in JSON als Zahlen behandelt. Dies unterscheidet sich von ihrer Behandlung in Datenverträgen, in die sie als Membernamen eingefügt werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="ab192-163">Weitere Informationen zur Daten Vertrags Behandlung finden Sie unter [Enumerationstypen in Daten Verträgen](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="ab192-164">Wenn beispielsweise `public enum Color {red, green, blue, yellow, pink}` gegeben ist, ergibt die Serialisierung von `yellow` die Zahl&#160;3 und nicht die Zeichenfolge "yellow".</span><span class="sxs-lookup"><span data-stu-id="ab192-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="ab192-165">Alle `enum`-Member sind serialisierbar.</span><span class="sxs-lookup"><span data-stu-id="ab192-165">All `enum` members are serializable.</span></span> <span data-ttu-id="ab192-166">Die <xref:System.Runtime.Serialization.EnumMemberAttribute>-Klasse und die <xref:System.NonSerializedAttribute>-Attribute werden ignoriert, wenn sie verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="ab192-167">Es ist möglich, einen nicht vorhandenen `enum`-Wert zu deserialisieren. Der Wert 87 kann z.&#160;B. in den vorherigen Farbenumerationswert deserialisiert werden, auch wenn kein entsprechender Farbname definiert ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="ab192-168">Eine `enum` aus Flags stellt keinen Sonderfall dar und wird wie jede andere `enum` behandelt.</span><span class="sxs-lookup"><span data-stu-id="ab192-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="ab192-169">Datums-/Uhrzeitangaben und JSON</span><span class="sxs-lookup"><span data-stu-id="ab192-169">Dates/Times and JSON</span></span>

<span data-ttu-id="ab192-170">Das JSON-Format unterstützt Datums- und Zeitangaben nicht direkt.</span><span class="sxs-lookup"><span data-stu-id="ab192-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="ab192-171">Jedoch werden sie sehr häufig verwendet, und ASP.NET AJAX bietet eine spezielle Unterstützung dieser Typen.</span><span class="sxs-lookup"><span data-stu-id="ab192-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="ab192-172">Werden ASP.NET AJAX-Proxys verwendet, entspricht der <xref:System.DateTime>-Typ in .NET vollständig dem `DateTime`-Typ in JavaScript.</span><span class="sxs-lookup"><span data-stu-id="ab192-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="ab192-173">Wird ASP.NET nicht verwendet, wird ein <xref:System.DateTime>-Typ in JSON durch ein spezielles Zeichenfolgenformat dargestellt, das im Abschnitt "Weitere Informationen" in diesem Thema beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="ab192-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="ab192-174"><xref:System.DateTimeOffset> wird in JSON als komplexer Typ dargestellt: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="ab192-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="ab192-175">Der `offsetMinutes`-Member gibt den mit der Position des Ereignisses von Interesse verbundenen Ortszeitoffset zur GMT (Greenwich Mean Time) an. GMT wird jetzt auch als UTC (Coordinated Universal Time) bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ab192-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="ab192-176">Der `dateTime`-Member gibt den Zeitpunkt an, zu dem das betreffende Ereignis eingetreten ist (er wird wieder in einen `DateTime`-Typ in JavaScript umgewandelt, wenn ASP.NET AJAX verwendet wird; andernfalls wird er in eine Zeichenfolge umgewandelt).</span><span class="sxs-lookup"><span data-stu-id="ab192-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="ab192-177">Bei der Serialisierung wird der `dateTime`-Member immer in GMT serialisiert.</span><span class="sxs-lookup"><span data-stu-id="ab192-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="ab192-178">Wenn beispielsweise die Uhrzeit 3:00&#160;AM in der Zeitzone von New York beschrieben wird, dann enthält `dateTime` die Zeitangabe "8:00&#160;AM" und `offsetMinutes` den Wert "300" (minus 300&#160;Minuten oder 5&#160;Stunden gegenüber GMT).</span><span class="sxs-lookup"><span data-stu-id="ab192-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="ab192-179">Werden die Objekte <xref:System.DateTime> und <xref:System.DateTimeOffset> zu JSON serialisiert, behalten sie die Informationen nur mit Millisekundengenauigkeit bei.</span><span class="sxs-lookup"><span data-stu-id="ab192-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="ab192-180">Werte, die kleiner als Millisekunden (Mikro-/Nanosekunden) sind, gehen bei der Serialisierung verloren.</span><span class="sxs-lookup"><span data-stu-id="ab192-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="ab192-181">XML-Typen und JSON</span><span class="sxs-lookup"><span data-stu-id="ab192-181">XML Types and JSON</span></span>

<span data-ttu-id="ab192-182">XML-Typen werden zu JSON-Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="ab192-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="ab192-183">Wenn z. b. ein Datenmember "q" vom Typ "XElement" enthält \<abc/> , lautet der JSON-Code {"q": " \<abc/> "}.</span><span class="sxs-lookup"><span data-stu-id="ab192-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="ab192-184">Es gibt einige spezielle Regeln, die festlegen, wie XML eingebunden wird. Nähere Informationen dazu finden Sie im Abschnitt "Weitere Informationen" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="ab192-185">Wenn Sie mit ASP.NET AJAX arbeiten und in JavaScript keine Zeichenfolgen, sondern XML DOM verwenden möchten, legen Sie die <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A>-Eigenschaft für <xref:System.ServiceModel.Web.WebGetAttribute> oder die <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A>-Eigenschaft für <xref:System.ServiceModel.Web.WebInvokeAttribute> auf XML fest.</span><span class="sxs-lookup"><span data-stu-id="ab192-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="ab192-186">Auflistungen, Wörterbücher und Arrays</span><span class="sxs-lookup"><span data-stu-id="ab192-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="ab192-187">Alle Auflistungen, Wörterbücher und Arrays werden in JSON als Arrays dargestellt.</span><span class="sxs-lookup"><span data-stu-id="ab192-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="ab192-188">Jede Anpassung, in der das <xref:System.Runtime.Serialization.CollectionDataContractAttribute> verwendet wird, wird in der JSON-Darstellung ignoriert.</span><span class="sxs-lookup"><span data-stu-id="ab192-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="ab192-189">Wörterbücher stellen keine Möglichkeit dar, JSON-Daten direkt zu bearbeiten.</span><span class="sxs-lookup"><span data-stu-id="ab192-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="ab192-190">Das Wörterbuch \<string,object> wird in WCF möglicherweise nicht auf die gleiche Weise unterstützt wie bei der Arbeit mit anderen JSON-Technologien.</span><span class="sxs-lookup"><span data-stu-id="ab192-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="ab192-191">Wird beispielsweise in einem Wörterbuch "abc" dem Wert "xyz" und "def" dem Wert 42 zugeordnet, dann lautet die JSON-Darstellung nicht {"abc":"xyz","def":42}, sondern [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}].</span><span class="sxs-lookup"><span data-stu-id="ab192-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="ab192-192">Wenn Sie direkt mit JSON arbeiten möchten (also ohne vorher definierten strengen Vertrag auf Schlüssel und Werte dynamisch zugreifen möchten), stehen Ihnen mehrere Optionen zur Verfügung:</span><span class="sxs-lookup"><span data-stu-id="ab192-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="ab192-193">Verwenden Sie das Beispiel für eine [schwach typisierte JSON-Serialisierung (Ajax)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) .</span><span class="sxs-lookup"><span data-stu-id="ab192-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="ab192-194">Verwenden Sie die <xref:System.Runtime.Serialization.ISerializable>-Schnittstelle und Deserialisierungskonstruktoren. Diese beiden Mechanismen ermöglichen es Ihnen, bei der Serialisierung und der Deserialisierung auf JSON-Schlüssel/Wert-Paare zuzugreifen, was jedoch in teilweise vertrauenswürdigen Szenarien nicht möglich ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="ab192-195">Verwenden Sie [ggf. die Zuordnung zwischen JSON und XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) , anstatt einen Serialisierer zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="ab192-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="ab192-196">*Polymorphismus* im Kontext der Serialisierung bezieht sich auf die Fähigkeit, einen abgeleiteten Typ zu serialisieren, bei dem sein Basistyp erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="ab192-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="ab192-197">Es gelten spezielle JSON-spezifische Regeln für die polymorphe Verwendung von Auflistungen (beispielsweise die Zuweisung einer Auflistung zu einem <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="ab192-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="ab192-198">Dieser Punkt wird ausführlicher im Abschnitt "Weitere Informationen" weiter unten in diesem Thema erläutert.</span><span class="sxs-lookup"><span data-stu-id="ab192-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="ab192-199">Weitere Details</span><span class="sxs-lookup"><span data-stu-id="ab192-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="ab192-200">Reihenfolge der Datenmember</span><span class="sxs-lookup"><span data-stu-id="ab192-200">Order of Data Members</span></span>

<span data-ttu-id="ab192-201">Die Reihenfolge der Datenmember ist bei Verwendung von JSON nicht von Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="ab192-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="ab192-202">Insbesondere gilt: Auch wenn <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> festgelegt wird, können die JSON-Daten immer noch in jeder beliebigen Reihenfolge deserialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="ab192-203">JSON-Typen</span><span class="sxs-lookup"><span data-stu-id="ab192-203">JSON Types</span></span>

<span data-ttu-id="ab192-204">Der JSON-Typ muss bei der Deserialisierung nicht mit der vorangehenden Tabelle übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="ab192-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="ab192-205">Beispielsweise wird ein Wert vom Typ `Int` normalerweise einer JSON-Zahl zugeordnet, aber er kann auch aus einer JSON-Zeichenfolge deserialisiert werden, sofern diese Zeichenfolge eine gültige Zahl enthält.</span><span class="sxs-lookup"><span data-stu-id="ab192-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="ab192-206">Daher ist sowohl {"q":42} als auch {"q":"42"} zulässig, wenn ein `Int`-Datenmember namens "q" vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="ab192-207">Polymorphie</span><span class="sxs-lookup"><span data-stu-id="ab192-207">Polymorphism</span></span>

<span data-ttu-id="ab192-208">Polymorphe Serialisierung besteht aus der Fähigkeit, einen abgeleiteten Typ zu serialisieren, wo sein Basistyp erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="ab192-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="ab192-209">Dies wird für die JSON-Serialisierung von WCF unterstützt, vergleichbar mit der Unterstützung der XML-Serialisierung.</span><span class="sxs-lookup"><span data-stu-id="ab192-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="ab192-210">Beispielsweise können Sie serialisieren `MyDerivedType` , wo `MyBaseType` erwartet wird, oder serialisieren, `Int` wo `Object` erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="ab192-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="ab192-211">Typinformationen gehen möglicherweise verloren, wenn ein abgeleiteter Typ deserialisiert wird, wo der Basistyp erwartet wird, es sei denn, Sie deserialisieren einen komplexen Typ.</span><span class="sxs-lookup"><span data-stu-id="ab192-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="ab192-212">Wenn z.&#160;B. ein <xref:System.Uri> serialisiert wird, wo ein <xref:System.Object> erwartet wird, ergibt sich daraus eine JSON-Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="ab192-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="ab192-213">Wenn diese Zeichenfolge dann wieder in <xref:System.Object> zurück deserialisiert wird, wird ein .NET <xref:System.String> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="ab192-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="ab192-214">Das Deserialisierungsprogramm weiß nicht, dass die Zeichenfolge ursprünglich den Typ <xref:System.Uri> hatte.</span><span class="sxs-lookup"><span data-stu-id="ab192-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="ab192-215">Allgemein gilt: Wird ein <xref:System.Object> erwartet, werden alle JSON-Zeichenfolgen als .NET-Zeichenfolgen und alle JSON-Arrays, die zur Serialisierung von .NET-Auflistungen, -Wörterbüchern und -Arrays verwendet wurden, als .NET <xref:System.Array> des Typs <xref:System.Object> deserialisiert, unabhängig davon, welchen ursprünglichen Typ sie hatten.</span><span class="sxs-lookup"><span data-stu-id="ab192-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="ab192-216">Der JSON-Typ boolean wird dem .NET-Typ <xref:System.Boolean> zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="ab192-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="ab192-217">Wenn jedoch ein <xref:System.Object> erwartet wird, dann werden JSON-Zahlen in einen der .NET-Typen <xref:System.Int32>, <xref:System.Decimal> oder <xref:System.Double> serialisiert, wobei automatisch der am besten geeignete Typ ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="ab192-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="ab192-218">Beim Deserialisieren in einen Schnittstellentyp, deserialisiert der <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> die Daten so, als wäre ein Objekt als Typ deklariert.</span><span class="sxs-lookup"><span data-stu-id="ab192-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="ab192-219">Wenn Sie mit Ihren eigenen Basistyp und abgeleiteten Typen arbeiten, ist normalerweise die Verwendung von <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> oder eines äquivalenten Mechanismus erforderlich.</span><span class="sxs-lookup"><span data-stu-id="ab192-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="ab192-220">Wenn Sie z. b. einen-Vorgang haben, der über einen `Animal` Rückgabewert verfügt und tatsächlich eine Instanz von zurückgibt `Cat` (abgeleitet von `Animal` ), sollten Sie entweder den <xref:System.Runtime.Serialization.KnownTypeAttribute> auf den- `Animal` Typ oder den <xref:System.ServiceModel.ServiceKnownTypeAttribute> auf den-Vorgang anwenden und den `Cat` Typ in diesen Attributen angeben.</span><span class="sxs-lookup"><span data-stu-id="ab192-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="ab192-221">Weitere Informationen finden Sie unter [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="ab192-222">Weitere Informationen zur polymorphen Serialisierung und der Einschränkungen, die Sie bei der Verwendung beachten müssen, finden Sie im Abschnitt "Weitere Informationen" weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="ab192-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="ab192-223">Versionskontrolle</span><span class="sxs-lookup"><span data-stu-id="ab192-223">Versioning</span></span>

<span data-ttu-id="ab192-224">Die Datenvertragsversionsfunktionen werden einschließlich der <xref:System.Runtime.Serialization.IExtensibleDataObject>-Schnittstelle in JSON vollständig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ab192-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="ab192-225">Darüber hinaus ist es in den meisten Fällen möglich, einen Typ in ein Format (beispielsweise XML) zu deserialisieren, es dann in ein anderes Format (beispielsweise JSON) zu serialisieren und die Daten in <xref:System.Runtime.Serialization.IExtensibleDataObject> beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="ab192-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="ab192-226">Weitere Informationen finden Sie unter [Aufwärtskompatible Datenverträge](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="ab192-227">Denken Sie daran, dass JSON ungeordnet ist und daher alle Reihenfolgeninformationen verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="ab192-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="ab192-228">.JSON unterstützt auch keine mehrfachen Schlüssel/Wert-Paare mit dem gleichen Schlüsselnamen.</span><span class="sxs-lookup"><span data-stu-id="ab192-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="ab192-229">Und schließlich sind alle Vorgänge mit <xref:System.Runtime.Serialization.IExtensibleDataObject> grundsätzlich polymorph. Das bedeutet, dass ihr abgeleiteter Typ <xref:System.Object> zugewiesen ist, dem Basistyp aller Typen.</span><span class="sxs-lookup"><span data-stu-id="ab192-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="ab192-230">JSON in URLs</span><span class="sxs-lookup"><span data-stu-id="ab192-230">JSON in URLs</span></span>

<span data-ttu-id="ab192-231">Bei Verwendung von ASP.NET AJAX-Endpunkten mit dem HTTP-GET-Verb (wobei das <xref:System.ServiceModel.Web.WebGetAttribute>-Attribut verwendet wird) werden eingehende Parameter in der Anforderungs-URL statt im Nachrichtentext angegeben.</span><span class="sxs-lookup"><span data-stu-id="ab192-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="ab192-232">JSON wird auch in der Anforderungs-URL unterstützt. Wenn Sie also über einen Vorgang verfügen, der `Int` den Namen "Number" und einen `Person` komplexen Typ mit dem Namen "p" annimmt, kann die URL der folgenden URL ähneln.</span><span class="sxs-lookup"><span data-stu-id="ab192-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="ab192-233">Wenn Sie ein ASP.NET AJAX Script-Manager-Steuerelement und einen Proxy für den Aufruf des Diensts verwenden, wird diese URL automatisch vom Proxy erstellt und nicht erkannt.</span><span class="sxs-lookup"><span data-stu-id="ab192-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="ab192-234">JSON kann nicht in URLs auf Nicht-ASP.NET AJAX-Endpunkten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="ab192-235">Weiterführende Informationen</span><span class="sxs-lookup"><span data-stu-id="ab192-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="ab192-236">ISerializable-Unterstützung</span><span class="sxs-lookup"><span data-stu-id="ab192-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="ab192-237">Unterstützte und nicht unterstützte ISerializable-Typen</span><span class="sxs-lookup"><span data-stu-id="ab192-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="ab192-238">Im Allgemeinen werden Typen, die die <xref:System.Runtime.Serialization.ISerializable>-Schnittstelle implementieren, bei der Serialisierung oder Deserialisierung von JSON vollständig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ab192-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="ab192-239">Jedoch sind manche dieser Typen (einschließlich einiger .NET&#160;Framework-Typen) so implementiert, dass die JSON-spezifischen Serialisierungseigenheiten dazu führen, dass diese Typen nicht korrekt deserialisiert werden:</span><span class="sxs-lookup"><span data-stu-id="ab192-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="ab192-240">Mit <xref:System.Runtime.Serialization.ISerializable> ist der Typ einzelner Datenmember nicht im Voraus bekannt.</span><span class="sxs-lookup"><span data-stu-id="ab192-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="ab192-241">Dies führt zu einer polymorphen Situation ähnlich der Deserialisierung von Typen in ein Objekt.</span><span class="sxs-lookup"><span data-stu-id="ab192-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="ab192-242">Wie bereits erwähnt, führt dies in JSON möglicherweise zum Verlust der Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="ab192-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="ab192-243">Ein Typ z.&#160;B., der eine `enum` in seiner <xref:System.Runtime.Serialization.ISerializable>-Implementierung serialisiert und versucht, den erhaltenen Wert direkt wieder zurück in eine `enum` zu deserialisieren, wird ohne die korrekten Umwandlungen fehlschlagen, weil eine `enum` in JSON als Zahl serialisiert wird und JSON-Zahlen in die integrierten numerischen .NET-Typen (Int32, Decimal oder Double) deserialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="ab192-244">Deshalb geht die Tatsache, dass die verwendete Zahl ein `enum`-Wert war, verloren.</span><span class="sxs-lookup"><span data-stu-id="ab192-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="ab192-245">Ein <xref:System.Runtime.Serialization.ISerializable>-Typ, der in seinem Deserialisierungskonstruktor von einer bestimmten Reihenfolge der Deserialisierung abhängt, wird bei der Deserialisierung mancher JSON-Daten möglicherweise ebenfalls fehlschlagen, weil die meisten JSON-Serialisierungsprogramme keine bestimmte Reihenfolge gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="ab192-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="ab192-246">Factorytypen</span><span class="sxs-lookup"><span data-stu-id="ab192-246">Factory Types</span></span>

<span data-ttu-id="ab192-247">Während die <xref:System.Runtime.Serialization.IObjectReference>-Schnittstelle allgemein in JSON unterstützt wird, werden Typen, die die Funktion „Factorytyp“ benötigen (die Rückgabe eines anderen Typs von <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> als den Typ, der die Schnittstelle implementiert) nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ab192-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="ab192-248">DateTime-Übertragungsformat</span><span class="sxs-lookup"><span data-stu-id="ab192-248">DateTime Wire Format</span></span>

<span data-ttu-id="ab192-249"><xref:System.DateTime>-Werte werden als JSON-Zeichenfolgen im Format "/Date(700000+0500)/" dargestellt, wobei die erste Zahl (700000 in dem angeführten Beispiel) die Anzahl der seit Mitternacht des 1. Januar 1970 in der GMT-Zeitzone verstrichenen Millisekunden (ohne Berücksichtigung der Sommerzeit) angibt.</span><span class="sxs-lookup"><span data-stu-id="ab192-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="ab192-250">Die Zahl kann negativ sein und gibt dann einen früheren Zeitpunkt an.</span><span class="sxs-lookup"><span data-stu-id="ab192-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="ab192-251">Der im Beispiel als „+0500“ angegebene Teil ist optional und legt fest, dass die Zeitangabe als <xref:System.DateTimeKind.Local> zu verstehen ist, also bei der Deserialisierung in eine lokale Zeitzone konvertiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="ab192-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="ab192-252">Fehlt dieser Teil, wird die Zeitangabe als <xref:System.DateTimeKind.Utc> deserialisiert.</span><span class="sxs-lookup"><span data-stu-id="ab192-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="ab192-253">Die tatsächliche Zahl ("0500" in diesem Beispiel) und ihr Vorzeichen (+ oder -) werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="ab192-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="ab192-254">Bei der Serialisierung werden <xref:System.DateTime>-, <xref:System.DateTimeKind.Local>- und <xref:System.DateTimeKind.Unspecified>-Zeitangaben mit einem Offset und <xref:System.DateTimeKind.Utc>-Zeitangaben ohne Offset geschrieben.</span><span class="sxs-lookup"><span data-stu-id="ab192-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="ab192-255">Im JavaScript-Code eines ASP.NET AJAX-Clients werden solche Zeichenfolgen automatisch in `DateTime`-Instanzen für JavaScript konvertiert.</span><span class="sxs-lookup"><span data-stu-id="ab192-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="ab192-256">Andere Zeichenfolgen ähnlicher Form, die aber nicht vom .NET-Typ <xref:System.DateTime> sind, werden ebenfalls konvertiert.</span><span class="sxs-lookup"><span data-stu-id="ab192-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="ab192-257">Die Konvertierung findet nur statt, wenn die "/"-Zeichen mit Escapezeichen versehen werden (d. h., der JSON-Code sieht wie folgt aus \\ : "/Date (700000 + 0500) \\ /"), und aus diesem Grund wird <xref:System.ServiceModel.WebHttpBinding> das Zeichen "/" durch den JSON-Encoder von WCF (aktiviert durch) immer</span><span class="sxs-lookup"><span data-stu-id="ab192-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="ab192-258">XML in JSON-Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="ab192-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="ab192-259">XmlElement</span><span class="sxs-lookup"><span data-stu-id="ab192-259">XmlElement</span></span>

<span data-ttu-id="ab192-260">Der Typ <xref:System.Xml.XmlElement> wird ohne Einbindung serialisiert wie er ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="ab192-261">Beispielsweise wird das Datenelement "x" vom Typ <xref:System.Xml.XmlElement> , das enthält, \<abc/> wie folgt dargestellt:</span><span class="sxs-lookup"><span data-stu-id="ab192-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="ab192-262">XmlNode-Arrays</span><span class="sxs-lookup"><span data-stu-id="ab192-262">Arrays of XmlNode</span></span>

<span data-ttu-id="ab192-263"><xref:System.Array>-Objekte des Typs <xref:System.Xml.XmlNode> werden in ein Element namens ArrayOfXmlNode im Standardnamespace des Datenvertrags für den Typ eingebunden.</span><span class="sxs-lookup"><span data-stu-id="ab192-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="ab192-264">Ist "x" ein Array, das den Attributknoten "N" im Namespace "ns" enthält, der seinerseits "value" und den leeren Elementknoten "M" enthält, dann ergibt sich folgende Darstellung.</span><span class="sxs-lookup"><span data-stu-id="ab192-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="ab192-265">Attribute in einem leeren Namespace werden am Anfang von XmlNode-Arrays (vor anderen Elementen) nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ab192-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="ab192-266">IXmlSerializable-Typen, einschließlich XElement- und DataSet-Typen</span><span class="sxs-lookup"><span data-stu-id="ab192-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="ab192-267"><xref:System.Runtime.Serialization.ISerializable>-Typen teilen sich in "Inhaltstypen", "DataSet-Typen" und "Elementtypen".</span><span class="sxs-lookup"><span data-stu-id="ab192-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="ab192-268">Definitionen dieser Typen finden Sie unter [XML-und ADO.NET-Typen in Daten Verträgen](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="ab192-269">"Inhalts-" und "DataSet-Typen" werden ähnlich den <xref:System.Array>-Objekten von <xref:System.Xml.XmlNode>serialisiert, die im vorherigen Abschnitt erläutert wurden.</span><span class="sxs-lookup"><span data-stu-id="ab192-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="ab192-270">Sie werden in ein Element eingebunden, dessen Name und Namespace dem Datenvertragsnamen und dem Namespace des jeweiligen Typs entsprechen.</span><span class="sxs-lookup"><span data-stu-id="ab192-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="ab192-271">"Elementtypen", wie das <xref:System.Xml.Linq.XElement>, werden serialisiert wie sie sind, ähnlich wie das bereits in diesem Thema erläuterte <xref:System.Xml.XmlElement>.</span><span class="sxs-lookup"><span data-stu-id="ab192-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="ab192-272">Polymorphie</span><span class="sxs-lookup"><span data-stu-id="ab192-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="ab192-273">Bewahren von Typinformationen</span><span class="sxs-lookup"><span data-stu-id="ab192-273">Preserving Type Information</span></span>

<span data-ttu-id="ab192-274">Wie schon vorher festgestellt, wird Polymorphie in JSON mit einigen Einschränkungen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ab192-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="ab192-275">JavaScript ist eine schwach typisierte Sprache, und Typidentität stellt normalerweise kein Problem dar.</span><span class="sxs-lookup"><span data-stu-id="ab192-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="ab192-276">Wird jedoch JSON verwendet, um zwischen einem stark typisierten System (.NET) und einem schwach typisierten System (JavaScript) zu kommunizieren, ist es sinnvoll, die Typidentität zu bewahren.</span><span class="sxs-lookup"><span data-stu-id="ab192-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="ab192-277">Die Typen mit den Datenvertragsnamen "Square" und "Circle" sind beispielsweise von einem Typ mit dem Datenvertragsnamen "Shape" abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="ab192-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="ab192-278">Wenn "Circle" von .NET zu JavaScript gesendet und später wieder an eine .NET-Methode übergeben wird, die "Shape" erwartet, ist es für .NET sinnvoll zu wissen, dass das fragliche Objekt ursprünglich ein "Circle" war. Andernfalls gehen eventuell alle für den abgeleiteten Typ spezifischen Informationen (z. B. der Datenmember "radius" von "Circle") verloren.</span><span class="sxs-lookup"><span data-stu-id="ab192-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="ab192-279">Um bei der Serialisierung komplexer Typen zu JSON die Typidentität zu bewahren, kann ein "Typhinweis" hinzugefügt werden, den das Deserialisierungsprogramm erkennen und auf den es entsprechend reagieren kann.</span><span class="sxs-lookup"><span data-stu-id="ab192-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="ab192-280">Der "Type Hint" ist ein JSON-Schlüssel/Wert-Paar mit dem Schlüsselnamen " \_ \_ Type" (zwei Unterstriche, gefolgt vom Wort "Type").</span><span class="sxs-lookup"><span data-stu-id="ab192-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="ab192-281">Der Wert ist eine JSON-Zeichenfolge der Form "DataContractName:DataContractNamespace" (alles vor dem ersten Doppelpunkt bildet den Namen).</span><span class="sxs-lookup"><span data-stu-id="ab192-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="ab192-282">Bei dem schon früher verwendeten Beispiel kann "Circle" wie folgt serialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="ab192-283">Der Typhinweis ist dem von der standardmäßigen XML-Schemainstanz definierten und bei der Serialisierung oder Deserialisierung verwendeten `xsi:type`-Attribut sehr ähnlich.</span><span class="sxs-lookup"><span data-stu-id="ab192-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="ab192-284">Datenmember \_ \_ mit dem Namen "Type" sind aufgrund eines möglichen Konflikts mit dem Typhinweis unzulässig.</span><span class="sxs-lookup"><span data-stu-id="ab192-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="ab192-285">Reduzieren der Größe von Typhinweisen</span><span class="sxs-lookup"><span data-stu-id="ab192-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="ab192-286">Um die Größe von JSON-Nachrichten zu reduzieren, wird das standardmäßige Namespace Präfix für den Datenvertrag ( `http://schemas.datacontract.org/2004/07/` ) durch das Zeichen "#" ersetzt.</span><span class="sxs-lookup"><span data-stu-id="ab192-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="ab192-287">(Damit diese Ersetzung rückgängig gemacht werden kann, wird eine Escaperegel verwendet: Wenn der Namespace mit den Zeichen "#" oder " \\ " beginnt, wird er mit einem zusätzlichen \\ Zeichen "" versehen).</span><span class="sxs-lookup"><span data-stu-id="ab192-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="ab192-288">Wenn "Circle" ein Typ im .NET-Namespace "MyApp. Shapes" ist, lautet der standardmäßige Daten Vertrags Namespace `http://schemas.datacontract.org/2004/07/MyApp` .</span><span class="sxs-lookup"><span data-stu-id="ab192-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="ab192-289">Shapes und die JSON-Darstellung lautet wie folgt.</span><span class="sxs-lookup"><span data-stu-id="ab192-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="ab192-290">Die abgeschnittene (#MyApp. Shapes) und die vollständigen <http://schemas.datacontract.org/2004/07/MyApp.Shapes> Namen () werden bei der Deserialisierung verstanden.</span><span class="sxs-lookup"><span data-stu-id="ab192-290">Both the truncated (#MyApp.Shapes) and the full (<http://schemas.datacontract.org/2004/07/MyApp.Shapes>) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="ab192-291">Position des Typhinweises in JSON-Objekten</span><span class="sxs-lookup"><span data-stu-id="ab192-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="ab192-292">Beachten Sie, dass in der JSON-Darstellung der Typhinweis das erste Element sein muss.</span><span class="sxs-lookup"><span data-stu-id="ab192-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="ab192-293">Dies ist der einzige Fall, wo die Reihenfolge von Schlüssel/Wert-Paaren bei der JSON-Verarbeitung wichtig ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="ab192-294">Folgendes ist beispielsweise keine gültige Angabe des Typhinweises.</span><span class="sxs-lookup"><span data-stu-id="ab192-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="ab192-295">Die <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> von WCF-und ASP.NET AJAX-Client Seiten verwendete gibt immer zuerst den Typhinweis aus.</span><span class="sxs-lookup"><span data-stu-id="ab192-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="ab192-296">Typhinweise gelten nur für komplexe Typen</span><span class="sxs-lookup"><span data-stu-id="ab192-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="ab192-297">Es gibt keine Möglichkeit, einen Typhinweis für nicht-komplexe Typen auszugeben.</span><span class="sxs-lookup"><span data-stu-id="ab192-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="ab192-298">Hat z.&#160;B. ein Vorgang einen <xref:System.Object>-Rückgabetyp, gibt aber einen Circle-Typ zurück, entspricht die JSON-Darstellung wahrscheinlich der vorher gezeigten, und die Typinformationen werden beibehalten.</span><span class="sxs-lookup"><span data-stu-id="ab192-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="ab192-299">Wird jedoch ein URI-Typ zurückgegeben, ist die JSON-Darstellung eine Zeichenfolge, und die Tatsache, dass diese Zeichenfolge einen URI-Typ darstellt, geht verloren.</span><span class="sxs-lookup"><span data-stu-id="ab192-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="ab192-300">Dies gilt nicht nur für primitive Typen, sondern auch für Auflistungen und Arrays.</span><span class="sxs-lookup"><span data-stu-id="ab192-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="ab192-301">Wann Typhinweise ausgegeben werden</span><span class="sxs-lookup"><span data-stu-id="ab192-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="ab192-302">Typhinweise können die Nachrichtengröße beträchtlich erhöhen. Dieses Problem kann durch die Verwendung kürzerer Datenvertragsnamespaces (wenn möglich) vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="ab192-303">Deshalb bestimmen die folgenden Regeln, ob Typhinweise ausgegeben werden:</span><span class="sxs-lookup"><span data-stu-id="ab192-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="ab192-304">Bei Verwendung von ASP.NET AJAX werden Typhinweise nach Möglichkeit ausgegeben, auch wenn keine Zuweisung von Basistypen zu abgeleiteten Typen besteht. Dies gilt auch, wenn beispielsweise ein Circle einem Circle zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="ab192-305">(Dies ist erforderlich, um den Aufruf aus der schwach typisierten JSON-Umgebung in die stark typisierte .NET-Umgebung vollständig zu unterstützen und den versehentlichen Verlust von Informationen zu vermeiden.)</span><span class="sxs-lookup"><span data-stu-id="ab192-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="ab192-306">Bei Verwendung von AJAX-Diensten ohne ASP.NET-Integration werden Typhinweise nur dann ausgegeben, wenn es eine Zuweisung von Basistypen zu abgeleiteten Typen gibt &#8211; also wenn Circle einem Shape-Typ oder einem <xref:System.Object> zugewiesen ist, nicht aber, wenn Circle einem Circle zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="ab192-307">Dies stellt die zur korrekten Implementierung eines JavaScript-Clients notwendigen Mindestinformationen bereit und verbessert so die Leistung, schützt jedoch nicht vor dem Verlust von Typinformationen in nicht ordnungsgemäß implementierten Clients.</span><span class="sxs-lookup"><span data-stu-id="ab192-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="ab192-308">Vermeiden Sie Zuweisungen von Basistypen zu abgeleiteten Typen auf dem Server, damit Sie diese Probleme nicht beim Client behandeln müssen.</span><span class="sxs-lookup"><span data-stu-id="ab192-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="ab192-309">Wenn Sie den <xref:System.Runtime.Serialization.DataContractSerializer>-Typ verwenden, ermöglicht Ihnen der `alwaysEmitTypeInformation`-Parameter des Konstruktors, zwischen den beiden genannten Möglichkeiten zu wählen, wobei der Standard auf "`false`" festgelegt ist (Typhinweise nur wenn erforderlich ausgeben).</span><span class="sxs-lookup"><span data-stu-id="ab192-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="ab192-310">Doppelte Datenelementnamen</span><span class="sxs-lookup"><span data-stu-id="ab192-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="ab192-311">Im JSON-Objekt sind Informationen des abgeleiteten Typs zusammen mit denen des Basistyps in beliebiger Reihenfolge vorhanden.</span><span class="sxs-lookup"><span data-stu-id="ab192-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="ab192-312">Beispielsweise `Shape` kann wie folgt dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="ab192-313">Circle wird dagegen möglicherweise wie folgt dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ab192-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="ab192-314">Wenn der `Shape` Basistyp auch einen Datenmember mit dem Namen " `radius` " enthält, führt dies zu einem Konflikt bei beiden Serialisierungen (weil JSON-Objekte keine sich wiederholenden Schlüsselnamen aufweisen dürfen) und Deserialisierung (da unklar ist, ob "Radius" auf `Shape.radius` oder verweist `Circle.radius` ).</span><span class="sxs-lookup"><span data-stu-id="ab192-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="ab192-315">Daher ist das Konzept des "Verbergens von Eigenschaften" (Datenmember mit gleichen Namen in der Basisklassen und in abgeleiteten Klassen), das in Datenvertragsklassen generell nicht empfohlen wird, im Fall von JSON sogar unzulässig.</span><span class="sxs-lookup"><span data-stu-id="ab192-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="ab192-316">Polymorphie und IXmlSerializable-Typen</span><span class="sxs-lookup"><span data-stu-id="ab192-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="ab192-317"><xref:System.Xml.Serialization.IXmlSerializable>-Typen können polymorph einander zugewiesen werden, solange die Anforderungen für bekannte Typen entsprechend den üblichen Datenvertragsregeln eingehalten werden.</span><span class="sxs-lookup"><span data-stu-id="ab192-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="ab192-318">Die Serialisierung eines <xref:System.Xml.Serialization.IXmlSerializable>-Typs statt eines <xref:System.Object>-Typs führt zu einem Verlust von Typinformationen, da das Ergebnis eine JSON-Zeichenfolge ist.</span><span class="sxs-lookup"><span data-stu-id="ab192-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="ab192-319">Polymorphie und bestimmte Schnittstellentypen</span><span class="sxs-lookup"><span data-stu-id="ab192-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="ab192-320">Es ist nicht zulässig, einen Auflistungstyp oder einen Typ, der <xref:System.Xml.Serialization.IXmlSerializable> implementiert, zu serialisieren, wenn ein Nicht-Auflistungstyp erwartet wird, der nicht <xref:System.Xml.Serialization.IXmlSerializable> ist (ausgenommen <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="ab192-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="ab192-321">Beispielsweise eine benutzerdefinierte Schnittstelle `IMyInterface` mit dem Namen und ein Typ `MyType` , die sowohl den <xref:System.Collections.Generic.IEnumerable%601> Typ `int` als auch implementieren `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="ab192-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="ab192-322">Es ist unzulässig, `MyType` von einem Vorgang zurückzugeben, dessen Rückgabetyp ist `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="ab192-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="ab192-323">Der Grund hierfür ist `MyType` , dass als JSON-Array serialisiert werden muss und einen Typhinweis erfordert. wie bereits erwähnt, ist es nicht möglich, einen Typhinweis mit Arrays aufzunehmen, sondern nur mit komplexen Typen.</span><span class="sxs-lookup"><span data-stu-id="ab192-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="ab192-324">Bekannte Typen und Konfiguration</span><span class="sxs-lookup"><span data-stu-id="ab192-324">Known Types and Configuration</span></span>

<span data-ttu-id="ab192-325">Der gesamte vom <xref:System.Runtime.Serialization.DataContractSerializer> verwendete Mechanismus bekannter Typen wird auf gleiche Weise auch vom <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ab192-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="ab192-326">Beide serialisierungssoren haben das gleiche Konfigurationselement in gelesen, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md) um bekannte Typen zu ermitteln, die über eine Konfigurationsdatei hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="ab192-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="ab192-327">Objekten zugewiesene Auflistungen</span><span class="sxs-lookup"><span data-stu-id="ab192-327">Collections Assigned to Object</span></span>

<span data-ttu-id="ab192-328">Objekten zugewiesene Auflistungen werden so serialisiert als handele es sich um Auflistungen, die <xref:System.Collections.Generic.IEnumerable%601> implementieren: als JSON-Array, bei dem jeder Eintrag einen Typhinweis besitzt, als wäre er ein komplexer Typ.</span><span class="sxs-lookup"><span data-stu-id="ab192-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="ab192-329">Beispielsweise sieht eine <xref:System.Collections.Generic.List%601> vom Typ, `Shape` die zugewiesen ist, <xref:System.Object> wie folgt aus.</span><span class="sxs-lookup"><span data-stu-id="ab192-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="ab192-330">Wenn es wieder in ein <xref:System.Object> deserialisiert wird:</span><span class="sxs-lookup"><span data-stu-id="ab192-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="ab192-331">`Shape`muss in der Liste der bekannten Typen enthalten sein.</span><span class="sxs-lookup"><span data-stu-id="ab192-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="ab192-332">Das vorhanden sein <xref:System.Collections.Generic.List%601> des Typs `Shape` in bekannten Typen hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="ab192-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="ab192-333">Beachten Sie, dass Sie `Shape` in diesem Fall bei der Serialisierung nicht bekannten Typen hinzufügen müssen. Dies erfolgt automatisch.</span><span class="sxs-lookup"><span data-stu-id="ab192-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="ab192-334">Die-Auflistung wird als vom Typ deserialisiert, der- <xref:System.Array> <xref:System.Object> `Shape` Instanzen enthält.</span><span class="sxs-lookup"><span data-stu-id="ab192-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="ab192-335">Abgeleitete Auflistungen, die Basisauflistungen zugewiesen sind</span><span class="sxs-lookup"><span data-stu-id="ab192-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="ab192-336">Wenn eine abgeleitete Auflistung einer Basisauflistung zugewiesen ist, wird die Auflistung normalerweise so serialisiert, als wäre sie eine Auflistung des Basistyps.</span><span class="sxs-lookup"><span data-stu-id="ab192-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="ab192-337">Kann jedoch der Elementtyp der abgeleiteten Auflistung nicht dem Elementtyp der Basisauflistung zugewiesen werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ab192-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="ab192-338">Typhinweise und Wörterbücher</span><span class="sxs-lookup"><span data-stu-id="ab192-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="ab192-339">Wenn ein Wörterbuch einem <xref:System.Object> zugewiesen ist, wird jeder Schlüssel- und Werteintrag des Wörterbuchs so behandelt, als wäre er <xref:System.Object> zugewiesen, und erhält einen Typhinweis.</span><span class="sxs-lookup"><span data-stu-id="ab192-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="ab192-340">Bei der Serialisierung von Wörterbuchtypen, wird das JSON-Objekt, das die Member "Key" und "Value" enthält, von der `alwaysEmitTypeInformation`-Einstellung nicht betroffen und erhält nur dann einen Typhinweis, wenn die oben genannten Auflistungsregeln dies erfordern.</span><span class="sxs-lookup"><span data-stu-id="ab192-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="ab192-341">Gültige JSON-Schlüsselnamen</span><span class="sxs-lookup"><span data-stu-id="ab192-341">Valid JSON Key Names</span></span>

<span data-ttu-id="ab192-342">Das Serialisierungsprogramm codiert Schlüsselnamen in XML, die keine gültigen XML-Namen sind.</span><span class="sxs-lookup"><span data-stu-id="ab192-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="ab192-343">Ein Datenmember mit dem Namen "123" hätte z. b. einen codierten Namen wie z. b. " \_ x0031 \_ \_ x0032 \_ \_ x0033 \_ ", da "123" ein ungültiger XML-Elementname ist (beginnt mit einer Ziffer).</span><span class="sxs-lookup"><span data-stu-id="ab192-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="ab192-344">Eine ähnliche Situation tritt möglicherweise bei einigen internationalen Zeichensätzen auf, deren Verwendung ungültige XML-Namen ergibt.</span><span class="sxs-lookup"><span data-stu-id="ab192-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="ab192-345">Eine Erläuterung dieser Auswirkungen von XML auf die JSON-Verarbeitung finden Sie unter [Mapping zwischen JSON und XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="ab192-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="ab192-346">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="ab192-346">See also</span></span>

- [<span data-ttu-id="ab192-347">Unterstützung für JSON und andere Datenübertragungsformate</span><span class="sxs-lookup"><span data-stu-id="ab192-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
