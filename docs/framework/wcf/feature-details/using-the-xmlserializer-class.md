---
title: Verwenden der XmlSerializer-Klasse
description: Erfahren Sie mehr über das XmlSerializer-Element, das WCF verwendet, um die Daten in Ihrer Anwendung in XML zu serialisieren, das zwischen Clients und Diensten übertragen wird.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: f7473de3f34ba543b4fabfe93167ea267f16dda5
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246380"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="68224-103">Verwenden der XmlSerializer-Klasse</span><span class="sxs-lookup"><span data-stu-id="68224-103">Using the XmlSerializer Class</span></span>

<span data-ttu-id="68224-104">Windows Communication Foundation (WCF) kann zwei verschiedene Serialisierungstechnologien verwenden, um die Daten in der Anwendung in XML umzuwandeln, das zwischen Clients und Diensten übertragen wird, einem Prozess, der als Serialisierung bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="68224-104">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="68224-105">DataContractSerializer als Standard</span><span class="sxs-lookup"><span data-stu-id="68224-105">DataContractSerializer as the Default</span></span>

<span data-ttu-id="68224-106">WCF verwendet standardmäßig die- <xref:System.Runtime.Serialization.DataContractSerializer> Klasse, um Datentypen zu serialisieren.</span><span class="sxs-lookup"><span data-stu-id="68224-106">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="68224-107">Dieses Serialisierungsprogramm unterstützt die folgenden Typen:</span><span class="sxs-lookup"><span data-stu-id="68224-107">This serializer supports the following types:</span></span>

- <span data-ttu-id="68224-108">Primitive Typen (z. B. ganze Zahlen, Zeichenfolgen und Bytearrays) sowie einige spezielle Typen wie <xref:System.Xml.XmlElement> und <xref:System.DateTime>, die als Primitive behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="68224-108">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="68224-109">Datenvertragstypen (mit dem <xref:System.Runtime.Serialization.DataContractAttribute>-Attribut markierte Typen).</span><span class="sxs-lookup"><span data-stu-id="68224-109">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="68224-110">Mit dem <xref:System.SerializableAttribute>-Attribut markierte Typen, einschließlich Typen, die die <xref:System.Runtime.Serialization.ISerializable>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="68224-110">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="68224-111">Typen, die die <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="68224-111">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="68224-112">Viele allgemeine Auflistungstypen, einschließlich vieler generischer Auflistungstypen.</span><span class="sxs-lookup"><span data-stu-id="68224-112">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="68224-113">Viele .NET Framework Typen fallen in die beiden letzteren Kategorien und sind daher serialisierbar.</span><span class="sxs-lookup"><span data-stu-id="68224-113">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="68224-114">Arrays serialisierbarer Typen sind ebenfalls serialisierbar.</span><span class="sxs-lookup"><span data-stu-id="68224-114">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="68224-115">Eine umfassende Liste finden Sie unter [Angeben von Datenübertragung in Dienstverträgen](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="68224-115">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="68224-116">Der <xref:System.Runtime.Serialization.DataContractSerializer> , der in Verbindung mit Daten Vertragstypen verwendet wird, ist die empfohlene Methode zum Schreiben neuer WCF-Dienste.</span><span class="sxs-lookup"><span data-stu-id="68224-116">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="68224-117">Weitere Informationen finden Sie unter [Verwenden von Daten Verträgen](using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="68224-117">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="68224-118">Verwendung der XmlSerializer-Klasse</span><span class="sxs-lookup"><span data-stu-id="68224-118">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="68224-119">WCF unterstützt auch die- <xref:System.Xml.Serialization.XmlSerializer> Klasse.</span><span class="sxs-lookup"><span data-stu-id="68224-119">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="68224-120">Die- <xref:System.Xml.Serialization.XmlSerializer> Klasse ist nicht für WCF eindeutig.</span><span class="sxs-lookup"><span data-stu-id="68224-120">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="68224-121">Es handelt sich um das gleiche Serialisierungsmodul, das ASP.NET-Webdienste verwenden.</span><span class="sxs-lookup"><span data-stu-id="68224-121">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="68224-122">Die <xref:System.Xml.Serialization.XmlSerializer>-Klasse unterstützt deutlich weniger Typen als die <xref:System.Runtime.Serialization.DataContractSerializer>-Klasse, ermöglicht jedoch eine größere Kontrolle über das resultierende XML und unterstützt den XSD-Schemastandard (XML Schema definition language) stärker.</span><span class="sxs-lookup"><span data-stu-id="68224-122">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="68224-123">Sie erfordert außerdem keine deklarativen Attribute für die serialisierbaren Typen.</span><span class="sxs-lookup"><span data-stu-id="68224-123">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="68224-124">Weitere Informationen finden Sie im Thema zur XML-Serialisierung in der .NET Framework-Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="68224-124">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="68224-125">Die <xref:System.Xml.Serialization.XmlSerializer>-Klasse unterstützt keine Datenvertragstypen.</span><span class="sxs-lookup"><span data-stu-id="68224-125">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="68224-126">Wenn Sie Svcutil.exe oder das **Dienstverweis hinzufügen** Feature in Visual Studio zum Generieren von Client Code für einen Drittanbieter Dienst oder zum Zugreifen auf ein Drittanbieter Schema verwenden, wird automatisch ein geeignetes Serialisierungsprogramm für Sie ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="68224-126">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="68224-127">Wenn das Schema nicht mit <xref:System.Runtime.Serialization.DataContractSerializer> kompatibel ist, wird <xref:System.Xml.Serialization.XmlSerializer> ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="68224-127">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="68224-128">Manuelles Wechseln zu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="68224-128">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="68224-129">Es kann vorkommen, dass Sie manuell zu <xref:System.Xml.Serialization.XmlSerializer> wechseln müssen.</span><span class="sxs-lookup"><span data-stu-id="68224-129">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="68224-130">Dies ist beispielsweise in den folgenden Situationen der Fall:</span><span class="sxs-lookup"><span data-stu-id="68224-130">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="68224-131">Beim Migrieren einer Anwendung von ASP.NET-Webdiensten zu WCF empfiehlt es sich, vorhandene, <xref:System.Xml.Serialization.XmlSerializer> -kompatible Typen wiederzuverwenden, anstatt neue Daten Vertragstypen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="68224-131">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="68224-132">Wenn die präzise Steuerung von in Nachrichten enthaltenen XML-Daten wichtig ist, jedoch kein WSDL (Web Services Description Language)-Dokument zur Verfügung steht, z.&#160;B. beim Erstellen eines Diensts mit Typen, die einem bestimmten standardisierten, veröffentlichten Schema entsprechen müssen, das nicht mit dem DataContractSerializer kompatibel ist.</span><span class="sxs-lookup"><span data-stu-id="68224-132">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="68224-133">Beim Erstellen von Diensten, die dem älteren SOAP-Codierungsstandard folgen.</span><span class="sxs-lookup"><span data-stu-id="68224-133">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="68224-134">In diesen und anderen Fällen können Sie manuell zur <xref:System.Xml.Serialization.XmlSerializer>-Klasse wechseln, indem Sie das `XmlSerializerFormatAttribute`-Attribut auf den Dienst anwenden, wie im folgenden Code dargestellt.</span><span class="sxs-lookup"><span data-stu-id="68224-134">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="68224-135">Überlegungen zur Sicherheit</span><span class="sxs-lookup"><span data-stu-id="68224-135">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="68224-136">Beim Wechseln von Serialisierungs-Engines ist große Sorgfalt geboten.</span><span class="sxs-lookup"><span data-stu-id="68224-136">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="68224-137">Derselbe Typ kann je nach verwendetem Serialisierungsprogramm mehrere Serialisierungskonzepte umfassen.</span><span class="sxs-lookup"><span data-stu-id="68224-137">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="68224-138">Wenn Sie versehentlich das falsche Serialisierungsprogramm verwenden, legen Sie möglicherweise Informationen aus dem Typ offen, deren Offenlegung Sie nicht beabsichtigt haben.</span><span class="sxs-lookup"><span data-stu-id="68224-138">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="68224-139">Beispielsweise serialisiert die <xref:System.Runtime.Serialization.DataContractSerializer>-Klasse beim Serialisieren von Datenvertragstypen nur mit dem <xref:System.Runtime.Serialization.DataMemberAttribute>-Attribut markierte Member.</span><span class="sxs-lookup"><span data-stu-id="68224-139">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="68224-140">Die <xref:System.Xml.Serialization.XmlSerializer>-Klasse serialisiert jeden öffentlichen Member.</span><span class="sxs-lookup"><span data-stu-id="68224-140">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="68224-141">Beachten Sie den Typ im folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="68224-141">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="68224-142">Wenn der Typ versehentlich in einem Dienstvertrag verwendet wird, in dem die <xref:System.Xml.Serialization.XmlSerializer>-Klasse ausgewählt ist, wird der `creditCardNumber`-Member serialisiert, was wahrscheinlich nicht beabsichtigt ist.</span><span class="sxs-lookup"><span data-stu-id="68224-142">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="68224-143">Auch wenn die <xref:System.Runtime.Serialization.DataContractSerializer>-Klasse der Standard ist, können Sie sie explizit für Ihren Dienst auswählen (obwohl dies nie erforderlich sein sollte), indem Sie das <xref:System.ServiceModel.DataContractFormatAttribute>-Attribut auf den Dienstvertragstyp anwenden.</span><span class="sxs-lookup"><span data-stu-id="68224-143">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="68224-144">Das für den Dienst verwendete Serialisierungsprogramm ist ein wesentlicher Bestandteil des Vertrags und kann durch Auswahl einer anderen Bindung oder durch Ändern anderer Konfigurationseinstellungen nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="68224-144">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="68224-145">Andere wichtige Sicherheitsüberlegungen gelten für die <xref:System.Xml.Serialization.XmlSerializer>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="68224-145">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="68224-146">Zuerst wird dringend empfohlen, dass jede WCF-Anwendung, die die-Klasse verwendet, <xref:System.Xml.Serialization.XmlSerializer> mit einem Schlüssel signiert wird, der von der-Offenlegung geschützt wird.</span><span class="sxs-lookup"><span data-stu-id="68224-146">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="68224-147">Diese Empfehlung gilt sowohl für das manuelle Wechseln zu <xref:System.Xml.Serialization.XmlSerializer> als auch ein automatisches Wechseln (mit Svcutil.exe, "Dienstverweis hinzufügen" oder ein ähnliches Tool).</span><span class="sxs-lookup"><span data-stu-id="68224-147">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="68224-148">Dies liegt daran, dass das <xref:System.Xml.Serialization.XmlSerializer> Serialisierungsmodul das Laden von *vorgenerierten Serialisierungsassemblys* unterstützt, sofern diese mit demselben Schlüssel wie die Anwendung signiert sind.</span><span class="sxs-lookup"><span data-stu-id="68224-148">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="68224-149">Eine nicht signierte Anwendung ist vollständig ungeschützt gegen die Möglichkeit, dass eine bösartige Assembly, die mit dem erwarteten Namen der vorgenerierten Serialisierungsassembly übereinstimmt, im Anwendungsordner oder im globalen Assemblycache platziert wird.</span><span class="sxs-lookup"><span data-stu-id="68224-149">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="68224-150">Natürlich muss ein Angreifer zuerst Schreibzugriff auf einen der beiden Speicherorte erhalten, um diese Aktion auszuführen.</span><span class="sxs-lookup"><span data-stu-id="68224-150">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="68224-151">Eine weitere Bedrohung, die beim Verwenden von <xref:System.Xml.Serialization.XmlSerializer> vorhanden ist, hängt mit dem Schreibzugriff auf den temporären Ordners des Systems zusammen.</span><span class="sxs-lookup"><span data-stu-id="68224-151">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="68224-152">Die <xref:System.Xml.Serialization.XmlSerializer> Serialisierungs-Engine erstellt und verwendet temporäre *Serialisierungsassemblys* in diesem Ordner.</span><span class="sxs-lookup"><span data-stu-id="68224-152">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="68224-153">Sie sollten sich der Tatsache bewusst sein, dass jeder Vorgang mit Schreibzugriff auf den temporären Ordner diese Serialisierungsassemblys mit bösartigem Code überschreiben kann.</span><span class="sxs-lookup"><span data-stu-id="68224-153">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="68224-154">Regeln für XmlSerializer-Unterstützung</span><span class="sxs-lookup"><span data-stu-id="68224-154">Rules for XmlSerializer support</span></span>

<span data-ttu-id="68224-155">Sie können mit <xref:System.Xml.Serialization.XmlSerializer> kompatible Attribute nicht direkt auf Vertragsvorgangsparameter oder Rückgabewerte anwenden.</span><span class="sxs-lookup"><span data-stu-id="68224-155">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="68224-156">Sie können jedoch auf typisierte Nachrichten (Nachrichtenvertragstextteile) angewendet werden, wie der folgende Code zeigt:</span><span class="sxs-lookup"><span data-stu-id="68224-156">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="68224-157">Beim Anwenden auf typisierte Nachrichtenmember überschreiben diese Attribute Eigenschaften, die mit den typisierten Nachrichtenattributen in Konflikt stehen.</span><span class="sxs-lookup"><span data-stu-id="68224-157">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="68224-158">Beispielsweise wird im folgenden Code `ElementName` durch `Name` überschrieben.</span><span class="sxs-lookup"><span data-stu-id="68224-158">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="68224-159">Das <xref:System.ServiceModel.MessageHeaderArrayAttribute>-Attribut wird nicht unterstützt, wenn <xref:System.Xml.Serialization.XmlSerializer> verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="68224-159">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="68224-160">In diesem Fall löst die <xref:System.Xml.Serialization.XmlSerializer> folgende Ausnahme aus, die vor WCF freigegeben wird: "ein Element, das auf der obersten Schema Ebene deklariert wurde, kann nicht über `maxOccurs` > 1 verfügen.</span><span class="sxs-lookup"><span data-stu-id="68224-160">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="68224-161">Geben Sie ein Wrapperelement für "more" an, indem Sie `XmlArray` oder `XmlArrayItem` anstelle von `XmlElementAttribute` verwenden oder indem Sie den Wrapped-Parameterstil verwenden.</span><span class="sxs-lookup"><span data-stu-id="68224-161">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="68224-162">Wenn Sie eine solche Ausnahme empfangen, prüfen Sie, ob diese Situation zutrifft.</span><span class="sxs-lookup"><span data-stu-id="68224-162">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="68224-163">WCF unterstützt das <xref:System.Xml.Serialization.SoapIncludeAttribute> -Attribut und das- <xref:System.Xml.Serialization.XmlIncludeAttribute> Attribut in Nachrichten Verträgen und Vorgangs Verträgen nicht. verwenden Sie stattdessen das- <xref:System.Runtime.Serialization.KnownTypeAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="68224-163">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="68224-164">Typen, die die IXmlSerializable-Schnittstelle implementieren</span><span class="sxs-lookup"><span data-stu-id="68224-164">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="68224-165">Typen, die die `IXmlSerializable`-Schnittstelle implementieren, werden von `DataContractSerializer` vollständig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="68224-165">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="68224-166">Sie sollten das <xref:System.Xml.Serialization.XmlSchemaProviderAttribute>-Attribut immer auf diese Typen anwenden, um das dazugehörige Schema zu steuern.</span><span class="sxs-lookup"><span data-stu-id="68224-166">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="68224-167">Wenn Sie polymorphe Typen verwenden, müssen Sie <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> auf den Typ anwenden, um sicherzustellen, dass der richtige Typ serialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="68224-167">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="68224-168">Es gibt drei Varianten von Typen, die `IXmlSerializable` implementieren: Typen, die beliebigen Inhalt darstellen, Typen, die ein einzelnes Element darstellen, und ältere <xref:System.Data.DataSet>-Typen.</span><span class="sxs-lookup"><span data-stu-id="68224-168">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="68224-169">Inhaltstypen verwenden eine vom `XmlSchemaProviderAttribute`-Attribut angegebene Schemaanbietermethode.</span><span class="sxs-lookup"><span data-stu-id="68224-169">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="68224-170">Die Methode gibt nicht `null` zurück, und die <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A>-Eigenschaft des Attributs wird auf ihrem Standardwert `false` belassen.</span><span class="sxs-lookup"><span data-stu-id="68224-170">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="68224-171">Dies ist die häufigste Verwendung von `IXmlSerializable`-Typen.</span><span class="sxs-lookup"><span data-stu-id="68224-171">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="68224-172">Elementtypen werden verwendet, wenn ein `IXmlSerializable`-Typ seinen eigenen Stammelementnamen kontrollieren muss.</span><span class="sxs-lookup"><span data-stu-id="68224-172">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="68224-173">Um einen Typ als Elementtyp zu kennzeichnen, legen Sie entweder die <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A>-Eigenschaft des <xref:System.Xml.Serialization.XmlSchemaProviderAttribute>-Attributs auf `true` fest, oder geben Sie über die Schemaanbietermethode `null` zurück.</span><span class="sxs-lookup"><span data-stu-id="68224-173">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="68224-174">Die Verwendung einer Schemaanbietermethode ist für Elementtypen optional. Sie können unter `null` anstatt des Methodennamens auch `XmlSchemaProviderAttribute` angeben.</span><span class="sxs-lookup"><span data-stu-id="68224-174">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="68224-175">Wenn `IsAny` jedoch `true` ist und eine Schemaanbietermethode angegeben ist, muss die Methode `null` zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="68224-175">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="68224-176">Bei älteren <xref:System.Data.DataSet>-Typen handelt es sich um `IXmlSerializable`-Typen, die nicht mit dem `XmlSchemaProviderAttribute`-Attribut gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="68224-176">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="68224-177">Stattdessen verwenden sie zur Schemagenerierung die <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="68224-177">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="68224-178">Dieses Muster wird für den `DataSet`-Typ und seine von ihm abgeleiteten typisierten Dataset-Klassen in älteren Versionen von .NET Framework verwendet. Es ist jedoch veraltet und wird nur aus Legacygründen noch unterstützt.</span><span class="sxs-lookup"><span data-stu-id="68224-178">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="68224-179">Verlassen Sie sich nicht auf dieses Muster, und wenden Sie immer das `XmlSchemaProviderAttribute` auf Ihre `IXmlSerializable`-Typen an.</span><span class="sxs-lookup"><span data-stu-id="68224-179">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="68224-180">IXmlSerializable-Inhaltstypen</span><span class="sxs-lookup"><span data-stu-id="68224-180">IXmlSerializable Content Types</span></span>

<span data-ttu-id="68224-181">Wenn Sie einen Datenmember eines Typs serialisieren, der `IXmlSerializable` implementiert und ein wie zuvor definierter Inhaltstyp ist, schreibt das Serialisierungsprogramm das Wrapperelement für den Datenmember und übergibt die Steuerung an die <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="68224-181">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="68224-182">Die <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>-Implementierung kann beliebige XML-Daten schreiben, auch zum Hinzufügen der Attribute zum Wrapperelement.</span><span class="sxs-lookup"><span data-stu-id="68224-182">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="68224-183">Nachdem `WriteXml` abgeschlossen ist, schließt das Serialisierungsprogramm das Element.</span><span class="sxs-lookup"><span data-stu-id="68224-183">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="68224-184">Wenn Sie einen Datenmember eines Typs deserialisieren, der `IXmlSerializable` implementiert und ein wie zuvor definierter Inhaltstyp ist, ordnet das Deserialisierungsprogramm den XML-Reader im Wrapperelement für den Datenmember an und übergibt die Steuerung an die <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="68224-184">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="68224-185">Die Methode muss das ganze Element lesen, einschließlich des Start- und Endtags.</span><span class="sxs-lookup"><span data-stu-id="68224-185">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="68224-186">Stellen Sie sicher, dass der `ReadXml`-Code auch den Fall verarbeitet, in dem das Element leer ist.</span><span class="sxs-lookup"><span data-stu-id="68224-186">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="68224-187">Außerdem sollte sich Ihre `ReadXml`-Implementierung nicht darauf verlassen, dass das Wrapperelement einen bestimmten Namen aufweist.</span><span class="sxs-lookup"><span data-stu-id="68224-187">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="68224-188">Der Name wird vom Serialisierungsprogramm ausgewählt und kann variieren.</span><span class="sxs-lookup"><span data-stu-id="68224-188">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="68224-189">Es ist zulässig, `IXmlSerializable`-Inhaltstypen polymorph zuzuweisen, zum Beispiel zu Datenmembern vom Typ <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="68224-189">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="68224-190">Es ist auch zulässig, dass die Typinstanzen NULL sind.</span><span class="sxs-lookup"><span data-stu-id="68224-190">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="68224-191">Außerdem ist es möglich, `IXmlSerializable`-Typen bei aktivierter Objektdiagrammbeibehaltung und mit <xref:System.Runtime.Serialization.NetDataContractSerializer> zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="68224-191">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="68224-192">Alle diese Features erfordern, dass das WCF-Serialisierungsprogramm bestimmte Attribute in das Wrapper Element ("Nil" und "Type" im XML-Schema Instanz-Namespace und "ID", "ref", "Type" und "Assembly" in einem WCF-spezifischen Namespace anfügt).</span><span class="sxs-lookup"><span data-stu-id="68224-192">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="68224-193">Bei der Implementierung von ReadXml zu ignorierende Attribute</span><span class="sxs-lookup"><span data-stu-id="68224-193">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="68224-194">Bevor die Steuerung an Ihren `ReadXml`-Code übergeben wird, untersucht das Deserialisierungsprogramm das XML-Element, erkennt diese speziellen XML-Attribute und führt die erforderlichen Aktionen aus.</span><span class="sxs-lookup"><span data-stu-id="68224-194">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="68224-195">Wenn "nil" zum Beispiel `true` ist, wird ein Nullwert deserialisiert, und `ReadXml` wird nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="68224-195">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="68224-196">Falls Polymorphie erkannt wird, wird der Inhalt des Elements deserialisiert, als ob es sich um einen anderen Typ handeln würde.</span><span class="sxs-lookup"><span data-stu-id="68224-196">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="68224-197">Die `ReadXml`-Implementierung des polymorph zugewiesenen Typs wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="68224-197">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="68224-198">Eine `ReadXml`-Implementierung sollte diese speziellen Attribute auf jeden Fall ignorieren, da sie vom Deserialisierungsprogramm verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="68224-198">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="68224-199">Schemaüberlegungen für IXmlSerializable-Inhaltstypen</span><span class="sxs-lookup"><span data-stu-id="68224-199">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="68224-200">Beim Exportieren eines Schemas und eines `IXmlSerializable`-Inhaltstyp wird die Schemaanbietermethode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="68224-200">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="68224-201">Ein <xref:System.Xml.Schema.XmlSchemaSet> wird an die Schemaanbietermethode übergeben.</span><span class="sxs-lookup"><span data-stu-id="68224-201">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="68224-202">Die Methode kann dem Schemasatz gültige Schemas hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="68224-202">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="68224-203">Der Schemasatz enthält das Schema, das zum Zeitpunkt des Schemaexports bereits bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="68224-203">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="68224-204">Wenn die Schemaanbietermethode dem Schemasatz ein Element hinzufügen muss, muss sie ermitteln, ob ein <xref:System.Xml.Schema.XmlSchema> mit dem geeigneten Namespace im Satz bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="68224-204">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="68224-205">Falls dies der Fall ist, muss die Schemaanbietermethode das neue Element dem vorhandenen `XmlSchema` hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="68224-205">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="68224-206">Andernfalls muss sie eine neue `XmlSchema`-Instanz erstellen.</span><span class="sxs-lookup"><span data-stu-id="68224-206">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="68224-207">Dies ist wichtig, wenn Arrays mit `IXmlSerializable`-Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="68224-207">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="68224-208">Wenn Sie zum Beispiel über einen `IXmlSerializable`-Typ verfügen, der als Typ "A" in Namespace "B" exportiert wird, ist es möglich, dass der Schemasatz beim Aufrufen der Schemaanbietermethode das Schema "B" bereits enthält, um den Typ "ArrayOfA" aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="68224-208">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="68224-209">Zusätzlich zum Hinzufügen von Typen zum <xref:System.Xml.Schema.XmlSchemaSet> muss die Schemaanbietermethode für Inhaltstypen einen anderen Wert als NULL zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="68224-209">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="68224-210">Sie kann ein <xref:System.Xml.XmlQualifiedName>-Element zurückgeben, das den Namen des Schematyps angibt, der für den jeweiligen `IXmlSerializable`-Typ verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="68224-210">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="68224-211">Dieser qualifizierte Name dient auch als Datenvertragsname und Namespace für den Typ.</span><span class="sxs-lookup"><span data-stu-id="68224-211">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="68224-212">Es ist zulässig, einen Typ zurückzugeben, der nicht im Schemasatz vorhanden ist, wenn dies direkt nach der Rückgabe der Schemaanbietermethode erfolgt.</span><span class="sxs-lookup"><span data-stu-id="68224-212">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="68224-213">Es wird jedoch vorausgesetzt, dass der Typ nach dem Export aller verwandten Typen (die <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A>-Methode wird für alle relevanten Typen von <xref:System.Runtime.Serialization.XsdDataContractExporter> aufgerufen, und es wird auf die <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>-Eigenschaft zugegriffen) im Schemasatz vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="68224-213">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="68224-214">Das Zugreifen auf die `Schemas`-Eigenschaft, bevor alle relevanten `Export`-Aufrufe durchgeführt wurden, kann zu einer <xref:System.Xml.Schema.XmlSchemaException> führen.</span><span class="sxs-lookup"><span data-stu-id="68224-214">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="68224-215">Weitere Informationen zum Exportprozess finden Sie unter [Exportieren von Schemas aus Klassen](exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="68224-215">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="68224-216">Die Schemaanbietermethode kann auch den zu verwendenden <xref:System.Xml.Schema.XmlSchemaType> zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="68224-216">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="68224-217">Der Typ kann anonym oder nicht anonym sein.</span><span class="sxs-lookup"><span data-stu-id="68224-217">The type may or may not be anonymous.</span></span> <span data-ttu-id="68224-218">Wenn er anonym ist, wird das Schema für den `IXmlSerializable`-Typ jeweils als anonymer Typ exportiert, wenn der `IXmlSerializable`-Typ als Datenmember verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="68224-218">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="68224-219">Der `IXmlSerializable`-Typ verfügt trotzdem noch über einen Datenvertragsnamen und einen Namespace.</span><span class="sxs-lookup"><span data-stu-id="68224-219">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="68224-220">(Dies wird in [Daten Vertrags Namen](data-contract-names.md) beschrieben, mit der Ausnahme, dass das- <xref:System.Runtime.Serialization.DataContractAttribute> Attribut nicht zum Anpassen des Namens verwendet werden kann.) Wenn Sie nicht anonym ist, muss es sich um einen der Typen im Handeln `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="68224-220">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="68224-221">Dies entspricht dem Zurückgeben von `XmlQualifiedName` für den Typ.</span><span class="sxs-lookup"><span data-stu-id="68224-221">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="68224-222">Zusätzlich wird für den Typ eine globale Elementdeklaration exportiert.</span><span class="sxs-lookup"><span data-stu-id="68224-222">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="68224-223">Wenn auf den Typ nicht das <xref:System.Xml.Serialization.XmlRootAttribute>-Attribut angewendet wurde, weist das Element denselben Namen und Namespace wie der Datenvertrag auf, und seine nillable-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="68224-223">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="68224-224">Die einzige Ausnahme ist der Schema Namespace ( `http://www.w3.org/2001/XMLSchema` ) – Wenn sich der Datenvertrag des Typs in diesem Namespace befindet, befindet sich das entsprechende globale Element im leeren Namespace, da es unzulässig ist, dem Schema Namespace neue Elemente hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="68224-224">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="68224-225">Wenn auf den Typ das `XmlRootAttribute`-Attribut angewendet wurde, wird die globale Elementdeklaration exportiert, indem Folgendes verwendet wird: die Eigenschaften <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> und <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="68224-225">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="68224-226">Die bei angewendetem `XmlRootAttribute` geltenden Standardeinstellungen sind der Datenvertragsname, ein leerer Namespace und der Wert `true` für "nillable".</span><span class="sxs-lookup"><span data-stu-id="68224-226">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="68224-227">Die gleichen Regeln für die globale Elementdeklaration gelten für Legacy-Datasettypen.</span><span class="sxs-lookup"><span data-stu-id="68224-227">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="68224-228">Beachten Sie, dass das `XmlRootAttribute` keine globalen Elementdeklarationen überschreiben kann, die mithilfe von benutzerdefiniertem Code hinzugefügt wurden. Diese können mithilfe der Schemaanbietermethode dem `XmlSchemaSet` oder über `GetSchema` für Legacy-Datasettypen hinzugefügt worden sein.</span><span class="sxs-lookup"><span data-stu-id="68224-228">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="68224-229">IXmlSerializable-Elementtypen</span><span class="sxs-lookup"><span data-stu-id="68224-229">IXmlSerializable Element Types</span></span>

<span data-ttu-id="68224-230">Für `IXmlSerializable`-Elementtypen ist entweder die `IsAny`-Eigenschaft auf `true` festgelegt, oder ihre Schemaanbietermethode gibt `null` zurück.</span><span class="sxs-lookup"><span data-stu-id="68224-230">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="68224-231">Das Serialisieren und Deserialisieren eines Elementtyps ähnelt stark dem Serialisieren und Deserialisieren eines Inhaltstyps.</span><span class="sxs-lookup"><span data-stu-id="68224-231">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="68224-232">Es gibt jedoch einige wichtige Unterschiede:</span><span class="sxs-lookup"><span data-stu-id="68224-232">However, there are some important differences:</span></span>

- <span data-ttu-id="68224-233">Von der `WriteXml`-Implementierung wird erwartet, dass sie genau ein Element schreibt (das natürlich mehrere untergeordnete Elemente enthalten kann).</span><span class="sxs-lookup"><span data-stu-id="68224-233">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="68224-234">Sie sollte keine Attribute außerhalb dieses einzelnen Elements, mehrerer gleichgeordneter Elemente oder gemischten Inhalts schreiben.</span><span class="sxs-lookup"><span data-stu-id="68224-234">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="68224-235">Das Element ist ggf. leer.</span><span class="sxs-lookup"><span data-stu-id="68224-235">The element may be empty.</span></span>

- <span data-ttu-id="68224-236">Die `ReadXml`-Implementierung sollte das Wrapperelement nicht lesen.</span><span class="sxs-lookup"><span data-stu-id="68224-236">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="68224-237">Es wird erwartet, dass sie das einzelne Element liest, das von `WriteXml` erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="68224-237">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="68224-238">Wenn das Serialisierungsprogramm regelmäßig einen Elementtyp serialisiert (zum Beispiel als Datenmember in einem Datenvertrag), gibt das Serialisierungsprogramm ein Wrapperelement aus, bevor `WriteXml` aufgerufen wird. Dies entspricht der Vorgehensweise bei Inhaltstypen.</span><span class="sxs-lookup"><span data-stu-id="68224-238">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="68224-239">Bei der Serialisierung eines Elementtyps auf der obersten Ebene gibt das Serialisierungsprogramm normalerweise jedoch kein Wrapperelement für das Element aus, das `WriteXml` schreibt. Dies ist nur der Fall, wenn beim Erstellen des Serialisierungsprogramms in den Konstruktoren `DataContractSerializer` oder `NetDataContractSerializer` explizit ein Stammname und ein Namespace angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="68224-239">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="68224-240">Weitere Informationen finden Sie unter [Serialisierung und Deserialisierung](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="68224-240">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="68224-241">Beim Serialisieren eines Elementtyps auf der obersten Ebene, ohne zur Entwurfszeit den Stammnamen und einen Namespace anzugeben, führen <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> und <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> im Wesentlichen keine Aktionen aus, und <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> ruft einfach `WriteXml` auf.</span><span class="sxs-lookup"><span data-stu-id="68224-241">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="68224-242">In diesem Modus kann das Objekt, das serialisiert wird, nicht `null` sein und nicht polymorph zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="68224-242">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="68224-243">Außerdem kann die Objektdiagrammbeibehaltung nicht aktiviert und `NetDataContractSerializer` kann nicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="68224-243">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="68224-244">Beim Deserialisieren eines Elementtyps auf der obersten Ebene, ohne zur Entwurfszeit den Stammnamen und den Namespace anzugeben, gibt <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> den Wert `true` zurück, wenn der Anfang eines beliebigen Elements gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="68224-244">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="68224-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> mit auf `verifyObjectName` festgelegtem `true`-Parameter verhält sich genau so wie `IsStartObject`, bevor das Objekt gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="68224-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="68224-246">`ReadObject` übergibt das Steuerelement dann an die `ReadXml`-Methode.</span><span class="sxs-lookup"><span data-stu-id="68224-246">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="68224-247">Das Schema, das für die Elementtypen exportiert wird, entspricht dem Schema für den `XmlElement`-Typ, wie in einem Abschnitt weiter oben beschrieben. Es gilt jedoch die Ausnahme, dass die Schemaanbietermethode wie bei Inhaltstypen dem <xref:System.Xml.Schema.XmlSchemaSet> zusätzliche Schemas hinzufügen kann.</span><span class="sxs-lookup"><span data-stu-id="68224-247">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="68224-248">Das Verwenden des `XmlRootAttribute`-Attributs mit Elementtypen ist nicht zulässig, und globale Elementdeklarationen werden für diese Typen nicht ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="68224-248">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="68224-249">Unterschiede zu XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="68224-249">Differences from the XmlSerializer</span></span>

<span data-ttu-id="68224-250">Die `IXmlSerializable`-Schnittstelle und das `XmlSchemaProviderAttribute`- und `XmlRootAttribute`-Attribut werden vom <xref:System.Xml.Serialization.XmlSerializer> auch verstanden.</span><span class="sxs-lookup"><span data-stu-id="68224-250">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="68224-251">Aber es gibt einige Unterschiede dabei, wie diese Elemente im Datenvertragsmodell behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="68224-251">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="68224-252">Die wichtigsten Unterschiede werden im Folgenden zusammengefasst:</span><span class="sxs-lookup"><span data-stu-id="68224-252">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="68224-253">Die Schemaanbietermethode muss öffentlich sein, um im `XmlSerializer` verwendet werden zu können. Sie muss jedoch nicht öffentlich sein, um im Datenvertragsmodell verwendet werden zu können.</span><span class="sxs-lookup"><span data-stu-id="68224-253">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="68224-254">Die Schemaanbietermethode wird aufgerufen, wenn für `IsAny` im Datenvertragsmodell `true` gilt, jedoch nicht für den `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="68224-254">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="68224-255">Wenn das `XmlRootAttribute`-Attribut für Inhalts- oder Legacy-Datasettypen nicht vorhanden ist, exportiert der `XmlSerializer` eine globale Elementdeklaration in den leeren Namespace.</span><span class="sxs-lookup"><span data-stu-id="68224-255">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="68224-256">Im Datenvertragsmodell ist der verwendete Namespace normalerweise der Datenvertragsnamespace, wie bereits beschrieben.</span><span class="sxs-lookup"><span data-stu-id="68224-256">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="68224-257">Beachten Sie diese Unterschiede, wenn Sie Typen erstellen, die mit beiden Serialisierungstechnologien verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="68224-257">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="68224-258">Importieren von IXmlSerializable-Schemas</span><span class="sxs-lookup"><span data-stu-id="68224-258">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="68224-259">Beim Importieren eines Schemas, das aus `IXmlSerializable`-Typen generiert wurde, gibt es verschiedene Möglichkeiten:</span><span class="sxs-lookup"><span data-stu-id="68224-259">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="68224-260">Das generierte Schema kann ein gültiges Daten Vertrags Schema sein, wie unter [Daten Vertrags Schema-Referenz](data-contract-schema-reference.md)beschrieben.</span><span class="sxs-lookup"><span data-stu-id="68224-260">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="68224-261">In diesem Fall kann das Schema auf die übliche Weise importiert werden, und es werden normale Datenvertragstypen generiert.</span><span class="sxs-lookup"><span data-stu-id="68224-261">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="68224-262">Bei dem generierten Schema kann es sich auch um ein nicht gültiges Datenvertragsschema handeln.</span><span class="sxs-lookup"><span data-stu-id="68224-262">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="68224-263">Ihre Schemaanbietermethode kann zum Beispiel Schemas mit XML-Attributen generieren, die im Datenvertragsmodell nicht unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="68224-263">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="68224-264">In diesem Fall können Sie das Schema als `IXmlSerializable`-Typen importieren.</span><span class="sxs-lookup"><span data-stu-id="68224-264">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="68224-265">Dieser Import Modus ist standardmäßig nicht aktiviert, kann jedoch problemlos aktiviert werden – z. b. mit dem `/importXmlTypes` Befehls Zeilenschalter zum [Service Model Metadata Utility-Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="68224-265">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="68224-266">Dies wird im Abschnitt [Importieren von Schemas zum Generieren von Klassen](importing-schema-to-generate-classes.md)ausführlich beschrieben.</span><span class="sxs-lookup"><span data-stu-id="68224-266">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="68224-267">Beachten Sie, dass Sie für die Typinstanzen direkt mit den XML-Daten arbeiten müssen.</span><span class="sxs-lookup"><span data-stu-id="68224-267">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="68224-268">Sie können auch erwägen, eine andere Serialisierungstechnologie zu verwenden, die einen größeren Schemabereich unterstützt. Weitere Informationen finden Sie im Thema zur Verwendung von `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="68224-268">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="68224-269">Es ist ratsam, Ihre vorhandenen `IXmlSerializable`-Typen im Proxy wiederzuverwenden, anstatt neue zu generieren.</span><span class="sxs-lookup"><span data-stu-id="68224-269">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="68224-270">In diesem Fall können Sie die Funktion mit den referenzierten Typen verwenden, die im Thema zum Importieren von Schemas zum Generieren von Typen beschrieben ist, um den wiederzuverwendenden Typ anzugeben.</span><span class="sxs-lookup"><span data-stu-id="68224-270">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="68224-271">Dies entspricht dem Verwenden des Schalters `/reference` für „svcutil.exe“. Damit wird die Assembly angegeben, die die wiederzuverwendenden Typen enthält.</span><span class="sxs-lookup"><span data-stu-id="68224-271">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="68224-272">XmlSerializer-Legacyverhalten</span><span class="sxs-lookup"><span data-stu-id="68224-272">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="68224-273">In .NET Framework 4.0 und früher wurden von XmlSerializer temporäre Serialisierungsassemblys generiert, indem C#-Code in eine Datei geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="68224-273">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="68224-274">Die Datei wurde anschließend in eine Assembly kompiliert.</span><span class="sxs-lookup"><span data-stu-id="68224-274">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="68224-275">Dieses Verhalten hatte einige unerwünschte Folgen, z. B. das Verzögern der Startzeit für die Serialisierung.</span><span class="sxs-lookup"><span data-stu-id="68224-275">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="68224-276">In .NET Framework 4.5 wurde das Verhalten geändert, um die Assemblys zu generieren, ohne den Compiler verwenden zu müssen.</span><span class="sxs-lookup"><span data-stu-id="68224-276">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="68224-277">Einige Entwickler möchten den generierten C#-Code jedoch anzeigen.</span><span class="sxs-lookup"><span data-stu-id="68224-277">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="68224-278">Sie können mit der folgenden Konfiguration festlegen, dass dieses Legacyverhalten verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="68224-278">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="68224-279">Wenn Kompatibilitätsprobleme auftreten, z. b. Wenn `XmlSerializer` eine abgeleitete Klasse nicht mit einer nicht öffentlichen neuen außer Kraft Setzung serialisiert werden kann, können Sie auf das Legacy Verhalten zurück wechseln, `XMLSerializer` indem Sie die folgende Konfiguration verwenden:</span><span class="sxs-lookup"><span data-stu-id="68224-279">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="68224-280">Als Alternative zu der oben beschriebenen Konfiguration können Sie die folgende Konfiguration auf einem Computer verwenden, auf dem .NET Framework 4,5 oder eine neuere Version ausgeführt wird:</span><span class="sxs-lookup"><span data-stu-id="68224-280">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="68224-281">Der `<xmlSerializer useLegacySerializerGeneration="true"/>` Switch funktioniert nur auf einem Computer, auf dem .NET Framework 4,5 oder eine neuere Version ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="68224-281">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="68224-282">Der obige `appSettings` Ansatz funktioniert für alle .NET Framework Versionen.</span><span class="sxs-lookup"><span data-stu-id="68224-282">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="68224-283">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="68224-283">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="68224-284">Angeben von Datenübertragung in Dienstverträgen</span><span class="sxs-lookup"><span data-stu-id="68224-284">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="68224-285">Verwenden von Datenverträgen</span><span class="sxs-lookup"><span data-stu-id="68224-285">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="68224-286">Vorgehensweise: Verbessern der Startzeit von WCF-Clientanwendungen mit dem XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="68224-286">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
