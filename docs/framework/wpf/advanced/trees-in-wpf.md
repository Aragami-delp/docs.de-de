---
title: Strukturen
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: aed4350f1a7084b7894a70ac9d6d00cf25b39e34
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646197"
---
# <a name="trees-in-wpf"></a>Strukturen in WPF
In vielen Technologien werden Elemente und Komponenten in einer Baumstruktur organisiert, in denen Entwickler die Objektknoten direkt in der Struktur bearbeiten, um das Rendering oder das Verhalten einer Anwendung zu beeinflussen. Außerdem verwendet [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] mehrere Baumstrukturmetaphern, um Beziehungen zwischen Programmelementen festzulegen. Da die WPF-Entwickler meist eine Anwendung im Code erstellen können oder Teile der Anwendung in XAML festlegen, obwohl sie konzeptionell über die Baumstrukturobjektmetapher denken, rufen sie trotzdem eine bestimmte API auf oder verwenden bestimmte Markups, um dies zu tun, anstatt einige allgemeine API-Strukturobjektmanipulationen vorzunehmen, wie Sie sie möglicherweise im XML-DOM verwenden. WPF macht zwei Hilfsklassen verfügbar, die <xref:System.Windows.LogicalTreeHelper> eine <xref:System.Windows.Media.VisualTreeHelper>Baummetapheransicht bereitstellen, und . Die Begriffe „visuelle Struktur“ und „logische Struktur“ werden auch in der WPF-Dokumentation verwendet, da diese Strukturen für das Verstehen des Verhaltens bestimmter WPF-Schlüsselfunktionen hilfreich sind. In diesem Thema wird definiert, was die visuelle Und die logische Struktur darstellen, <xref:System.Windows.LogicalTreeHelper> erläutert, wie sich solche Bäume auf ein allgemeines Objektbaumkonzept beziehen, und führt ein und <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>
## <a name="trees-in-wpf"></a>Strukturen in WPF  
 Die umfassendste Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ist die Objektstruktur. Wenn Sie eine Anwendungsseite in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] festlegen und anschließend [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] laden, wird die Baumstruktur basierend auf den Schachtelungsbeziehungen der Elemente im Markup erstellt. Wenn Sie eine Anwendung oder einen Teil der Anwendung im Code festlegen, wird die Baumstruktur basierend darauf erstellt, wie Sie Eigenschaftswerte für Eigenschaften zuweisen, die das Inhaltsmodell für ein bestimmtes Objekt implementieren. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] gibt es zwei Möglichkeiten, wie die vollständige Objektstruktur konzipiert wird und an die öffentliche API gemeldet werden kann: Als logische Struktur und als visuelle Struktur. Die Unterschiede zwischen logischer Struktur und visueller Struktur sind nicht immer unbedingt wichtig, aber sie können gelegentlich Probleme mit bestimmten [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Subsystemen verursachen und Auswählen im Markup oder im Code beeinträchtigen.  
  
 Obwohl Sie nicht immer die logische Struktur oder die visuelle Struktur direkt bearbeiten, ist das Verstehen der Konzepte, wie die Strukturen interagieren, nützlich, um WPF als eine Technologie zu verstehen. Sich WPF als eine Baumstrukturmetapher vorzustellen, ist auch wichtig, um zu verstehen, wie Eigenschaftsvererbung und Ereignisrouting in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] funktionieren.  
  
> [!NOTE]
> Da die Objektstruktur eher ein Konzept als eine tatsächliche API ist, ist es eine weitere Möglichkeit, sich das Konzept als Objektdiagramm vorzustellen. In der Praxis gibt es Beziehungen zwischen Objekten während der Laufzeit, die die Baumstrukturmetapher aufschlüsseln können. Trotzdem ist die Baumstrukturmetapher, insbesondere bei XAML-definierten Benutzeroberflächen, ausreichend relevant, sodass die meisten WPF-Dokumentationen den Begriff „Objektstruktur“ verwenden werden, wenn auf dieses allgemeine Konzept verwiesen wird.  
  
<a name="logical_tree"></a>
## <a name="the-logical-tree"></a>Die logische Struktur  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fügen Sie Inhalte zu Benutzeroberflächenelementen hinzu, indem Sie Eigenschaften der Objekte festlegen, die diese Elemente unterstützen. Sie fügen z. B. Elemente zu einem <xref:System.Windows.Controls.ListBox> Steuerelement hinzu, indem Sie dessen <xref:System.Windows.Controls.ItemsControl.Items%2A> Eigenschaft bearbeiten. Auf diese Weise platzieren Sie <xref:System.Windows.Controls.ItemCollection> Elemente in <xref:System.Windows.Controls.ItemsControl.Items%2A> den Eigenschaftswert. Ebenso bearbeiten Sie, <xref:System.Windows.Controls.DockPanel>um Objekte <xref:System.Windows.Controls.Panel.Children%2A> zu einem hinzuzufügen, den Eigenschaftswert. Hier fügen Sie Objekte <xref:System.Windows.Controls.UIElementCollection>zum hinzufügen. Ein Codebeispiel finden Sie unter [Gewusst wie: Hinzufügen eines Elements dynamisch](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 Wenn [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]Sie Listenelemente in <xref:System.Windows.Controls.ListBox> einem oder Steuerelementen oder <xref:System.Windows.Controls.DockPanel>anderen UI-Elementen in einem platzieren, verwenden Sie auch die <xref:System.Windows.Controls.ItemsControl.Items%2A> und-Eigenschaften, <xref:System.Windows.Controls.Panel.Children%2A> entweder explizit oder implizit, wie im folgenden Beispiel.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Wenn Sie diesen XAML-Code als XML unter einem Dokumentobjektmodell verarbeiten würden und die auskommentierten Tags als implizit eingeschlossen hätten (was zulässig gewesen wäre), hätte die entstandene XML-DOM-Struktur Elemente für `<ListBox.Items>` und für die anderen impliziten Elemente eingeschlossen. XAML verarbeitet jedoch nicht auf diese Weise, und wenn Sie das Markup lesen und in Objekte schreiben, enthält das daraus entstehende Objektdiagramm nicht wirklich `ListBox.Items`. Sie verfügt jedoch <xref:System.Windows.Controls.ListBox> über `Items` eine <xref:System.Windows.Controls.ItemCollection>Eigenschaft mit <xref:System.Windows.Controls.ItemCollection> dem Namen , <xref:System.Windows.Controls.ListBox> die eine enthält und die initialisiert, aber leer ist, wenn die XAML verarbeitet wird. Anschließend wird jedes untergeordnete Objektelement, <xref:System.Windows.Controls.ListBox> das als <xref:System.Windows.Controls.ItemCollection> Inhalt für den `ItemCollection.Add`vorhanden ist, durch Parseraufrufe von hinzugefügt. Dieses Beispiel über die Verarbeitung von XAML in einer Objektstruktur ist bisher scheinbar ein Beispiel, bei dem die erstellte Objektstruktur im Grunde die logische Struktur ist.  
  
 Die logische Struktur ist jedoch nicht das gesamte Objektdiagramm, das zur Laufzeit für die Anwendungsbenutzeroberfläche vorhanden ist, selbst wenn die impliziten XAML-Syntaxelemente berücksichtigt werden. Der Hauptgrund dafür sind Visuals und Vorlagen. Betrachten Sie z. B. die <xref:System.Windows.Controls.Button>. Die logische Struktur <xref:System.Windows.Controls.Button> meldet das `Content`Objekt und auch seine Zeichenfolge . Es gibt jedoch noch mehr zu dieser Schaltfläche in der Laufzeit-Objektstruktur. Insbesondere wird die Schaltfläche nur auf dem Bildschirm <xref:System.Windows.Controls.Button> angezeigt, wie sie es tut, weil eine bestimmte Steuerelementvorlage angewendet wurde. Die visuellen Elemente, die aus einer angewendeten <xref:System.Windows.Controls.Border> Vorlage stammen (z. B. die Vorlagen definiert von Dunkelgrau um die visuelle Schaltfläche), werden nicht in der logischen Struktur gemeldet, selbst wenn Sie sich die logische Struktur während der Laufzeit ansehen (z. B. das Behandeln eines Eingabeereignisses von der sichtbaren Benutzeroberfläche und das anschließende Lesen der logischen Struktur). Sie müssten stattdessen die visuelle Struktur untersuchen, um die visuellen Vorlagen zu suchen.  
  
 Weitere Informationen dazu, wie die [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]-Syntax das erstellte Objektdiagramm sowie die implizite Syntax in XAML zuordnet, finden Sie unter [Ausführliche Erläuterung der XAML-Syntax](xaml-syntax-in-detail.md) oder [Übersicht über XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md).  
  
<a name="tree_property_inheritance_event_routing"></a>
### <a name="the-purpose-of-the-logical-tree"></a>Der Zweck der logischen Struktur  
 Die logische Struktur ist vorhanden, damit Inhaltsmodelle ihre potenziellen untergeordneten Objekte leicht durchlaufen können und damit Inhaltsmodelle erweiterbar sind. Darüber hinaus bietet die logische Struktur ein Framework für bestimmte Benachrichtigungen, z.B. wenn alle Objekte in der logischen Struktur geladen werden. Im Grunde ist die logische Struktur eine Annäherung an ein Laufzeit-Objektdiagramm auf der Frameworkebene, das visuelle Elemente ausschließt, aber für viele Abfragevorgänge für Ihre eigene Laufzeit-Anwendungskomposition ausreichend ist.  
  
 Darüber hinaus werden sowohl statische als auch dynamische Ressourcenverweise <xref:System.Windows.FrameworkElement.Resources%2A> aufgelöst, indem Sie durch die logische Struktur nach <xref:System.Windows.FrameworkElement> Auflistungen <xref:System.Windows.FrameworkContentElement>für `Resources` das ursprüngliche <xref:System.Windows.ResourceDictionary>anfordernde Objekt nach oben schauen und dann die logische Struktur fortsetzen und jeden (oder ) auf einen anderen Wert überprüfen, der möglicherweise einen enthält. Die logische Struktur wird für die Ressourcensuche verwendet, wenn sowohl die logische Struktur als auch die visuelle Struktur vorhanden sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suche finden Sie unter [XAML-Ressourcen](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>
### <a name="composition-of-the-logical-tree"></a>Zusammensetzung der logischen Struktur  
 Die logische Struktur wird auf WPF-Frameworkebene definiert, was bedeutet, dass das WPF-Basiselement, das für logische Baumoperationen am relevantesten ist, entweder <xref:System.Windows.FrameworkElement> oder ist. <xref:System.Windows.FrameworkContentElement> Wie Sie jedoch sehen können, <xref:System.Windows.LogicalTreeHelper> ob Sie die API tatsächlich verwenden, <xref:System.Windows.FrameworkElement> enthält <xref:System.Windows.FrameworkContentElement>die logische Struktur manchmal Knoten, die nicht entweder oder sind. Die logische Struktur meldet <xref:System.Windows.Controls.TextBlock.Text%2A> z. <xref:System.Windows.Controls.TextBlock>B. den Wert einer , bei der es sich um eine Zeichenfolge handelt.  
  
<a name="override_logical_tree"></a>
### <a name="overriding-the-logical-tree"></a>Überschreiben der logischen Struktur  
 Erweiterte Steuerelementautoren können die logische Struktur überschreiben, indem mehrere APIs überschrieben werden, die definieren, wie ein allgemeines Objekt oder Inhaltsmodell Objekte innerhalb der logischen Struktur hinzufügt oder entfernt. Ein Beispiel zum Überschreiben der logischen Struktur finden Sie unter [Überschreiben der logischen Struktur](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>
### <a name="property-value-inheritance"></a>Vererbung von Eigenschaftswerten  
 Die Vererbung von Eigenschaftswerten funktioniert mithilfe einer Hybridstruktur. Die tatsächlichen Metadaten, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> die die Eigenschaft enthalten, die <xref:System.Windows.FrameworkPropertyMetadata> die Eigenschaftenvererbung ermöglicht, sind die WPF-Framework-Ebene-Klasse. Daher müssen sowohl das übergeordnete Objekt, das den ursprünglichen Wert enthält, <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>als auch das untergeordnete Objekt, das diesen Wert erbt, sowohl oder sein, als auch beide Teil einer logischen Struktur sein. Allerdings kann für vorhandene WPF-Eigenschaften, die die Vererbung von Eigenschaften unterstützen, die Vererbung von Eigenschaftswerten durch ein beteiligtes Objekt aufrechterhalten werden, das nicht in der logischen Struktur ist. Dies ist vor allem relevant, wenn Vorlagenelemente alle geerbten Eigenschaftswerte verwenden, die entweder auf die Instanz festgelegt wurden, die als Vorlage verwendet wird, oder auf noch höheren Ebenen der Seitenebenen-Zusammensetzung und aus diesem Grund höher in der logischen Struktur sind. Damit die Vererbung von Eigenschaftswerten über eine solche Grenze hinweg konsistent funktioniert, muss die erbende Eigenschaft als angefügte Eigenschaft registriert werden, und Sie sollten dieses Muster befolgen, wenn Sie beabsichtigen, eine benutzerdefinierte Abhängigkeitseigenschaft mit Eigenschaftenvererbungsverhalten festzulegen. Die genaue Struktur, die für die Vererbung von Eigenschaften verwendet wurde, kann nicht vollständig von einer Hilfsprogrammklassen-Dienstmethode vorhergesehen werden, dies gilt selbst während der Laufzeit. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](property-value-inheritance.md).  
  
<a name="two_trees"></a>
## <a name="the-visual-tree"></a>Die visuelle Struktur  
 Neben dem Konzept der logischen Struktur, gibt es auch das Konzept der visuellen Struktur in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Die visuelle Struktur beschreibt die Struktur visueller <xref:System.Windows.Media.Visual> Objekte, die durch die Basisklasse dargestellt wird. Wenn Sie eine Vorlage für ein Steuerelement erstellen, werden Sie die visuelle Struktur festlegen oder neu festlegen, die für dieses Steuerelement angewendet wird. Die visuelle Struktur ist auch für Entwickler interessant, die die Kontrolle über Zeichnungen auf niedrigerer Ebene aus Leistungs- und Optimierungsgründen möchten. Eine Belichtung der visuellen Struktur als Teil der konventionellen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]-Programmierschnittstellen ist, dass das Ereignis für ein Routingereignis größtenteils entlang der visuellen Struktur steuert, nicht aber entlang der logischen Struktur. Diese Besonderheit des Routingereignisverhaltens ist möglicherweise nicht sofort erkennbar, es sei denn, Sie sind ein Autor des Steuerelements. Routingereignisse über die visuelle Struktur ermöglichen Steuerelemente, die die Komposition auf der visuellen Ebene implementieren, um Ereignisse zu bearbeiten oder Ereignissetter zu erstellen.  
  
<a name="trees_content"></a>
## <a name="trees-content-elements-and-content-hosts"></a>Strukturen, Inhaltselemente und Inhaltshosts  
 Inhaltselemente (Klassen, die <xref:System.Windows.ContentElement>von stammen) sind nicht Teil der visuellen Struktur; sie erben nicht von <xref:System.Windows.Media.Visual> und haben keine visuelle Darstellung. Um überhaupt in einer Benutzeroberfläche <xref:System.Windows.ContentElement> angezeigt zu werden, muss eine <xref:System.Windows.Media.Visual> in einem Inhaltshost gehostet werden, der sowohl ein als auch ein logischer Baumteilnehmer ist. Normalerweise ist ein <xref:System.Windows.FrameworkElement>solches Objekt ein . Sie können konzipieren, dass der Inhaltshost wie ein „Browser“ für den Inhalt ist und wählt, wie der Inhalt innerhalb des Bildschirmbereichs, den der Host steuert, anzuzeigen ist. Wenn der Inhalt gehostet wird, kann der Inhalt zu einem Teilnehmer bestimmter Prozessstrukturen gemacht werden, die normalerweise der visuellen Struktur zugeordnet sind. Im Allgemeinen <xref:System.Windows.FrameworkElement> enthält die Hostklasse Implementierungscode, der der Ereignisroute über Unterknoten der logischen Inhaltsstruktur gehostet <xref:System.Windows.ContentElement> wird, obwohl der gehostete Inhalt nicht Teil der echten visuellen Struktur ist. Dies ist erforderlich, damit ein <xref:System.Windows.ContentElement> Routingereignis, das zu einem anderen Element als sich selbst weitergeleitet wird, hergeleitet werden kann.  
  
<a name="tree_traversal"></a>
## <a name="tree-traversal"></a>Traversierung der Struktur  
 Die <xref:System.Windows.LogicalTreeHelper> Klasse <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>stellt <xref:System.Windows.LogicalTreeHelper.GetParent%2A>die <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> , und Methoden für die logische Baumdurchquerung bereit. In den meisten Fällen sollte Sie nicht die logische Struktur von vorhandenen Steuerelementen durchlaufen müssen, da diese Steuerelemente fast immer ihre logisch untergeordneten Elemente als dedizierte Auflistungseigenschaft verfügbar machen, die Auflistungszugriff, wie z.B. `Add`, einen Indexer und so weiter, unterstützt. Die Baumdurchquerung ist hauptsächlich ein Szenario, das von Steuerelementautoren verwendet <xref:System.Windows.Controls.ItemsControl> wird, die sich entscheiden, nicht von beabsichtigten Steuerelementmustern abzuleiten, z. B. oder <xref:System.Windows.Controls.Panel> wo Auflistungseigenschaften bereits definiert sind, und die beabsichtigen, ihre eigene Auflistungseigenschaftsunterstützung bereitzustellen.  
  
 Die visuelle Struktur unterstützt auch eine Hilfsklasse <xref:System.Windows.Media.VisualTreeHelper>für die visuelle Baumdurchquerung . Die visuelle Struktur wird nicht so bequem durch steuerungsspezifische Eigenschaften verfügbar gemacht, daher ist die Klasse die <xref:System.Windows.Media.VisualTreeHelper> empfohlene Methode, um die visuelle Struktur zu durchlaufen, wenn dies für Ihr Programmierszenario erforderlich ist. Weitere Informationen finden Sie unter [Übersicht über das WPF-Grafikenrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Manchmal ist es notwendig, die visuelle Struktur einer angewendeten Vorlage zu untersuchen. Gehen Sie bei dieser Technik vorsichtig vor. Selbst wenn Sie eine visuelle Struktur für ein Steuerelement durchlaufen, in dem Sie die Vorlage <xref:System.Windows.Controls.Control.Template%2A> definieren, können Benutzer des Steuerelements die Vorlage jederzeit ändern, indem sie die Eigenschaft für Instanzen festlegen, und sogar der Endbenutzer kann die angewendete Vorlage beeinflussen, indem er das Systemdesign ändert.  
  
<a name="routes"></a>
## <a name="routes-for-routed-events-as-a-tree"></a>Routen für Routingereignisse als „Struktur“  
 Wie bereits erwähnt, durchläuft die Route aller angegebenen Routingereignisse entlang eines einzelnen und vordefinierten Pfads einer Struktur, die eine Mischung aus den Darstellungen visueller und logischer Strukturen ist. Die Ereignisroute kann innerhalb der Struktur nach oben oder nach unten passieren, je nachdem, ob es ein Tunnel- oder Bubbling-Routingereignis ist. Das Konzept der Ereignisroute hat keine direkt unterstützende Hilfsprogrammklasse, die verwendet werden kann, um die Ereignisroute unabhängig vom Auslösen eines Ereignisses, das tatsächlich weiterleitet, zu „durchlaufen“. Es gibt eine Klasse, <xref:System.Windows.EventRoute>die die Route darstellt, aber die Methoden dieser Klasse sind im Allgemeinen nur für die interne Verwendung.  
  
<a name="resourcesandtrees"></a>
## <a name="resource-dictionaries-and-trees"></a>Ressourcenwörterbücher und Strukturen  
 Wörterbuchressourcensuche für alle `Resources`, die auf einer Seite festgelegt sind, durchlaufen im Grunde die logische Struktur. Objekte, die nicht in der logischen Struktur sind, können auf verschlüsselte Ressourcen verweisen, aber die Ressourcensuchsequenz beginnt an dem Punkt, an dem das Objekt mit der logischen Struktur verbunden ist. In WPF können nur logische Baumknoten eine `Resources` <xref:System.Windows.ResourceDictionary>Eigenschaft haben, die eine enthält, daher hat es keinen <xref:System.Windows.ResourceDictionary>Vorteil, wenn die visuelle Struktur nach schlüsselorientierten Ressourcen aus einem gesucht wird.  
  
 Die Ressourcensuche kann jedoch auch über die unmittelbare logische Struktur hinaus erweitert werden. Bei Anwendungsmarkups kann die Ressourcensuche auf Anwendungsebene von Ressourcenwörterbüchern weitergeführt werden, und anschließend bei der Designunterstützung und den Systemwerten fortgesetzt werden, die als statische Eigenschaften oder Schlüssel referenziert werden. Designs selbst können auch auf Systemwerte außerhalb der logischen Struktur des Designs verweisen, wenn die Ressourcenverweise dynamisch sind. Weitere Informationen zu Ressourcenwörterbüchern und der Suchlogik, finden Sie unter [XAML-Ressourcen](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>Siehe auch

- [Übersicht über die Eingabe](input-overview.md)
- [Übersicht über das WPF-Grafikrendering](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Übersicht über Routingereignisse](routed-events-overview.md)
- [Initialisierung für Objektelemente außerhalb einer Objektstruktur](initialization-for-object-elements-not-in-an-object-tree.md)
- [WPF-Architektur](wpf-architecture.md)
