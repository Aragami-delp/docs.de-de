---
title: Threadsichere Auflistungen
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 7af59cf0fdbe8d5c7d7d586b4b86992ae1dc7601
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/02/2020
ms.locfileid: "84290369"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="98ba7-102">Threadsichere Auflistungen</span><span class="sxs-lookup"><span data-stu-id="98ba7-102">Thread-Safe Collections</span></span>
<span data-ttu-id="98ba7-103">Das .NET Framework 4 führt den <xref:System.Collections.Concurrent?displayProperty=nameWithType>-Namespace ein, der mehrere Auflistungsklassen einschließt, die sowohl threadsicher als auch skalierbar sind.</span><span class="sxs-lookup"><span data-stu-id="98ba7-103">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="98ba7-104">Mehrere Threads können diesen Auflistungen sicher und effizient Elemente hinzufügen bzw. daraus entfernen, ohne dass zusätzliche Synchronisierung in Benutzercode erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="98ba7-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="98ba7-105">Wenn Sie neuen Code schreiben, verwenden Sie immer dann die Klassen für parallele Auflistungsvorgänge, wenn mehrere Threads gleichzeitig Schreibvorgänge in der Auflistung ausführen.</span><span class="sxs-lookup"><span data-stu-id="98ba7-105">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="98ba7-106">Wenn Sie nur von einer freigegebenen Auflistung lesen, können Sie die Klassen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace verwenden.</span><span class="sxs-lookup"><span data-stu-id="98ba7-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="98ba7-107">Es wird empfohlen, keine 1.0-Auflistungsklassen zu verwenden, sofern als Zielversion nicht .NET Framework 1.1 oder eine frühere Laufzeit festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="98ba7-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="98ba7-108">Threadsynchronisierung in den Auflistungen von .NET Framework 1.0 und 2.0</span><span class="sxs-lookup"><span data-stu-id="98ba7-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="98ba7-109">Die in .NET Framework 1.0 eingeführten Auflistungen befinden sich im <xref:System.Collections?displayProperty=nameWithType>-Namespace.</span><span class="sxs-lookup"><span data-stu-id="98ba7-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="98ba7-110">Diese Auflistungen, die das häufig verwendete <xref:System.Collections.ArrayList>-Objekt und das <xref:System.Collections.Hashtable>-Objekt einschließen, bieten eine gewisse Threadsicherheit durch die `Synchronized`-Eigenschaft, von der ein threadsicherer Wrapper um die Auflistung zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="98ba7-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="98ba7-111">Der Wrapper funktioniert folgendermaßen: Die gesamte Auflistung wird bei jedem Hinzufüge- oder Entfernungsvorgang gesperrt.</span><span class="sxs-lookup"><span data-stu-id="98ba7-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="98ba7-112">Daher muss jeder Thread, der versucht, auf die Auflistung zuzugreifen, warten, bis er die jeweilige Sperre übernehmen kann.</span><span class="sxs-lookup"><span data-stu-id="98ba7-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="98ba7-113">Dies ist nicht skalierbar und kann beträchtliche Leistungseinbußen für große Auflistungen verursachen.</span><span class="sxs-lookup"><span data-stu-id="98ba7-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="98ba7-114">Außerdem wird der Entwurf nicht völlig vor Racebedingungen geschützt.</span><span class="sxs-lookup"><span data-stu-id="98ba7-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="98ba7-115">Weitere Informationen finden Sie im Blogbeitrag [Synchronization in Generic Collections (Synchronisierung in generischen Auflistungen)](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span><span class="sxs-lookup"><span data-stu-id="98ba7-115">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="98ba7-116">Die in .NET Framework 2.0 eingeführten Auflistungsklassen befinden sich im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace.</span><span class="sxs-lookup"><span data-stu-id="98ba7-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="98ba7-117">Dazu gehören <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> usw.</span><span class="sxs-lookup"><span data-stu-id="98ba7-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="98ba7-118">Diese Klassen bieten verbesserte Typsicherheit und Leistung im Vergleich zu den .NET Framework 1.0-Klassen.</span><span class="sxs-lookup"><span data-stu-id="98ba7-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="98ba7-119">Die .NET Framework 2.0-Auflistungsklassen stellen jedoch keine Threadsynchronisierung bereit; Benutzercode muss die gesamte Synchronisierung bereitstellen, wenn Elemente gleichzeitig in mehreren Threads hinzugefügt oder entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="98ba7-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="98ba7-120">Es wird empfohlen, die gleichzeitigen Auflistungsklassen im .NET Framework 4 zu verwenden, da sie nicht nur die Typsicherheit der .NET Framework 2.0-Auflistungsklassen, sondern auch eine effizientere und vollständigere Threadsicherheit als die Auflistungen von .NET Framework 1.0 bieten.</span><span class="sxs-lookup"><span data-stu-id="98ba7-120">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="98ba7-121">Differenzierte Sperre und sperrenfreie Mechanismen</span><span class="sxs-lookup"><span data-stu-id="98ba7-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="98ba7-122">Einige der gleichzeitigen Auflistungstypen verwenden einfache Synchronisierungsmechanismen, z. B. <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, und <xref:System.Threading.CountdownEvent>, die neu im .NET Framework 4 sind.</span><span class="sxs-lookup"><span data-stu-id="98ba7-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="98ba7-123">Diese Synchronisierungstypen verwenden normalerweise *andauernde Spinvorgänge* für die kurzen Zeiträume, bevor der Thread in einen echten Wartezustand versetzt wird.</span><span class="sxs-lookup"><span data-stu-id="98ba7-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="98ba7-124">Wenn Wartezeiten als sehr kurz eingeschätzt werden, sind Spinvorgänge weitaus weniger rechenintensiv als Wartezustände, die einen aufwändigen Kernel-Übergang umfassen.</span><span class="sxs-lookup"><span data-stu-id="98ba7-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="98ba7-125">Für Auflistungsklassen, für die Spinvorgänge verwendet werden, bedeutet diese Effizienz, dass mehrere Threads Elemente mit einer sehr hohen Rate hinzufügen und entfernen können.</span><span class="sxs-lookup"><span data-stu-id="98ba7-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="98ba7-126">Weitere Informationen zu Spinvorgängen im Vergleich zu Blockierungen finden Sie unter [SpinLock](../../threading/spinlock.md) und [SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="98ba7-126">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="98ba7-127">Für die <xref:System.Collections.Concurrent.ConcurrentQueue%601>-Klasse und die <xref:System.Collections.Concurrent.ConcurrentStack%601>-Klasse werden gar keine Sperren verwendet.</span><span class="sxs-lookup"><span data-stu-id="98ba7-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="98ba7-128">Stattdessen wird die Threadsicherheit durch <xref:System.Threading.Interlocked>-Vorgänge gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="98ba7-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="98ba7-129">Da die gleichzeitigen Auflistungsklassen <xref:System.Collections.ICollection> unterstützen, stellen sie Implementierungen für die <xref:System.Collections.ICollection.IsSynchronized%2A>-Eigenschaft und die <xref:System.Collections.ICollection.SyncRoot%2A>-Eigenschaft bereit, auch wenn diese Eigenschaften nicht relevant sind.</span><span class="sxs-lookup"><span data-stu-id="98ba7-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="98ba7-130">`IsSynchronized` gibt immer `false` zurück, und `SyncRoot` ist immer `null` (`Nothing` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="98ba7-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="98ba7-131">In der folgenden Tabelle sind die Auflistungstypen im <xref:System.Collections.Concurrent?displayProperty=nameWithType>-Namespace aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="98ba7-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="98ba7-132">Typ</span><span class="sxs-lookup"><span data-stu-id="98ba7-132">Type</span></span>|<span data-ttu-id="98ba7-133">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="98ba7-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="98ba7-134">Stellt Begrenzungs- und Blockierungsfunktionen für jeden Typ bereit, von dem <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="98ba7-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="98ba7-135">Weitere Informationen finden Sie unter [Übersicht über BlockingCollection](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="98ba7-135">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="98ba7-136">Threadsichere Implementierung eines Wörterbuchs von Schlüssel-Wert-Paaren.</span><span class="sxs-lookup"><span data-stu-id="98ba7-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="98ba7-137">Threadsichere Implementierung einer First In, First Out (FIFO)-Warteschlange.</span><span class="sxs-lookup"><span data-stu-id="98ba7-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="98ba7-138">Threadsichere Implementierung eines Last In, First Out (LIFO)-Stapels.</span><span class="sxs-lookup"><span data-stu-id="98ba7-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="98ba7-139">Threadsichere Implementierung einer ungeordneten Auflistung von Elementen.</span><span class="sxs-lookup"><span data-stu-id="98ba7-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="98ba7-140">Die Schnittstelle, die ein Typ implementieren muss, damit sie in `BlockingCollection` verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="98ba7-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="98ba7-141">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="98ba7-141">Related Topics</span></span>  
  
|<span data-ttu-id="98ba7-142">Titel</span><span class="sxs-lookup"><span data-stu-id="98ba7-142">Title</span></span>|<span data-ttu-id="98ba7-143">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="98ba7-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="98ba7-144">Übersicht über BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="98ba7-144">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="98ba7-145">Beschreibt die vom <xref:System.Collections.Concurrent.BlockingCollection%601>-Typ bereitgestellte Funktion.</span><span class="sxs-lookup"><span data-stu-id="98ba7-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="98ba7-146">How to: Hinzufügen und Entfernen von Elementen aus einem ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="98ba7-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="98ba7-147">Beschreibt, wie Elemente aus einem <xref:System.Collections.Concurrent.ConcurrentDictionary%602>-Objekt hinzugefügt und entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="98ba7-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="98ba7-148">How to: Hinzufügen und Entfernen von einzelnen Elementen zu bzw. aus einer BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="98ba7-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="98ba7-149">Beschreibt, wie Elemente einer Blockierungsauflistung hinzugefügt und daraus abgerufen werden, ohne dass der schreibgeschützte Enumerator verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="98ba7-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="98ba7-150">How to: Hinzufügen von Begrenzungs- und Blockierungsfunktionen zu einer Auflistung</span><span class="sxs-lookup"><span data-stu-id="98ba7-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="98ba7-151">Beschreibt, wie jede Auflistungsklasse als zugrunde liegender Speichermechanismus für eine <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>-Auflistung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="98ba7-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="98ba7-152">How to: Verwenden von ForEach zum Entfernen von Elementen aus einer BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="98ba7-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="98ba7-153">Beschreibt, wie mit einer `foreach`-Anweisung (`For Each` in Visual Basic) alle Elemente in einer Blockierungsauflistung entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="98ba7-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="98ba7-154">How to: Verwenden von Arrays mit blockierenden Auflistungen in einer Pipeline</span><span class="sxs-lookup"><span data-stu-id="98ba7-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="98ba7-155">Beschreibt, wie mit mehreren Blockierungsauflistungen gleichzeitig eine Pipeline implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="98ba7-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="98ba7-156">How to: Erstellen eines Objektpools mit ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="98ba7-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="98ba7-157">Zeigt die Verwendung einer parallelen Sammlung zur Verbesserung der Leistung in Szenarien, in denen Sie Objekte nicht fortlaufend neu erstellen müssen, sondern diese wiederverwenden können.</span><span class="sxs-lookup"><span data-stu-id="98ba7-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="98ba7-158">Referenz</span><span class="sxs-lookup"><span data-stu-id="98ba7-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
