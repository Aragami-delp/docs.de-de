---
title: Der Large-Object-Heap (LOH) unter Windows
description: In diesem Artikel werden große Objekte erläutert, die Art und Weise, wie sie vom .NET-Garbage Collector verwaltet werden, sowie die Leistungseinbußen bei der Verwendung großer Objekte.
ms.date: 05/02/2018
helpviewer_keywords:
- large object heap (LOH)"
- LOH
- garbage collection, large object heap
- GC [.NET ], large object heap
ms.openlocfilehash: 87105acbd43eb8eda0daa00c65ca0635f5e1cc74
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/02/2020
ms.locfileid: "84286027"
---
# <a name="the-large-object-heap-on-windows-systems"></a><span data-ttu-id="d9dd1-103">Der große Objektheap auf Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="d9dd1-103">The large object heap on Windows systems</span></span>

<span data-ttu-id="d9dd1-104">Der .NET Garbage Collector (GC) teilt Objekte in die Kategorien „klein“ und „groß“ ein.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-104">The .NET garbage collector (GC) divides objects up into small and large objects.</span></span> <span data-ttu-id="d9dd1-105">Wenn ein Objekt groß ist, sind einige seiner Attribute wichtiger als bei einem kleinen Objekt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-105">When an object is large, some of its attributes become more significant than if the object is small.</span></span> <span data-ttu-id="d9dd1-106">So kann die Komprimierung, also das Kopieren in den Arbeitsspeicher an einer anderen Stelle des Heaps, aufwändig sein.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-106">For instance, compacting it&mdash;that is, copying it in memory elsewhere on the heap&mdash;can be expensive.</span></span> <span data-ttu-id="d9dd1-107">Deshalb platziert der Garbage Collector große Objekte im Large-Object-Heap (LOH).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-107">Because of this, the garbage collector places large objects on the large object heap (LOH).</span></span> <span data-ttu-id="d9dd1-108">In diesem Artikel wird erläutert, wodurch ein Objekt als großes Objekt angesehen wird, wie große Objekte bereinigt werden und in welcher Weise sich große Objekte auf die Leistung auswirken.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-108">This article discusses what qualifies an object as a large object, how large objects are collected, and what kind of performance implications large objects impose.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d9dd1-109">In diesem Artikel wird der Large-Object-Heap in .NET Framework und .NET Core erläutert, der nur in Windows-Systemen ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-109">This article discusses the large object heap in .NET Framework and .NET Core running on Windows systems only.</span></span> <span data-ttu-id="d9dd1-110">Der große Objektheap in .NET-Implementierungen auf anderen Plattformen wird nicht behandelt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-110">It does not cover the LOH running on .NET implementations on other platforms.</span></span>

## <a name="how-an-object-ends-up-on-the-loh"></a><span data-ttu-id="d9dd1-111">Wie gelangt ein Objekt in den Large-Object-Heap?</span><span class="sxs-lookup"><span data-stu-id="d9dd1-111">How an object ends up on the LOH</span></span>

<span data-ttu-id="d9dd1-112">Ein Objekt wird als großes Objekt betrachtet, wenn es eine Größe von mindestens 85.000 Byte aufweist.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-112">If an object is greater than or equal to 85,000 bytes in size, it’s considered a large object.</span></span> <span data-ttu-id="d9dd1-113">Diese Zahl wurde von der Leistungsoptimierung ermittelt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-113">This number was determined by performance tuning.</span></span> <span data-ttu-id="d9dd1-114">Wenn die Zuordnungsanforderung für ein Objekt über 85.000 Byte beträgt, ordnet die Runtime diese dem großen Objektheap zu.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-114">When an object allocation request is for 85,000 or more bytes, the runtime allocates it on the large object heap.</span></span>

<span data-ttu-id="d9dd1-115">Der folgende Abschnitt enthält für ein besseres Verständnis einige Grundlagen über den Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-115">To understand what this means, it's useful to examine some fundamentals about the garbage collector.</span></span>

<span data-ttu-id="d9dd1-116">Der Garbage Collector ist ein generationsbasierter Collector.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-116">The garbage collector is a generational collector.</span></span> <span data-ttu-id="d9dd1-117">Er verfügt über drei Generationen: Generation 0, Generation 1 und Generation 2.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-117">It has three generations: generation 0, generation 1, and generation 2.</span></span> <span data-ttu-id="d9dd1-118">Es gibt drei Generationen, da in einer gut eingerichteten App die meisten Objekte in Generation 0 inaktiv werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-118">The reason for having 3 generations is that, in a well-tuned app, most objects die in gen0.</span></span> <span data-ttu-id="d9dd1-119">In einer Server-App sollten die Zuordnungen für jede Anforderung inaktiv werden, nachdem die Anforderung abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-119">For example, in a server app, the allocations associated with each request should die after the request is finished.</span></span> <span data-ttu-id="d9dd1-120">Die noch nicht abgeschlossenen Zuordnungsanforderungen gelangen in Generation 1 und werden dann inaktiv.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-120">The in-flight allocation requests will make it into gen1 and die there.</span></span> <span data-ttu-id="d9dd1-121">Im Grunde dient Generation 1 als Puffer zwischen Bereichen mit neuen Objekten und Bereichen mit langlebigen Objekten.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-121">Essentially, gen1 acts as a buffer between young object areas and long-lived object areas.</span></span>

<span data-ttu-id="d9dd1-122">Kleine Objekte werden immer in Generation 0 zugeordnet und je nach Lebensdauer entweder in Generation 1 oder 2 heraufgestuft.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-122">Small objects are always allocated in generation 0 and, depending on their lifetime, may be promoted to generation 1 or generation2.</span></span> <span data-ttu-id="d9dd1-123">Große Objekte werden immer in Generation 2 zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-123">Large objects are always allocated in generation 2.</span></span>

<span data-ttu-id="d9dd1-124">Große Objekte gehören zu Generation 2, da sie nur während einer Garbage Collection für Generation 2 bereinigt werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-124">Large objects belong to generation 2 because they are collected only during a generation 2 collection.</span></span> <span data-ttu-id="d9dd1-125">Wenn eine Generation bereinigt wird, werden alle jüngeren Generationen ebenfalls bereinigt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-125">When a generation is collected, all its younger generation(s) are also collected.</span></span> <span data-ttu-id="d9dd1-126">So findet beispielsweise bei einer Garbage Collection für Generation 1 eine Bereinigung der Generationen 1 und 0 statt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-126">For example, when a generation 1 GC happens, both generation 1 and 0 are collected.</span></span> <span data-ttu-id="d9dd1-127">Erfolgt eine Garbage Collection für Generation 2, wird der gesamte Heap bereinigt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-127">And when a generation 2 GC happens, the whole heap is collected.</span></span> <span data-ttu-id="d9dd1-128">Aus diesem Grund wird eine Garbage Collection für Generation 2 auch als *vollständige Garbage Collection* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-128">For this reason, a generation 2 GC is also called a *full GC*.</span></span> <span data-ttu-id="d9dd1-129">In diesem Artikel wird „Garbage Collection für Generation 2“ statt „vollständige Garbage Collection“ verwendet, die Begriffe sind jedoch synonym.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-129">This article refers to generation 2 GC instead of full GC, but the terms are interchangeable.</span></span>

<span data-ttu-id="d9dd1-130">Die Generationen stellen eine logische Ansicht des Garbage Collection-Heaps bereit.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-130">Generations provide a logical view of the GC heap.</span></span> <span data-ttu-id="d9dd1-131">Physisch gesehen werden Objekte in verwalteten Heapsegmenten gespeichert.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-131">Physically, objects live in managed heap segments.</span></span> <span data-ttu-id="d9dd1-132">Ein *verwaltetes Heapsegment* ist ein Speicherblock, den der Garbage Collector vom Betriebssystem (durch Aufrufen der [VirtualAlloc-Funktion](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)) für verwalteten Code reserviert.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-132">A *managed heap segment* is a chunk of memory that the GC reserves from the OS by calling the [VirtualAlloc function](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) on behalf of managed code.</span></span> <span data-ttu-id="d9dd1-133">Beim Laden der CLR ordnet der Garbage Collector zunächst zwei Heapsegmente zu: eines für kleine Objekte (der kleine Objektheap) und eines für große Objekte (der große Objektheap).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-133">When the CLR is loaded, the GC allocates two initial heap segments: one for small objects (the small object heap, or SOH), and one for large objects (the large object heap).</span></span>

<span data-ttu-id="d9dd1-134">Die Zuordnungsanforderungen werden dann erfüllt, indem verwaltete Objekte in diesen verwalteten Heapsegmenten abgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-134">The allocation requests are then satisfied by putting managed objects on these managed heap segments.</span></span> <span data-ttu-id="d9dd1-135">Wenn das Objekt kleiner als 85.000 Byte ist, wird es im Segment für den kleinen Objektheap abgelegt, andernfalls im Segment für einen großen Objektheap.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-135">If the object is less than 85,000 bytes, it is put on the segment for the SOH; otherwise, it is put on an LOH segment.</span></span> <span data-ttu-id="d9dd1-136">Segmente werden (in kleineren Blöcken) übernommen, wenn ihnen immer mehr Objekte zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-136">Segments are committed (in smaller chunks) as more and more objects are allocated onto them.</span></span>
<span data-ttu-id="d9dd1-137">Beim kleinen Objektheap werden Objekte, die bei einer Garbage Collection nicht bereinigt werden, in die nächste Generation heraufgestuft.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-137">For the SOH, objects that survive a GC are promoted to the next generation.</span></span> <span data-ttu-id="d9dd1-138">Objekte, die in einer Garbage Collection für Generation 0 nicht bereinigt werden, werden nun als Objekte von Generation 1 betrachtet und so weiter.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-138">Objects that survive a generation 0 collection are now considered generation 1 objects, and so on.</span></span> <span data-ttu-id="d9dd1-139">Objekte, die die älteste Generation überdauern, werden jedoch weiterhin als Objekte der ältesten Generation betrachtet.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-139">However, objects that survive the oldest generation are still considered to be in the oldest generation.</span></span> <span data-ttu-id="d9dd1-140">Die Objekte, die Generation 2 überdauern, sind also Objekte von Generation 2, und die Objekte, die den großen Objektheap überdauern, sind Objekte des großen Objektheaps (die in Generation 2 bereinigt werden).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-140">In other words, survivors from generation 2 are generation 2 objects; and survivors from the LOH are LOH objects (which are collected with gen2).</span></span>

<span data-ttu-id="d9dd1-141">Benutzercode kann nur in der Generation 0 (kleine Objekte) oder im großen Objektheap (große Objekte) zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-141">User code can only allocate in generation 0 (small objects) or the LOH (large objects).</span></span> <span data-ttu-id="d9dd1-142">Nur der Garbage Collector kann Objekte von Generation 1 (durch Heraufstufen beibehaltener Objekte aus Generation 0) und Generation 2 (durch Heraufstufen beibehaltener Objekte aus den Generationen 1 und 2) zuordnen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-142">Only the GC can “allocate” objects in generation 1 (by promoting survivors from generation 0) and generation 2 (by promoting survivors from generations 1 and 2).</span></span>

<span data-ttu-id="d9dd1-143">Wenn eine Garbage Collection ausgelöst wird, geht der Garbage Collector alle aktiven Objekte durch und komprimiert sie.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-143">When a garbage collection is triggered, the GC traces through the live objects and compacts them.</span></span> <span data-ttu-id="d9dd1-144">Da die Komprimierung jedoch aufwändig ist, *bereinigt* die Garbage Collection den großen Objektheap. Dabei wird eine Freiliste aus inaktiven Objekten erstellt, die später zur Erfüllung von Zuordnungsanforderungen für große Objekte wiederverwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-144">But because compaction is expensive, the GC *sweeps* the LOH; it makes a free list out of dead objects that can be reused later to satisfy large object allocation requests.</span></span> <span data-ttu-id="d9dd1-145">Angrenzende inaktive Objekte werden in ein einzelnes freies Objekt umgewandelt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-145">Adjacent dead objects are made into one free object.</span></span>

<span data-ttu-id="d9dd1-146">.NET Core und .NET Framework (ab .NET Framework 4.5.1) enthalten die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode?displayProperty=nameWithType>-Eigenschaft, durch die Benutzer angegeben können, dass der große Objektheap während der nächsten vollständigen blockierenden Garbage Collection komprimiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-146">.NET Core and .NET Framework (starting with .NET Framework 4.5.1) include the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode?displayProperty=nameWithType> property that allows users to specify that the LOH should be compacted during the next full blocking GC.</span></span> <span data-ttu-id="d9dd1-147">Zukünftig erfolgt die Komprimierung des großen Objektheaps in .NET möglicherweise automatisch.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-147">And in the future, .NET may decide to compact the LOH automatically.</span></span> <span data-ttu-id="d9dd1-148">Daher sollten Sie diese Objekte fixieren, wenn Sie große Objekte zuordnen und sicherstellen möchten, dass diese nicht verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-148">This means that, if you allocate large objects and want to make sure that they don’t move, you should still pin them.</span></span>

<span data-ttu-id="d9dd1-149">Abbildung 1 zeigt ein Szenario, bei dem Generation 1 nach der ersten Garbage Collection für Generation 0 gebildet wird, bei der `Obj1` und `Obj3` inaktiv sind. Generation 2 wird nach der ersten Garbage Collection für Generation 1 gebildet, bei der `Obj2` und `Obj5` inaktiv sind.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-149">Figure 1 illustrates a scenario where the GC forms generation 1 after the first generation 0 GC where `Obj1` and `Obj3` are dead, and it forms generation 2 after the first generation 1 GC where `Obj2` and `Obj5` are dead.</span></span> <span data-ttu-id="d9dd1-150">Beachten Sie, dass diese und die folgenden Abbildungen nur zur Veranschaulichung dienen. Sie enthalten nur wenige Objekte, um besser darzustellen, was auf dem Heap geschieht.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-150">Note that this and the following figures are only for illustration purposes; they contain very few objects to better show what happens on the heap.</span></span> <span data-ttu-id="d9dd1-151">In der Praxis sind an einer Garbage Collection in der Regel wesentlich mehr Objekte beteiligt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-151">In reality, many more objects are typically involved in a GC.</span></span>

![Abbildung 1: Garbage Collection für Generation 0 und 1](media/loh/loh-figure-1.jpg)\
<span data-ttu-id="d9dd1-153">Abbildung 1: Garbage Collection für Generation 0 und 1.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-153">Figure 1: A generation 0 and a generation 1 GC.</span></span>

<span data-ttu-id="d9dd1-154">Abbildung 2 veranschaulicht, dass nach einer Garbage Collection für Generation 2, bei der `Obj1` und `Obj2` inaktiv sind, bildet die Garbage Collection freien Arbeitsspeicher, der von `Obj1` und `Obj2` belegt werden kann. Diese werden dann verwendet, um eine Zuordnungsanforderung für `Obj4` zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-154">Figure 2 shows that after a generation 2 GC which saw that `Obj1` and `Obj2` are dead, the GC forms contiguous free space out of memory that used to be occupied by `Obj1` and `Obj2`, which then was used to satisfy an allocation request for `Obj4`.</span></span> <span data-ttu-id="d9dd1-155">Der Speicherplatz nach dem letzten Objekt (`Obj3`) bis zum Ende des Segments kann ebenfalls zur Erfüllung von Zuordnungsanforderungen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-155">The space after the last object, `Obj3`, to end of the segment can also be used to satisfy allocation requests.</span></span>

![Abbildung 2: Nach einer Garbage Collection für Generation 2](media/loh/loh-figure-2.jpg)\
<span data-ttu-id="d9dd1-157">Abbildung 2: Nach einer Garbage Collection für Generation 2</span><span class="sxs-lookup"><span data-stu-id="d9dd1-157">Figure 2: After a generation 2 GC</span></span>

<span data-ttu-id="d9dd1-158">Wenn nicht genügend Speicherplatz zur Erfüllung der Zuordnungsanforderungen für große Objekte verfügbar ist, versucht die Garbage Collection zunächst, weitere Segmente vom Betriebssystem anzufordern.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-158">If there isn't enough free space to accommodate the large object allocation requests, the GC first attempts to acquire more segments from the OS.</span></span> <span data-ttu-id="d9dd1-159">Wenn dies fehlschlägt, wird eine Garbage Collection für Generation 2 ausgelöst, um Speicherplatz freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-159">If that fails, it triggers a generation 2 GC in the hope of freeing up some space.</span></span>

<span data-ttu-id="d9dd1-160">Bei einer Garbage Collection für Generation 1 oder 2 gibt der Garbage Collector Segmente frei für das Betriebssystem, in denen keine aktiven Objekte vorhanden sind, indem die Funktion [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-160">During a generation 1 or generation 2 GC, the garbage collector releases segments that have no live objects on them back to the OS by calling the [VirtualFree function](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree).</span></span> <span data-ttu-id="d9dd1-161">Der Speicherplatz nach dem letzten aktiven Objekt bis zum Ende des Segments wird aufgehoben (außer in dem kurzlebigen Segment, in dem Generation 0 und Generation 1 aktiv sind und in dem der Garbage Collector einigen Speicherplatz beibehält, da dieser sofort Ihrer Anwendung zugewiesen wird).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-161">Space after the last live object to the end of the segment is decommitted (except on the ephemeral segment where gen0/gen1 live, where the garbage collector does keep some committed because your application will be allocating in it right away).</span></span> <span data-ttu-id="d9dd1-162">Die freien Speicherblöcke sind nach wie vor committet, obwohl sie zurückgesetzt werden. Das bedeutet, dass das Betriebssystem in ihnen befindliche Daten nicht wieder auf den Datenträger schreiben muss.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-162">And the free spaces remain committed though they are reset, meaning that the OS doesn’t need to write data in them back to disk.</span></span>

<span data-ttu-id="d9dd1-163">Da der große Objektheap nur während Garbage Collections für Generation 2 bereinigt wird, kann ein Segment des großen Objektheaps nur während einer solchen Garbage Collection freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-163">Since the LOH is only collected during generation 2 GCs, the LOH segment can only be freed during such a GC.</span></span> <span data-ttu-id="d9dd1-164">In Abbildung 3 wird ein Szenario veranschaulicht, indem der Garbage Collector ein Segment (Segment 2) für das Betriebssystem freigibt und mehr Speicherplatz für die verbleibenden Segmente aufhebt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-164">Figure 3 illustrates a scenario where the garbage collector releases one segment (segment 2) back to the OS and decommits more space on the remaining segments.</span></span> <span data-ttu-id="d9dd1-165">Wenn der aufgehobene Speicherplatz am Ende des Segments verwendet werden muss, um Zuordnungsanforderungen für große Objekte zu erfüllen, wird der Arbeitsspeicher wieder committet.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-165">If it needs to use the decommitted space at the end of the segment to satisfy large object allocation requests, it commits the memory again.</span></span> <span data-ttu-id="d9dd1-166">(Eine Erläuterung zum Übernehmen und Aufheben finden Sie in der Dokumentation für [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc).)</span><span class="sxs-lookup"><span data-stu-id="d9dd1-166">(For an explanation of commit/decommit, see the documentation for [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc).</span></span>

![Abbildung 3: Großer Objektheap nach einer Garbage Collection für Generation 2](media/loh/loh-figure-3.jpg)\
<span data-ttu-id="d9dd1-168">Abbildung 3: Der große Objektheap nach einer Garbage Collection für Generation 2</span><span class="sxs-lookup"><span data-stu-id="d9dd1-168">Figure 3: The LOH after a generation 2 GC</span></span>

## <a name="when-is-a-large-object-collected"></a><span data-ttu-id="d9dd1-169">Wann wird ein großes Objekt bereinigt?</span><span class="sxs-lookup"><span data-stu-id="d9dd1-169">When is a large object collected?</span></span>

<span data-ttu-id="d9dd1-170">Im Allgemeinen wird eine Garbage Collection durchgeführt, wenn eine der folgenden drei Bedingungen zutrifft:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-170">In general, a GC occurs under one of the following three conditions:</span></span>

- <span data-ttu-id="d9dd1-171">Die Zuordnung überschreitet den Schwellenwert von Generation 0 oder des großen Objekts.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-171">Allocation exceeds the generation 0 or large object threshold.</span></span>

  <span data-ttu-id="d9dd1-172">Der Schwellenwert ist eine Eigenschaft einer Generation.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-172">The threshold is a property of a generation.</span></span> <span data-ttu-id="d9dd1-173">Ein Schwellenwert wird für eine Generation festgelegt, wenn der Garbage Collector diesem Objekte zuordnet.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-173">A threshold for a generation is set when the garbage collector allocates objects into it.</span></span> <span data-ttu-id="d9dd1-174">Wenn der Schwellenwert überschritten wird, wird eine Garbage Collection für diese Generation ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-174">When the threshold is exceeded, a GC is triggered on that generation.</span></span> <span data-ttu-id="d9dd1-175">Wenn Sie kleine oder große Objekte zuweisen, verwenden Sie daher die jeweiligen Schwellenwerte für Generation 0 und den großen Objektheap.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-175">When you allocate small or large objects, you consume generation 0 and the LOH’s thresholds, respectively.</span></span> <span data-ttu-id="d9dd1-176">Wenn der Garbage Collector eine Zuordnung zu Generation 1 oder 2 vornimmt, verwendet er deren Schwellenwerte.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-176">When the garbage collector allocates into generation 1 and 2, it consumes their thresholds.</span></span> <span data-ttu-id="d9dd1-177">Diese Schwellenwerte werden während der Ausführung des Programms dynamisch abgestimmt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-177">These thresholds are dynamically tuned as the program runs.</span></span>

  <span data-ttu-id="d9dd1-178">Dies ist der Normalfall. Die meisten Garbage Collections werden aufgrund von Zuordnungen im verwalteten Heap ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-178">This is the typical case; most GCs happen because of allocations on the managed heap.</span></span>

- <span data-ttu-id="d9dd1-179">Die <xref:System.GC.Collect%2A?displayProperty=nameWithType> -Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-179">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span>

  <span data-ttu-id="d9dd1-180">Wenn die parameterlose <xref:System.GC.Collect?displayProperty=nameWithType>-Methode aufgerufen wird oder eine andere Überladung als Argument an <xref:System.GC.MaxGeneration?displayProperty=nameWithType> übergeben wird, wird der große Objektheap zusammen mit dem restlichen verwalteten Heap bereinigt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-180">If the parameterless <xref:System.GC.Collect?displayProperty=nameWithType> method is called or another overload is passed <xref:System.GC.MaxGeneration?displayProperty=nameWithType> as an argument, the LOH is collected along with the rest of the managed heap.</span></span>

- <span data-ttu-id="d9dd1-181">Das System verfügt über wenig Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-181">The system is in low memory situation.</span></span>

  <span data-ttu-id="d9dd1-182">Dies tritt auf, wenn der Garbage Collector eine Benachrichtigung über eine hohe Arbeitsspeicherauslastung vom Betriebssystem erhält.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-182">This occurs when the garbage collector receives a high memory notification from the OS.</span></span> <span data-ttu-id="d9dd1-183">Wenn der Garbage Collector eine Garbage Collection für Generation 2 für produktiv hält, wird diese ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-183">If the garbage collector thinks that doing a generation 2 GC will be productive, it triggers one.</span></span>

## <a name="loh-performance-implications"></a><span data-ttu-id="d9dd1-184">Auswirkungen des LOH auf die Leistung</span><span class="sxs-lookup"><span data-stu-id="d9dd1-184">LOH performance implications</span></span>

<span data-ttu-id="d9dd1-185">Zuordnungen zum großen Objektheap beeinträchtigen die Leistung folgendermaßen:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-185">Allocations on the large object heap impact performance in the following ways.</span></span>

- <span data-ttu-id="d9dd1-186">Zuordnungskosten:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-186">Allocation cost.</span></span>

  <span data-ttu-id="d9dd1-187">Die CLR garantiert, dass der Speicher für jedes neue Objekt, das herausgegeben wird, bereinigt wird.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-187">The CLR makes the guarantee that the memory for every new object it gives out is cleared.</span></span> <span data-ttu-id="d9dd1-188">Dies bedeutet, dass die Zuordnungskosten für ein großes Objekt vollständig von der Speicherbereinigung dominiert werden (sofern keine Garbage Collection ausgelöst wird).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-188">This means the allocation cost of a large object is completely dominated by memory clearing (unless it triggers a GC).</span></span> <span data-ttu-id="d9dd1-189">Wenn zwei Zyklen für die Bereinigung von einem Byte benötigt werden, bedeutet dies, dass zum Bereinigen des kleinsten großen Objekts 170.000 Zyklen erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-189">If it takes 2 cycles to clear one byte, it takes 170,000 cycles to clear the smallest large object.</span></span> <span data-ttu-id="d9dd1-190">Das Bereinigen des Arbeitsspeichers eines 16 MB großen Objekts auf einem Computer mit 2 GHz dauert ungefähr 16 Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-190">Clearing the memory of a 16MB object on a 2GHz machine takes approximately 16ms.</span></span> <span data-ttu-id="d9dd1-191">Dies führt zu hohen Kosten.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-191">That's a rather large cost.</span></span>

- <span data-ttu-id="d9dd1-192">Bereinigungskosten:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-192">Collection cost.</span></span>

  <span data-ttu-id="d9dd1-193">Da der große Objektheap und Generation 2 zusammen bereinigt werden, wird eine Garbage Collection für Generation 2 ausgelöst, wenn einer der beiden Schwellenwerte überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-193">Because the LOH and generation 2 are collected together, if either one's threshold is exceeded, a generation 2 collection is triggered.</span></span> <span data-ttu-id="d9dd1-194">Wenn eine Garbage Collection für Generation 2 aufgrund des großen Objektheaps ausgelöst wurde, wird Generation 2 nach der Garbage Collection nicht unbedingt erheblich kleiner.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-194">If a generation 2 collection is triggered because of the LOH, generation 2 won't necessarily be much smaller after the GC.</span></span> <span data-ttu-id="d9dd1-195">Wenn nicht viele Daten zu Generation 2 gehören, hat dies nur minimale Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-195">If there's not much data on generation 2, this has minimal impact.</span></span> <span data-ttu-id="d9dd1-196">Ist Generation 2 jedoch groß, können Leistungsprobleme auftreten, wenn viele Garbage Collections für Generation 2 ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-196">But if generation 2 is large, it can cause performance problems if many generation 2 GCs are triggered.</span></span> <span data-ttu-id="d9dd1-197">Wenn viele große Objekte nur vorübergehend zugewiesen werden und Sie über einen großen kleinen Objektheap verfügen, verwenden Sie möglicherweise zu viel Zeit für Garbage Collections.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-197">If many large objects are allocated on a very temporary basis and you have a large SOH, you could be spending too much time doing GCs.</span></span> <span data-ttu-id="d9dd1-198">Darüber hinaus können die Zuordnungskosten sich summieren, wenn Sie sehr große Objekte weiterhin zuordnen und freigeben.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-198">In addition, the allocation cost can really add up if you keep allocating and letting go of really large objects.</span></span>

- <span data-ttu-id="d9dd1-199">Arrayelemente mit Verweistypen:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-199">Array elements with reference types.</span></span>

  <span data-ttu-id="d9dd1-200">Sehr große Objekte im großen Objektheap sind in der Regel Arrays (es kommt äußerst selten vor, dass ein sehr großes Instanzobjekt vorhanden ist).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-200">Very large objects on the LOH are usually arrays (it's very rare to have an instance object that's really large).</span></span> <span data-ttu-id="d9dd1-201">Wenn die Elemente eines Arrays viele Verweise enthalten, fallen Kosten an, die bei Elementen mit wenigen Verweise nicht anfallen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-201">If the elements of an array are reference-rich, it incurs a cost that is not present if the elements are not reference-rich.</span></span> <span data-ttu-id="d9dd1-202">Enthält das Element keine Verweise, muss der Garbage Collector das Array überhaupt nicht durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-202">If the element doesn’t contain any references, the garbage collector doesn’t need to go through the array at all.</span></span> <span data-ttu-id="d9dd1-203">Wenn Sie beispielsweise ein Array zum Speichern von Knoten in einer binären Struktur verwenden, könnte dies implementiert werden, indem durch die tatsächlichen Knoten auf den rechten und linken Knoten eines Knotens verwiesen wird:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-203">For example, if you use an array to store nodes in a binary tree, one way to implement it is to refer to a node’s right and left node by the actual nodes:</span></span>

  ```csharp
  class Node
  {
     Data d;
     Node left;
     Node right;
  };

  Node[] binary_tr = new Node [num_nodes];
  ```

  <span data-ttu-id="d9dd1-204">Wenn `num_nodes` groß ist, muss der Garbage Collector mindestens zwei Verweise pro Element durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-204">If `num_nodes` is large, the garbage collector needs to go through at least two references per element.</span></span> <span data-ttu-id="d9dd1-205">Ein alternativer Ansatz besteht darin, den Index des rechten und des linken Knotens zu speichern:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-205">An alternative approach is to store the index of the right and the left nodes:</span></span>

  ```csharp
  class Node
  {
     Data d;
     uint left_index;
     uint right_index;
  } ;
  ```

  <span data-ttu-id="d9dd1-206">Verweisen Sie auf die Daten des linken Knotens nicht mit `left.d`, sondern mit `binary_tr[left_index].d`.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-206">Instead of referring the left node’s data as `left.d`, you refer to it as `binary_tr[left_index].d`.</span></span> <span data-ttu-id="d9dd1-207">Der Garbage Collector muss dann keine Verweise für den linken und rechten Knoten betrachten.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-207">And the garbage collector doesn’t need to look at any references for the left and right node.</span></span>

<span data-ttu-id="d9dd1-208">Von diesen drei Faktoren sind die ersten beiden üblicherweise relevanter als der dritte.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-208">Out of the three factors, the first two are usually more significant than the third.</span></span> <span data-ttu-id="d9dd1-209">Deshalb wird empfohlen, dass Sie einen Pool von großen Objekten zuordnen, den Sie wiederverwenden, statt temporäre Objekte zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-209">Because of this, we recommend that you allocate a pool of large objects that you reuse instead of allocating temporary ones.</span></span>

## <a name="collect-performance-data-for-the-loh"></a><span data-ttu-id="d9dd1-210">Sammeln von Leistungsdaten für den LOH</span><span class="sxs-lookup"><span data-stu-id="d9dd1-210">Collect performance data for the LOH</span></span>

<span data-ttu-id="d9dd1-211">Bevor Sie Leistungsdaten für einen bestimmten Bereich erfassen, sollten Sie Folgendes durchgeführt haben:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-211">Before you collect performance data for a specific area, you should already have done the following:</span></span>

1. <span data-ttu-id="d9dd1-212">Beweise dafür suchen, dass Sie diesen Bereich überprüfen sollten</span><span class="sxs-lookup"><span data-stu-id="d9dd1-212">Found evidence that you should be looking at this area.</span></span>

2. <span data-ttu-id="d9dd1-213">Andere bekannte Bereiche ohne ein Ergebnis untersuchen, das das vorhandene Leistungsproblem erklären könnte</span><span class="sxs-lookup"><span data-stu-id="d9dd1-213">Exhausted other areas that you know of without finding anything that could explain the performance problem you saw.</span></span>

<span data-ttu-id="d9dd1-214">Weitere Informationen zu den Grundlagen zu Arbeitsspeicher und CPU finden Sie im Blogbeitrag [Understand the problem before you try to find a solution (Verstehen des Problems vor der Lösungsfindung)](https://devblogs.microsoft.com/dotnet/understand-the-problem-before-you-try-to-find-a-solution/).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-214">See the blog [Understand the problem before you try to find a solution](https://devblogs.microsoft.com/dotnet/understand-the-problem-before-you-try-to-find-a-solution/) for more information on the fundamentals of memory and the CPU.</span></span>

<span data-ttu-id="d9dd1-215">Sie können folgende Tools verwenden, um Daten über die Leistung des großen Objektheaps zu erfassen:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-215">You can use the following tools to collect data on LOH performance:</span></span>

- [<span data-ttu-id="d9dd1-216">.NET CLR-Speicherleistungsindikatoren</span><span class="sxs-lookup"><span data-stu-id="d9dd1-216">.NET CLR memory performance counters</span></span>](#net-clr-memory-performance-counters)

- [<span data-ttu-id="d9dd1-217">ETW-Ereignisse</span><span class="sxs-lookup"><span data-stu-id="d9dd1-217">ETW events</span></span>](#etw-events)

- [<span data-ttu-id="d9dd1-218">Debugger</span><span class="sxs-lookup"><span data-stu-id="d9dd1-218">A debugger</span></span>](#a-debugger)

### <a name="net-clr-memory-performance-counters"></a><span data-ttu-id="d9dd1-219">.NET CLR-Speicherleistungsindikatoren</span><span class="sxs-lookup"><span data-stu-id="d9dd1-219">.NET CLR Memory Performance counters</span></span>

<span data-ttu-id="d9dd1-220">Diese Speicherleistungsindikatoren sind in der Regel ein guter erster Schritt bei der Untersuchung von Leistungsproblemen. Es wird jedoch empfohlen, [ETW-Ereignisse](#etw-events) zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-220">These performance counters are usually a good first step in investigating performance issues (although we recommend that you use [ETW events](#etw-events)).</span></span> <span data-ttu-id="d9dd1-221">Sie können den Systemmonitor wie in Abbildung 4 dargestellt konfigurieren, indem Sie die gewünschten Indikatoren hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-221">You configure Performance Monitor by adding the counters that you want, as Figure 4 shows.</span></span> <span data-ttu-id="d9dd1-222">Folgende sind für den großen Objektheap relevant:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-222">The ones that are relevant for the LOH are:</span></span>

- <span data-ttu-id="d9dd1-223">**Anzahl der Garbage Collections für Generation 2**</span><span class="sxs-lookup"><span data-stu-id="d9dd1-223">**Gen 2 Collections**</span></span>

   <span data-ttu-id="d9dd1-224">Zeigt an, wie viele Garbage Collections für Generation 2 durchgeführt wurden, seit der Prozess gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-224">Displays the number of times generation 2 GCs have occurred since the process started.</span></span> <span data-ttu-id="d9dd1-225">Der Indikator wird am Ende einer Garbage Collection für Generation 2 (auch als vollständige Garbage Collection bezeichnet) erhöht.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-225">The counter is incremented at the end of a generation 2 collection (also called a full garbage collection).</span></span> <span data-ttu-id="d9dd1-226">Dieser Indikator zeigt den letzten erfassten Wert an.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-226">This counter displays the last observed value.</span></span>

- <span data-ttu-id="d9dd1-227">**Größe des Heap für große Objekte**</span><span class="sxs-lookup"><span data-stu-id="d9dd1-227">**Large Object Heap size**</span></span>

   <span data-ttu-id="d9dd1-228">Zeigt die aktuelle Größe des großen Objektheaps in Byte (einschließlich des freien Speicherplatzes) an.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-228">Displays the current size, in bytes, including free space, of the LOH.</span></span> <span data-ttu-id="d9dd1-229">Dieser Indikator wird nicht bei jeder Zuordnung, sondern nur am Ende einer Garbage Collection aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-229">This counter is updated at the end of a garbage collection, not at each allocation.</span></span>

<span data-ttu-id="d9dd1-230">Eine allgemeine Möglichkeit zum Anzeigen von Leistungsindikatoren ist die Verwendung des Systemmonitors (perfmon.exe).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-230">A common way to look at performance counters is with Performance Monitor (perfmon.exe).</span></span> <span data-ttu-id="d9dd1-231">Fügen Sie den entsprechenden Indikator für Prozesse, die für Sie wichtig sind, mithilfe von „Leistungsindikatoren hinzufügen“ hinzu.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-231">Use “Add Counters” to add the interesting counter for processes that you care about.</span></span> <span data-ttu-id="d9dd1-232">Sie können die Leistungsindikatordaten im Systemmonitor wie in Abbildung 4 dargestellt in einer Protokolldatei speichern:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-232">You can save the performance counter data to a log file, as Figure 4 shows:</span></span>

<span data-ttu-id="d9dd1-233">![Screenshot, der das Hinzufügen von Leistungsindikatoren zeigt.](media/large-object-heap/add-performance-counter.png)</span><span class="sxs-lookup"><span data-stu-id="d9dd1-233">![Screenshot that shows adding performance counters.](media/large-object-heap/add-performance-counter.png)</span></span>
<span data-ttu-id="d9dd1-234">Abbildung 4: Der große Objektheap nach einer Garbage Collection für Generation 2</span><span class="sxs-lookup"><span data-stu-id="d9dd1-234">Figure 4: The LOH after a generation 2 GC</span></span>

<span data-ttu-id="d9dd1-235">Leistungsindikatoren können auch programmgesteuert abgefragt werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-235">Performance counters can also be queried programmatically.</span></span> <span data-ttu-id="d9dd1-236">Viele Benutzer sammeln die Leistungsdaten auf diese Weise im Rahmen ihrer alltäglichen Testprozesse.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-236">Many people collect them this way as part of their routine testing process.</span></span> <span data-ttu-id="d9dd1-237">Wenn Indikatoren mit ungewöhnlichen Werten angezeigt werden, können dann mithilfe anderer Methoden detailliertere Daten abgerufen werden, um die Untersuchung zu erleichtern.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-237">When they spot counters with values that are out of the ordinary, they use other means to get more detailed data to help with the investigation.</span></span>

> [!NOTE]
> <span data-ttu-id="d9dd1-238">Es wird empfohlen, ETW-Ereignisse statt Leistungsindikatoren zu verwenden, da ETW umfangreichere Informationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-238">We recommend that you to use ETW events instead of performance counters, because ETW provides much richer information.</span></span>

### <a name="etw-events"></a><span data-ttu-id="d9dd1-239">ETW-Ereignisse</span><span class="sxs-lookup"><span data-stu-id="d9dd1-239">ETW events</span></span>

<span data-ttu-id="d9dd1-240">Der Garbage Collector bietet viele ETW-Ereignisse, mit denen Sie besser nachvollziehen können, welche Aktionen der Heap durchführt und warum.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-240">The garbage collector provides a rich set of ETW events to help you understand what the heap is doing and why.</span></span> <span data-ttu-id="d9dd1-241">In folgenden Blogbeiträgen wird das Erfassen und Verstehen von GC-Ereignissen mit ETW veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-241">The following blog posts show how to collect and understand GC events with ETW:</span></span>

- [<span data-ttu-id="d9dd1-242">GC ETW Events - 1 (Garbage Collection: ETW-Ereignisse (1))</span><span class="sxs-lookup"><span data-stu-id="d9dd1-242">GC ETW Events - 1</span></span>](https://devblogs.microsoft.com/dotnet/gc-etw-events-1/)

- [<span data-ttu-id="d9dd1-243">GC ETW Events - 2 (Garbage Collection: ETW-Ereignisse (2))</span><span class="sxs-lookup"><span data-stu-id="d9dd1-243">GC ETW Events - 2</span></span>](https://devblogs.microsoft.com/dotnet/gc-etw-events-2/)

- [<span data-ttu-id="d9dd1-244">GC ETW Events - 3 (Garbage Collection: ETW-Ereignisse (3))</span><span class="sxs-lookup"><span data-stu-id="d9dd1-244">GC ETW Events - 3</span></span>](https://devblogs.microsoft.com/dotnet/gc-etw-events-3/)

- [<span data-ttu-id="d9dd1-245">GC ETW Events - 4 (Garbage Collection: ETW-Ereignisse (4))</span><span class="sxs-lookup"><span data-stu-id="d9dd1-245">GC ETW Events - 4</span></span>](https://devblogs.microsoft.com/dotnet/gc-etw-events-4/)

<span data-ttu-id="d9dd1-246">Betrachten Sie die Spalte „Triggergrund“ für die Garbage Collections, um übermäßige Garbage Collections für Generation 2 zu identifizieren, die von temporären Zuordnungen von großen Objektheaps verursacht wurden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-246">To identify excessive generation 2 GCs caused by temporary LOH allocations, look at the Trigger Reason column for GCs.</span></span> <span data-ttu-id="d9dd1-247">Wenn Sie einen einfachen Test durchführen möchten, der nur große Objekte temporär zuordnet, können Sie mithilfe der folgenden [PerfView](https://www.microsoft.com/download/details.aspx?id=28567)-Befehlszeile Informationen zu ETW-Ereignissen erfassen:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-247">For a simple test that only allocates temporary large objects, you can collect information on ETW events with the following [PerfView](https://www.microsoft.com/download/details.aspx?id=28567) command line:</span></span>

```console
perfview /GCCollectOnly /AcceptEULA /nogui collect
```

<span data-ttu-id="d9dd1-248">Das Ergebnis ähnelt Folgendem:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-248">The result is something like this:</span></span>

<span data-ttu-id="d9dd1-249">![Screenshot mit ETW-Ereignissen in PerfView.](media/large-object-heap/event-tracing-windows-perfview.png)</span><span class="sxs-lookup"><span data-stu-id="d9dd1-249">![Screenshot that shows ETW events in PerfView.](media/large-object-heap/event-tracing-windows-perfview.png)</span></span>
<span data-ttu-id="d9dd1-250">Abbildung 5: Mithilfe von PerfView angezeigte ETW-Ereignisse</span><span class="sxs-lookup"><span data-stu-id="d9dd1-250">Figure 5: ETW events shown using PerfView</span></span>

<span data-ttu-id="d9dd1-251">Sie werden feststellen, dass alle Garbage Collections für Generation 2 durchgeführt und von AllocLarge ausgelöst wurden. Das bedeutet, dass die Zuordnung eines großen Objekts diese Garbage Collection ausgelöst hat.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-251">As you can see, all GCs are generation 2 GCs, and they are all triggered by AllocLarge, which means that allocating a large object triggered this GC.</span></span> <span data-ttu-id="d9dd1-252">Es ist bekannt, dass es sich um temporäre Zuordnungen handelt, da die Spalte **LOH Survival Rate** (Beibehaltungsrate des großen Objektheaps) „1 %“ anzeigt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-252">We know that these allocations are temporary because the **LOH Survival Rate %** column says 1%.</span></span>

<span data-ttu-id="d9dd1-253">Sie können zusätzliche ETW-Ereignisse erfassen, aus denen hervorgeht, wer diese großen Objekte zugeordnet hat.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-253">You can collect additional ETW events that tell you who allocated these large objects.</span></span> <span data-ttu-id="d9dd1-254">Verwenden Sie beispielsweise folgende Befehlszeile:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-254">The following command line:</span></span>

```console
perfview /GCOnly /AcceptEULA /nogui collect
```

<span data-ttu-id="d9dd1-255">Dadurch wird ein AllocationTick-Ereignis erfasst, das etwa alle 100.000 Zuordnungen ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-255">collects an AllocationTick event which is fired approximately every 100k worth of allocations.</span></span> <span data-ttu-id="d9dd1-256">Das bedeutet, dass immer dann ein Ereignis ausgelöst wird, wenn ein großes Objekt zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-256">In other words, an event is fired each time a large object is allocated.</span></span> <span data-ttu-id="d9dd1-257">Sie können dann eine der Ansichten für die Heapzuordnung der Garbage Collection betrachten, in denen die Aufruflisten angezeigt werden, die große Objekte zugeordnet haben:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-257">You can then look at one of the GC Heap Alloc views which show you the callstacks that allocated large objects:</span></span>

<span data-ttu-id="d9dd1-258">![Screenshot mit Garbage Collector Heap-Ansicht.](media/large-object-heap/garbage-collector-heap.png)</span><span class="sxs-lookup"><span data-stu-id="d9dd1-258">![Screenshot that shows a garbage collector heap view.](media/large-object-heap/garbage-collector-heap.png)</span></span>
<span data-ttu-id="d9dd1-259">Abbildung 6: Ansicht der Heapzuordnung einer Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="d9dd1-259">Figure 6: A GC Heap Alloc view</span></span>

<span data-ttu-id="d9dd1-260">Wie Sie sehen können, handelt es sich hierbei um einen einfachen Test, der nur große Objekte aus seiner `Main`-Methode zuordnet.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-260">As you can see, this is a very simple test that just allocates large objects from its `Main` method.</span></span>

### <a name="a-debugger"></a><span data-ttu-id="d9dd1-261">Debugger</span><span class="sxs-lookup"><span data-stu-id="d9dd1-261">A debugger</span></span>

<span data-ttu-id="d9dd1-262">Wenn Sie nur ein Speicherabbild besitzen und untersuchen müssen, welche Objekte sich im großen Objektheap befinden, können Sie die von .NET bereitgestellte [SOS-Debugerweiterung](../../framework/tools/sos-dll-sos-debugging-extension.md) verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-262">If all you have is a memory dump and you need to look at what objects are actually on the LOH, you can use the [SoS debugger extension](../../framework/tools/sos-dll-sos-debugging-extension.md) provided by .NET.</span></span>

> [!NOTE]
> <span data-ttu-id="d9dd1-263">Die in diesem Abschnitt erwähnten Debuggingbefehle gelten für die [Windows-Debugger](https://www.microsoft.com/whdc/devtools/debugging/default.mspx).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-263">The debugging commands mentioned in this section are applicable to the [Windows Debuggers](https://www.microsoft.com/whdc/devtools/debugging/default.mspx).</span></span>

<span data-ttu-id="d9dd1-264">Nachfolgend wird eine Beispielausgabe für die Analyse des großen Objektheaps angezeigt:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-264">The following shows sample output from analyzing the LOH:</span></span>

```console
0:003> .loadby sos mscorwks
0:003> !eeheap -gc
Number of GC Heaps: 1
generation 0 starts at 0x013e35ec
sdgeneration 1 starts at 0x013e1b6c
generation 2 starts at 0x013e1000
ephemeral segment allocation context: none
segment   begin allocated     size
0018f2d0 790d5588 790f4b38 0x0001f5b0(128432)
013e0000 013e1000 013e35f8 0x000025f8(9720)
Large object heap starts at 0x023e1000
segment   begin allocated     size
023e0000 023e1000 033db630 0x00ffa630(16754224)
033e0000 033e1000 043cdf98 0x00fecf98(16699288)
043e0000 043e1000 05368b58 0x00f87b58(16284504)
Total Size 0x2f90cc8(49876168)
------------------------------
GC Heap Size 0x2f90cc8(49876168)
0:003> !dumpheap -stat 023e1000 033db630
total 133 objects
Statistics:
MT   Count   TotalSize Class Name
001521d0       66     2081792     Free
7912273c       63     6663696 System.Byte[]
7912254c       4     8008736 System.Object[]
Total 133 objects
```

<span data-ttu-id="d9dd1-265">Die Größe des großen Objektheaps beträgt 49.738.016 Byte (16.754.224 + 16.699.288 + 16.284.504).</span><span class="sxs-lookup"><span data-stu-id="d9dd1-265">The LOH heap size is (16,754,224 + 16,699,288 + 16,284,504) = 49,738,016 bytes.</span></span> <span data-ttu-id="d9dd1-266">Zwischen den Adressen 023e1000 und 033db630 sind 8.008.736 Byte von einem Array von <xref:System.Object?displayProperty=nameWithType>-Objekten und 6.663.696 Byte sind von einem Array von <xref:System.Byte?displayProperty=nameWithType>-Objekten belegt. 2.081.792 Byte sind von freiem Speicherplatz belegt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-266">Between addresses 023e1000 and 033db630, 8,008,736 bytes are occupied by an array of <xref:System.Object?displayProperty=nameWithType> objects, 6,663,696 bytes are occupied by an array of <xref:System.Byte?displayProperty=nameWithType>  objects, and 2,081,792 bytes are occupied by free space.</span></span>

<span data-ttu-id="d9dd1-267">Manchmal zeigt der Debugger an, dass die Gesamtgröße des großen Objektheaps weniger als 85.000 Byte beträgt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-267">Sometimes, the debugger shows that the total size of the LOH is less than 85,000 bytes.</span></span> <span data-ttu-id="d9dd1-268">Dies geschieht, weil die Runtime den großen Objektheap zur Zuordnung von bestimmten Objekten verwendet, die kleiner als ein großes Objekt sind.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-268">This happens because the runtime itself uses the LOH to allocate some objects that are smaller than a large object.</span></span>

<span data-ttu-id="d9dd1-269">Da der große Objektheap nicht komprimiert wird, wird der große Objektheap manchmal für die Quelle der Fragmentierung gehalten.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-269">Because the LOH is not compacted, sometimes the LOH is thought to be the source of fragmentation.</span></span> <span data-ttu-id="d9dd1-270">Fragmentierung bedeutet:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-270">Fragmentation means:</span></span>

- <span data-ttu-id="d9dd1-271">Die Fragmentierung des verwalteten Heaps, die sich durch die Menge des freien Speicherplatzes zwischen verwalteten Objekten auszeichnet.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-271">Fragmentation of the managed heap, which is indicated by the amount of free space between managed objects.</span></span> <span data-ttu-id="d9dd1-272">Im SOS-Debugger zeigt der `!dumpheap –type Free`-Befehl die Menge des freien Speicherplatzes zwischen verwalteten Objekten an.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-272">In SoS, the `!dumpheap –type Free` command displays the amount of free space between managed objects.</span></span>

- <span data-ttu-id="d9dd1-273">Die Fragmentierung des Adressraums des virtuellen Arbeitsspeichers, bei dem es sich um den Arbeitsspeicher handelt, der als `MEM_FREE` markiert ist.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-273">Fragmentation of the virtual memory (VM) address space, which is the memory marked as `MEM_FREE`.</span></span> <span data-ttu-id="d9dd1-274">Sie können diesen mithilfe von verschiedenen Debuggerbefehlen in WinDbg abrufen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-274">You can get it by using various debugger commands in windbg.</span></span>

   <span data-ttu-id="d9dd1-275">Im folgenden Beispiel wird die Fragmentierung des virtuellen Arbeitsspeichers dargestellt:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-275">The following example shows fragmentation in the VM space:</span></span>

   ```console
   0:000> !address
   00000000 : 00000000 - 00010000
   Type     00000000
   Protect 00000001 PAGE_NOACCESS
   State   00010000 MEM_FREE
   Usage   RegionUsageFree
   00010000 : 00010000 - 00002000
   Type     00020000 MEM_PRIVATE
   Protect 00000004 PAGE_READWRITE
   State   00001000 MEM_COMMIT
   Usage   RegionUsageEnvironmentBlock
   00012000 : 00012000 - 0000e000
   Type     00000000
   Protect 00000001 PAGE_NOACCESS
   State   00010000 MEM_FREE
   Usage   RegionUsageFree
   … [omitted]
   -------------------- Usage SUMMARY --------------------------
   TotSize (     KB)   Pct(Tots) Pct(Busy)   Usage
   701000 (   7172) : 00.34%   20.69%   : RegionUsageIsVAD
   7de15000 ( 2062420) : 98.35%   00.00%   : RegionUsageFree
   1452000 (   20808) : 00.99%   60.02%   : RegionUsageImage
   300000 (   3072) : 00.15%   08.86%   : RegionUsageStack
   3000 (     12) : 00.00%   00.03%   : RegionUsageTeb
   381000 (   3588) : 00.17%   10.35%   : RegionUsageHeap
   0 (       0) : 00.00%   00.00%   : RegionUsagePageHeap
   1000 (       4) : 00.00%   00.01%   : RegionUsagePeb
   1000 (       4) : 00.00%   00.01%   : RegionUsageProcessParametrs
   2000 (       8) : 00.00%   00.02%   : RegionUsageEnvironmentBlock
   Tot: 7fff0000 (2097088 KB) Busy: 021db000 (34668 KB)

   -------------------- Type SUMMARY --------------------------
   TotSize (     KB)   Pct(Tots) Usage
   7de15000 ( 2062420) : 98.35%   : <free>
   1452000 (   20808) : 00.99%   : MEM_IMAGE
   69f000 (   6780) : 00.32%   : MEM_MAPPED
   6ea000 (   7080) : 00.34%   : MEM_PRIVATE

   -------------------- State SUMMARY --------------------------
   TotSize (     KB)   Pct(Tots) Usage
   1a58000 (   26976) : 01.29%   : MEM_COMMIT
   7de15000 ( 2062420) : 98.35%   : MEM_FREE
   783000 (   7692) : 00.37%   : MEM_RESERVE

   Largest free region: Base 01432000 - Size 707ee000 (1843128 KB)
   ```

<span data-ttu-id="d9dd1-276">Häufiger kommt es vor, dass eine Fragmentierung des virtuellen Arbeitsspeichers durch temporäre große Objekte verursacht wird, für die erforderlich ist, dass der Garbage Collector regelmäßig neue verwaltete Heapsegmente vom Betriebssystem abruft und leere Segmente wieder für das Betriebssystem freigibt.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-276">It’s more common to see VM fragmentation caused by temporary large objects that require the garbage collector to frequently acquire new managed heap segments from the OS and to release empty ones back to the OS.</span></span>

<span data-ttu-id="d9dd1-277">Sie können überprüfen, ob der große Objektheap die Fragmentierung des virtuellen Arbeitsspeichers verursacht, indem Sie einen Haltepunkt für [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) und [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) festlegen und bestimmen, von wem diese Funktionen aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-277">To verify whether the LOH is causing VM fragmentation, you can set a breakpoint on [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) and [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) to see who call them.</span></span> <span data-ttu-id="d9dd1-278">Sie können einen Breakpoint z.B. folgendermaßen festlegen, um anzuzeigen, wer versucht hat, virtuelle Arbeitsspeicherblöcke, die größer als 8 MB sind, aus dem Betriebssystem zuzuordnen:</span><span class="sxs-lookup"><span data-stu-id="d9dd1-278">For example, to see who tried to allocate virtual memory chunks larger than 8MBB from the OS, you can set a breakpoint like this:</span></span>

```console
bp kernel32!virtualalloc "j (dwo(@esp+8)>800000) 'kb';'g'"
```

<span data-ttu-id="d9dd1-279">Dieser Befehl unterbricht den Debugger und zeigt die Aufrufliste nur an, wenn [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) mit einer Zuordnungsgröße aufgerufen wird, die größer als 8 MB (0x800000) ist.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-279">This command breaks into the debugger and shows the call stack only if [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) is called with an allocation size greater than 8MB (0x800000).</span></span>

<span data-ttu-id="d9dd1-280">In CLR 2.0 wurde ein Feature namens *VM Hoarding* hinzugefügt, das für Szenarios nützlich ist, in denen Segmente (einschließlich des großen und des kleinen Objektheaps) häufig abgerufen und freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-280">CLR 2.0 added a feature called *VM Hoarding* that can be useful for scenarios where segments (including on the large and small object heaps) are frequently acquired and released.</span></span> <span data-ttu-id="d9dd1-281">Wenn Sie das Feature „VM Hoarding“ definieren möchten, geben Sie ein Startflag namens `STARTUP_HOARD_GC_VM` über die Hosting-API an.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-281">To specify VM Hoarding, you specify a startup flag called `STARTUP_HOARD_GC_VM` via the hosting API.</span></span> <span data-ttu-id="d9dd1-282">Die CLR hebt den Arbeitsspeicher für diese Segmente auf, und setzt diese auf eine Standbyliste, anstatt leere Segmente wieder für das Betriebssystem freizugeben.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-282">Instead of releasing empty segments back to the OS, the CLR decommits the memory on these segments and puts them on a standby list.</span></span> <span data-ttu-id="d9dd1-283">(Beachten Sie, dass die CLR dies nicht für Segmente durchführen kann, die zu groß sind.) Die CLR verwendet diese Segmente später, um Anforderungen für neue Segmente zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-283">(Note that the CLR doesn't do this for segments that are too large.) The CLR later uses those segments to satisfy new segment requests.</span></span> <span data-ttu-id="d9dd1-284">Wenn Ihre App das nächste Mal ein neues Segment benötigt, verwendet die CLR eines von dieser Standbyliste, wenn sie eines finden kann, das groß genug ist.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-284">The next time that your app needs a new segment, the CLR uses one from this standby list if it can find one that’s big enough.</span></span>

<span data-ttu-id="d9dd1-285">Die Funktion „VM Hoarding“ ist ebenfalls für Anwendungen nützlich, in denen bereits abgerufene Segmente beibehalten werden sollen. Dazu zählen beispielsweise Server-Apps, die als dominante Apps im System ausgeführt werden, um Ausnahmen wegen nicht ausreichendem Arbeitsspeicher zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-285">VM hoarding is also useful for applications that want to hold onto the segments that they already acquired, such as some server apps that are the dominant apps running on the system, to avoid out-of-memory exceptions.</span></span>

<span data-ttu-id="d9dd1-286">Es wird nachdrücklich empfohlen, dass Sie Ihre Anwendung sorgfältig testen, wenn Sie dieses Feature verwenden, und sicherstellen, dass die Speicherauslastung Ihrer Anwendung relativ stabil ist.</span><span class="sxs-lookup"><span data-stu-id="d9dd1-286">We strongly recommend that you carefully test your application when you use this feature to ensure your application has fairly stable memory usage.</span></span>
