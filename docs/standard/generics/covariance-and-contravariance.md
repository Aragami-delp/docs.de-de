---
title: Kovarianz und Kontravarianz in Generics
description: Hier erfahren Sie mehr über die Kovarianz, die die Verwendung eines stärker abgeleiteten Typs ermöglicht, und die Kontravarianz, durch die Sie in .NET-Generics einen weniger abgeleiteten Typ verwenden können.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
ms.openlocfilehash: 12de1554bb6e33b69d0d2bba24001e7e4c2d8a65
ms.sourcegitcommit: 7137e12f54c4e83a94ae43ec320f8cf59c1772ea
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/10/2020
ms.locfileid: "84663043"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="358e5-103">Kovarianz und Kontravarianz in Generics</span><span class="sxs-lookup"><span data-stu-id="358e5-103">Covariance and Contravariance in Generics</span></span>
<span data-ttu-id="358e5-104">Kovarianz und Kontravarianz sind Begriffe, die auf die Fähigkeit Bezug nehmen, einen stärker abgeleiteten (spezifischeren) oder einen weniger abgeleiteten (allgemeineren) Typ zu verwenden als ursprünglich angegeben.</span><span class="sxs-lookup"><span data-stu-id="358e5-104">Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="358e5-105">Generische Typparameter unterstützen Kovarianz und Kontravarianz und bieten somit mehr Flexibilität beim Zuweisen und Verwenden von generischen Typen.</span><span class="sxs-lookup"><span data-stu-id="358e5-105">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span> <span data-ttu-id="358e5-106">Wenn Sie auf ein Typsystem verweisen, haben Kovarianz, Kontravarianz und Invarianz die folgenden Definitionen.</span><span class="sxs-lookup"><span data-stu-id="358e5-106">When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="358e5-107">In den Beispielen wird von der Basisklasse `Base` und der abgeleiteten Klasse `Derived`ausgegangen.</span><span class="sxs-lookup"><span data-stu-id="358e5-107">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="358e5-108">Ermöglicht die Verwendung eines stärker abgeleiteten Typs als ursprünglich angegeben.</span><span class="sxs-lookup"><span data-stu-id="358e5-108">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="358e5-109">Sie können eine Instanz von `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) einer Variablen des Typs `IEnumerable<Base>`zuweisen.</span><span class="sxs-lookup"><span data-stu-id="358e5-109">You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="358e5-110">Ermöglicht die Verwendung eines generischeren (weniger stark abgeleiteten) Typs als ursprünglich angegeben.</span><span class="sxs-lookup"><span data-stu-id="358e5-110">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="358e5-111">Sie können eine Instanz von `Action<Base>` (`Action(Of Base)` in Visual Basic) einer Variablen des Typs `Action<Derived>`zuweisen.</span><span class="sxs-lookup"><span data-stu-id="358e5-111">You can assign an instance of `Action<Base>` (`Action(Of Base)` in Visual Basic) to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="358e5-112">Bedeutet, dass nur der ursprünglich angegebene Typ verwendet werden kann. Ein invarianter generischer Typparameter ist also weder kovariant noch kontravariant.</span><span class="sxs-lookup"><span data-stu-id="358e5-112">Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="358e5-113">Sie können eine Instanz von `List<Base>` (`List(Of Base)` in Visual Basic) nicht einer Variablen des Typs `List<Derived>` zuweisen oder umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="358e5-113">You cannot assign an instance of `List<Base>` (`List(Of Base)` in Visual Basic) to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="358e5-114">Kovariante Typparameter ermöglichen es Ihnen, Zuweisungen vorzunehmen, die normaler [Polymorphie](../../csharp/programming-guide/classes-and-structs/polymorphism.md) stark ähneln, wie im folgenden Code dargestellt.</span><span class="sxs-lookup"><span data-stu-id="358e5-114">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="358e5-115">Die <xref:System.Collections.Generic.List%601> -Klasse implementiert die generische <xref:System.Collections.Generic.IEnumerable%601> -Schnittstelle. `List<Derived>` (`List(Of Derived)` in Visual Basic) implementiert daher `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="358e5-115">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="358e5-116">Der kovariante Typparameter ist für den Rest zuständig.</span><span class="sxs-lookup"><span data-stu-id="358e5-116">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="358e5-117">Kontravarianz erscheint dagegen kontraintuitiv.</span><span class="sxs-lookup"><span data-stu-id="358e5-117">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="358e5-118">Im folgenden Beispiel wird ein Delegat des `Action<Base>` -Typs (`Action(Of Base)` in Visual Basic) erstellt und dann einer Variable des `Action<Derived>`-Typs zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="358e5-118">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="358e5-119">Das erscheint rückständig, ist aber typsicherer Code, der kompiliert und ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="358e5-119">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="358e5-120">Der Lambda-Ausdruck entspricht dem ihm zugewiesenen Delegaten und definiert daher eine Methode, die einen Parameter des `Base` -Typs akzeptiert und keinen Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="358e5-120">The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="358e5-121">Der resultierende Delegat kann einer Variable des `Action<Derived>` -Typs zugewiesen werden, da der Typparameter `T` des <xref:System.Action%601> -Delegaten kontravariant ist.</span><span class="sxs-lookup"><span data-stu-id="358e5-121">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="358e5-122">Der Code ist typsicher, da `T` einen Parametertyp angibt.</span><span class="sxs-lookup"><span data-stu-id="358e5-122">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="358e5-123">Wenn der Delegat des `Action<Base>` -Typs wie ein Delegat des `Action<Derived>`-Typs aufgerufen wird, muss sein Argument vom `Derived`-Typ sein.</span><span class="sxs-lookup"><span data-stu-id="358e5-123">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="358e5-124">Dieses Argument kann immer sicher an die zugrunde liegende Methode übergeben werden, da der Parameter der Methode vom `Base`-Typ ist.</span><span class="sxs-lookup"><span data-stu-id="358e5-124">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="358e5-125">Im Allgemeinen können kovariante Typparameter als Rückgabetyp eines Delegaten und kontravariante Typparameter als Parametertypen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="358e5-125">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="358e5-126">Für eine Schnittstelle können kovariante Typparameter als Rückgabetypen der Methoden der Schnittstelle verwendet werden und kontravariante Typparameter als Parametertypen der Methoden der Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="358e5-126">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="358e5-127">Kovarianz und Kontravarianz werden zusammen als *Varianz* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="358e5-127">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="358e5-128">Ein generischer Typparameter, der nicht als kovariant oder kontravariant markiert ist, wird als *invariant*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="358e5-128">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="358e5-129">Im Folgenden sehen Sie eine kurze Zusammenfassung der Fakten zur Varianz in der Common Language Runtime:</span><span class="sxs-lookup"><span data-stu-id="358e5-129">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="358e5-130">In .NET Framework 4 sind variante Typparameter auf generische Schnittstellen und generische Delegattypen beschränkt.</span><span class="sxs-lookup"><span data-stu-id="358e5-130">In the .NET Framework 4, variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="358e5-131">Eine generische Schnittstelle oder ein generischer Delegattyp kann sowohl kovariante, als auch kontravariante Typparameter haben.</span><span class="sxs-lookup"><span data-stu-id="358e5-131">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="358e5-132">Varianz gilt nur für Verweistypen. Wenn Sie für einen varianten Typparameter einen Werttyp angeben, ist dieser Typparameter für den resultierenden konstruierten Typ invariant.</span><span class="sxs-lookup"><span data-stu-id="358e5-132">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="358e5-133">Varianz gilt nicht für eine Delegatkombination.</span><span class="sxs-lookup"><span data-stu-id="358e5-133">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="358e5-134">Bei zwei Delegaten vom Typ `Action<Derived>` und `Action<Base>` (`Action(Of Derived)` und `Action(Of Base)` in Visual Basic) können Sie folglich den zweiten Delegaten nicht mit dem ersten kombinieren, obwohl das Ergebnis typsicher wäre.</span><span class="sxs-lookup"><span data-stu-id="358e5-134">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="358e5-135">Bei Varianz kann der zweite Delegat einer Variable des `Action<Derived>`-Typs zugewiesen werden, Delegaten können aber nur kombiniert werden, wenn ihre Typen genau überstimmen.</span><span class="sxs-lookup"><span data-stu-id="358e5-135">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="358e5-136">Generische Schnittstellen mit kovarianten Typparametern</span><span class="sxs-lookup"><span data-stu-id="358e5-136">Generic Interfaces with Covariant Type Parameters</span></span>  
 <span data-ttu-id="358e5-137">Ab .NET Framework 4 verfügen mehrere generische Schnittstellen über kovariante Typparameter wie etwa <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601> und <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="358e5-137">Starting with the .NET Framework 4, several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="358e5-138">Alle Typparameter dieser Schnittstellen sind kovariant, sodass sie nur für die Rückgabetypen der Member verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="358e5-138">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="358e5-139">Im folgenden Beispiel werden kovariante Typparameter veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="358e5-139">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="358e5-140">Im Beispiel werden zwei Typen definiert: `Base` verfügt über eine statische Methode mit dem Namen `PrintBases` , die einen `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) erwartet und die Elemente ausgibt.</span><span class="sxs-lookup"><span data-stu-id="358e5-140">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="358e5-141">`Derived` erbt von `Base`.</span><span class="sxs-lookup"><span data-stu-id="358e5-141">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="358e5-142">Im Beispiel wird ein leerer `List<Derived>` (`List(Of Derived)` in Visual Basic) erstellt, um zu veranschaulichen, dass dieser Typ an `PrintBases` übergeben und ohne Umwandlung einer Variablen vom Typ `IEnumerable<Base>` zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="358e5-142">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="358e5-143"><xref:System.Collections.Generic.List%601> implementiert <xref:System.Collections.Generic.IEnumerable%601>, die über einen einzelnen kovarianten Typparameter verfügt.</span><span class="sxs-lookup"><span data-stu-id="358e5-143"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="358e5-144">Aufgrund des kovarianten Typparameters kann eine Instanz von `IEnumerable<Derived>` anstelle von `IEnumerable<Base>`verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="358e5-144">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-generic-type-parameters"></a><span data-ttu-id="358e5-145">Generische Schnittstellen mit kontravarianten generischen Typparametern</span><span class="sxs-lookup"><span data-stu-id="358e5-145">Generic Interfaces with Contravariant Generic Type Parameters</span></span>  
 <span data-ttu-id="358e5-146">Ab .NET Framework 4 verfügen mehrere generische Schnittstellen über kontravariante Typparameter wie etwa <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601> und <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="358e5-146">Starting with the .NET Framework 4, several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="358e5-147">Diese Schnittstellen verfügen nur über kontravariante Typparameter. Die Typparameter werden daher nur in den Membern der Schnittstellen als Parametertypen verwendet.</span><span class="sxs-lookup"><span data-stu-id="358e5-147">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="358e5-148">Im folgenden Beispiel werden kontravariante Typparameter veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="358e5-148">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="358e5-149">Im Beispiel wird eine abstrakte (`MustInherit` in Visual Basic) `Shape` -Klasse mit einer `Area` -Eigenschaft definiert.</span><span class="sxs-lookup"><span data-stu-id="358e5-149">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="358e5-150">Außerdem wird eine `ShapeAreaComparer` -Klasse definiert, die `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic) implementiert.</span><span class="sxs-lookup"><span data-stu-id="358e5-150">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="358e5-151">Die Implementierung der <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> -Methode basiert auf dem Wert der `Area` -Eigenschaft, sodass `ShapeAreaComparer` zum Sortieren von `Shape` -Objekten nach Bereich verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="358e5-151">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="358e5-152">Die `Circle` -Klasse erbt von `Shape` und überschreibt `Area`.</span><span class="sxs-lookup"><span data-stu-id="358e5-152">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="358e5-153">Im Beispiel wird ein <xref:System.Collections.Generic.SortedSet%601> von `Circle` -Objekten erstellt, wobei ein Konstruktor verwendet wird, der `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic) akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="358e5-153">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="358e5-154">Anstelle von `IComparer<Circle>`wird jedoch ein `ShapeAreaComparer` -Objekt übergeben, das `IComparer<Shape>`implementiert.</span><span class="sxs-lookup"><span data-stu-id="358e5-154">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="358e5-155">Im Beispiel kann ein Vergleich eines weniger stark abgeleiteten Typs (`Shape`) übergeben werden, wenn der Code einen Vergleich eines stärker abgeleiteten Typs (`Circle`) verlangt, da der Typparameter der generischen <xref:System.Collections.Generic.IComparer%601> -Schnittstelle kontravariant ist.</span><span class="sxs-lookup"><span data-stu-id="358e5-155">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="358e5-156">Wenn `Circle` ein neues `SortedSet<Circle>`-Objekt hinzugefügt wird, wird die `IComparer<Shape>.Compare` -Methode (`IComparer(Of Shape).Compare` -Methode in Visual Basic) des `ShapeAreaComparer` -Objekts immer dann aufgerufen, wenn das neue Element mit einem vorhandenen Element verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="358e5-156">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="358e5-157">Der Parametertyp der Methode (`Shape`) ist weniger stark abgeleitet als der Typ, der übergeben wird (`Circle`). Deshalb ist der Aufruf typsicher.</span><span class="sxs-lookup"><span data-stu-id="358e5-157">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="358e5-158">Kontravarianz ermöglicht es `ShapeAreaComparer` , eine Auflistung eines einzelnen Typs sowie eine Auflistung von gemischten Typen zu sortieren, die von `Shape`abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="358e5-158">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="358e5-159">Generische Delegaten mit varianten Typparametern</span><span class="sxs-lookup"><span data-stu-id="358e5-159">Generic Delegates with Variant Type Parameters</span></span>  
 <span data-ttu-id="358e5-160">In .NET Framework 4 verfügen die generischen Delegaten vom Typ `Func` (beispielsweise <xref:System.Func%602>) über kovariante Rückgabetypen und kontravariante Parametertypen.</span><span class="sxs-lookup"><span data-stu-id="358e5-160">In the .NET Framework 4, the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="358e5-161">Die generischen `Action` -Delegaten, z. B. <xref:System.Action%602>, verfügen über kontravariante Parametertypen.</span><span class="sxs-lookup"><span data-stu-id="358e5-161">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="358e5-162">Das bedeutet, dass die Delegaten Variablen mit weiter abgeleiteten Parametertypen und (im Fall von generischen `Func` -Delegaten) weniger abgeleiteten Rückgabetypen zugewiesen werden können.</span><span class="sxs-lookup"><span data-stu-id="358e5-162">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="358e5-163">Der letzte generische Typparameter der generischen `Func` -Delegaten gibt den Typ des Rückgabewerts in der Signatur des Delegaten an.</span><span class="sxs-lookup"><span data-stu-id="358e5-163">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="358e5-164">Er ist kovariant (Schlüsselwort`out` ), wohingegen die anderen generischen Typparameter kontravariant sind (Schlüsselwort`in` ).</span><span class="sxs-lookup"><span data-stu-id="358e5-164">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="358e5-165">Dies wird im folgenden Code veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="358e5-165">The following code illustrates this.</span></span> <span data-ttu-id="358e5-166">Im ersten Codeabschnitt wird eine Klasse mit dem Namen `Base`, eine Klasse mit dem Namen `Derived` , die `Base`erbt, und eine weitere Klasse mit einer `static` -Methode (`Shared` in Visual Basic) mit dem Namen `MyMethod`definiert.</span><span class="sxs-lookup"><span data-stu-id="358e5-166">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="358e5-167">Die Methode akzeptiert eine Instanz von `Base` und gibt eine Instanz von `Derived` zurück.</span><span class="sxs-lookup"><span data-stu-id="358e5-167">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="358e5-168">(Wenn das Argument eine Instanz von `Derived` ist, gibt `MyMethod` diese zurück. Wenn das Argument eine Instanz von `Base` ist, gibt `MyMethod` eine neue Instanz von `Derived` zurück.) Im Beispiel wird in `Main()` eine Instanz von `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) erstellt, die `MyMethod` darstellt und in der Variablen `f1` gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="358e5-168">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="358e5-169">Der zweite Codeabschnitt zeigt, dass der Delegat einer Variablen vom Typ `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic) zugewiesen werden kann, da der Rückgabetyp kovariant ist.</span><span class="sxs-lookup"><span data-stu-id="358e5-169">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="358e5-170">Der dritte Codeabschnitt zeigt, dass der Delegat einer Variablen vom Typ `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic) zugewiesen werden kann, da der Parametertyp kontravariant ist.</span><span class="sxs-lookup"><span data-stu-id="358e5-170">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="358e5-171">Der letzte Codeabschnitt zeigt, dass der Delegat einer Variablen vom Typ `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic) zugewiesen werden kann, wobei die Auswirkungen des kontravarianten Parametertyps und des kovarianten Rückgabewerttyps kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="358e5-171">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-generic-and-non-generic-delegates"></a><span data-ttu-id="358e5-172">Varianz in generischen und nicht generischen Delegaten</span><span class="sxs-lookup"><span data-stu-id="358e5-172">Variance in Generic and Non-Generic Delegates</span></span>  
 <span data-ttu-id="358e5-173">Im obigen Code passt die Signatur von `MyMethod` exakt zur Signatur des erstellten generischen Delegaten `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="358e5-173">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="358e5-174">Das Beispiel zeigt, dass dieser generische Delegat in Variablen oder Methodenparametern mit weiter abgeleiteten Parametertypen und weniger abgeleiteten Rückgabetypen gespeichert werden kann, solange alle Delegattypen aus dem generischen Delegattyp <xref:System.Func%602>erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="358e5-174">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="358e5-175">Dies ist ein wichtiger Punkt.</span><span class="sxs-lookup"><span data-stu-id="358e5-175">This is an important point.</span></span> <span data-ttu-id="358e5-176">Kovarianz und Kontravarianz haben in den Typparametern generischer Delegaten ähnliche Auswirkungen wie bei der normalen Delegatbindung (siehe [Varianz in Delegaten (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) und [Varianz in Delegaten (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="358e5-176">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="358e5-177">Die Varianz bei der Delegatbindung funktioniert jedoch bei allen Delegattypen und nicht nur bei generischen Delegattypen, die über variante Typparameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="358e5-177">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="358e5-178">Darüber hinaus kann durch die Varianz bei der Delegatbindung eine Methode an einen beliebigen Delegaten gebunden werden, der restriktivere Parametertypen und einen weniger restriktiven Rückgabetyp verwendet, wohingegen die Zuweisung generischer Delegaten nur funktioniert, wenn beide Delegattypen aus der gleichen generischen Typdefinition erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="358e5-178">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="358e5-179">Im folgenden Beispiel werden die kombinierten Effekte von Varianz in der Delegatbindung und Varianz bei generischen Typparametern veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="358e5-179">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="358e5-180">Im Beispiel wird eine Typhierarchie definiert, die drei Typen beinhaltet, vom am wenigsten abgeleiteten Typ (`Type1`) bis zum am weitesten abgeleiteten Typ (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="358e5-180">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="358e5-181">Bei der normalen Delegatbindung wird die Varianz verwendet, um eine Methode mit dem Parametertyp `Type1` und dem Rückgabetyp `Type3` an einen generischen Delegaten mit dem Parametertyp `Type2` und dem Rückgabetyp `Type2`zu binden.</span><span class="sxs-lookup"><span data-stu-id="358e5-181">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="358e5-182">Der resultierende generische Delegat wird anschließend einer anderen Variablen zugewiesen, deren generischer Delegattyp einen Parameter vom Typ `Type3` und den Rückgabetyp `Type1`hat. Hierbei werden Kovarianz und Kontravarianz generischer Typparameter verwendet.</span><span class="sxs-lookup"><span data-stu-id="358e5-182">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="358e5-183">Bei der zweiten Zuweisung müssen sowohl der Variablentyp als auch der Delegattyp mit der gleichen generischen Typdefinition erstellt werden, in diesem Fall <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="358e5-183">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="defining-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="358e5-184">Definieren von varianten generischen Schnittstellen und Delegaten</span><span class="sxs-lookup"><span data-stu-id="358e5-184">Defining Variant Generic Interfaces and Delegates</span></span>
 <span data-ttu-id="358e5-185">Ab .NET Framework 4 verfügen Visual Basic und C# über Schlüsselwörter, mit denen die generischen Typparameter von Schnittstellen und Delegaten als kovariant oder kontravariant gekennzeichnet werden können.</span><span class="sxs-lookup"><span data-stu-id="358e5-185">Starting with the .NET Framework 4, Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="358e5-186">Beginnen mit .NET Framework, Version 2.0, unterstützt die Common Language Runtime Varianzkennzeichnungen für generische Typparameter.</span><span class="sxs-lookup"><span data-stu-id="358e5-186">Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.</span></span> <span data-ttu-id="358e5-187">Vor .NET Framework 4 war Microsoft Intermediate Language (MSIL) die einzige Möglichkeit, eine generische Klasse zu definieren, die über diese Kennzeichnungen verfügt – entweder durch Kompilieren der Klasse mit [Ilasm.exe (IL-Assembler)](../../framework/tools/ilasm-exe-il-assembler.md) oder durch Ausgeben in einer dynamischen Assembly.</span><span class="sxs-lookup"><span data-stu-id="358e5-187">Prior to the .NET Framework 4, the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.</span></span>  
  
 <span data-ttu-id="358e5-188">Ein kovarianter Typparameter wird mit dem `out` -Schlüsselwort (`Out` -Schlüsselwort in Visual Basic, `+` für den [MSIL-Assembler](../../framework/tools/ilasm-exe-il-assembler.md)) gekennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="358e5-188">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="358e5-189">Sie können einen kovarianten Typparameter als Rückgabewert einer Methode verwenden, die zu einer Schnittstelle gehört, oder als Rückgabetyp eines Delegaten.</span><span class="sxs-lookup"><span data-stu-id="358e5-189">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="358e5-190">Sie können einen kovarianten Typparameter nicht als generische Typeinschränkung für Schnittstellenmethoden verwenden.</span><span class="sxs-lookup"><span data-stu-id="358e5-190">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="358e5-191">Wenn eine Methode einer Schnittstelle über einen Parameter verfügt, der ein generischer Delegattyp ist, kann ein kovarianter Typparameter des Schnittstellentyps verwendet werden, um einen kontravarianten Typparameter des Delegattyps anzugeben.</span><span class="sxs-lookup"><span data-stu-id="358e5-191">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="358e5-192">Ein kontravarianter Typparameter wird mit dem `in` -Schlüsselwort (`In` -Schlüsselwort in Visual Basic, `-` für den [MSIL-Assembler](../../framework/tools/ilasm-exe-il-assembler.md)) gekennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="358e5-192">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="358e5-193">Sie können einen kontravarianten Typparameter als Typ eines Parameters einer Methode verwenden, die zu einer Schnittstelle gehört, oder als Typ eines Parameters eines Delegaten.</span><span class="sxs-lookup"><span data-stu-id="358e5-193">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="358e5-194">Sie können einen kontravarianten Typparameter als generische Typeinschränkung für Schnittstellenmethoden verwenden.</span><span class="sxs-lookup"><span data-stu-id="358e5-194">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="358e5-195">Nur Schnittstellentypen und Delegattypen können über variante Typparameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="358e5-195">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="358e5-196">Eine Schnittstelle oder ein Delegattyp kann sowohl kovariante, als auch kontravariante Typparameter haben.</span><span class="sxs-lookup"><span data-stu-id="358e5-196">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="358e5-197">In Visual Basic und C# müssen die Regeln zum Verwenden von kovarianten und kontravarianten Typparametern eingehalten werden, und es ist nicht möglich, Kovarianz- und Kontravarianzkennzeichnungen zu den Typparametern anderer Typen als Schnittstellen- und Delegattypen hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="358e5-197">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span> <span data-ttu-id="358e5-198">Der [MSIL-Assembler](../../framework/tools/ilasm-exe-il-assembler.md) führt keine solchen Überprüfungen aus, es wird aber eine <xref:System.TypeLoadException> ausgelöst, wenn Sie versuchen, einen Typ zu laden, der gegen die Regeln verstößt.</span><span class="sxs-lookup"><span data-stu-id="358e5-198">The [MSIL Assembler](../../framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.</span></span>  
  
 <span data-ttu-id="358e5-199">Weitere Informationen und einen Beispielcode finden Sie unter [Varianz in generischen Schnittstellen (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) und [Varianz in generischen Schnittstellen (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="358e5-199">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-variant-generic-interface-and-delegate-types"></a><span data-ttu-id="358e5-200">Liste der varianten generischen Schnittstellen und Delegattypen</span><span class="sxs-lookup"><span data-stu-id="358e5-200">List of Variant Generic Interface and Delegate Types</span></span>
 <span data-ttu-id="358e5-201">In .NET Framework 4 verfügen die folgenden Schnittstellen- und Delegattypen über kovariante und/oder kontravariante Typparameter:</span><span class="sxs-lookup"><span data-stu-id="358e5-201">In the .NET Framework 4, the following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="358e5-202">Typ</span><span class="sxs-lookup"><span data-stu-id="358e5-202">Type</span></span>|<span data-ttu-id="358e5-203">Kovariante Typparameter</span><span class="sxs-lookup"><span data-stu-id="358e5-203">Covariant type parameters</span></span>|<span data-ttu-id="358e5-204">Kontravariante Typparameter</span><span class="sxs-lookup"><span data-stu-id="358e5-204">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="358e5-205"><xref:System.Action%601> bis <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="358e5-205"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="358e5-206">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-206">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="358e5-207">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-207">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="358e5-208">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-208">Yes</span></span>|<span data-ttu-id="358e5-209">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-209">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="358e5-210">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-210">Yes</span></span>||  
|<span data-ttu-id="358e5-211"><xref:System.Func%602> bis <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="358e5-211"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="358e5-212">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-212">Yes</span></span>|<span data-ttu-id="358e5-213">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-213">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="358e5-214">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-214">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="358e5-215">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="358e5-216">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-216">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="358e5-217">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="358e5-218">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-218">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="358e5-219">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-219">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="358e5-220">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="358e5-221">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-221">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="358e5-222">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-222">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="358e5-223">Ja</span><span class="sxs-lookup"><span data-stu-id="358e5-223">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="358e5-224">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="358e5-224">See also</span></span>

- [<span data-ttu-id="358e5-225">Kovarianz und Kontravarianz (C#)</span><span class="sxs-lookup"><span data-stu-id="358e5-225">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="358e5-226">Kovarianz und Kontravarianz (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="358e5-226">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="358e5-227">Variance in Delegates (C#) (Varianz bei Delegaten (C#))</span><span class="sxs-lookup"><span data-stu-id="358e5-227">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="358e5-228">Variance in Delegates (Visual Basic) (Varianz in Delegaten (Visual Basic))</span><span class="sxs-lookup"><span data-stu-id="358e5-228">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
