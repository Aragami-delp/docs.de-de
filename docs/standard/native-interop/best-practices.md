---
title: 'Bewährte Methoden für native Interoperabilität: .NET'
description: Erfahren Sie mehr über bewährte Methoden für die Einrichtung von Schnittstellen mit nativen Komponenten in .NET.
ms.date: 01/18/2019
ms.openlocfilehash: e5d96471e796dca712d25d2d9e2609508180d83f
ms.sourcegitcommit: a9b8945630426a575ab0a332e568edc807666d1b
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 03/30/2020
ms.locfileid: "80391220"
---
# <a name="native-interoperability-best-practices"></a><span data-ttu-id="e4e57-103">Bewährte Methoden für native Interoperabilität</span><span class="sxs-lookup"><span data-stu-id="e4e57-103">Native interoperability best practices</span></span>

<span data-ttu-id="e4e57-104">.NET bietet verschiedene Möglichkeiten zum Anpassen Ihres Codes für die native Interoperabilität.</span><span class="sxs-lookup"><span data-stu-id="e4e57-104">.NET gives you a variety of ways to customize your native interoperability code.</span></span> <span data-ttu-id="e4e57-105">Dieser Artikel bietet einen Leitfaden, den die .NET-Teams von Microsoft in Bezug auf die native Interoperabilität befolgen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-105">This article includes the guidance that Microsoft's .NET teams follow for native interoperability.</span></span>

## <a name="general-guidance"></a><span data-ttu-id="e4e57-106">Allgemeine Anleitung</span><span class="sxs-lookup"><span data-stu-id="e4e57-106">General guidance</span></span>

<span data-ttu-id="e4e57-107">Die Anleitungen in diesem Abschnitt gelten für alle Interoperabilitätsszenarien.</span><span class="sxs-lookup"><span data-stu-id="e4e57-107">The guidance in this section applies to all interop scenarios.</span></span>

- <span data-ttu-id="e4e57-108">✔️ VERWENDEN Sie die gleichen Benennungen und die gleiche Groß- und Kleinschreibung für Ihre Methoden und Parameter wie die native Methode, die Sie aufrufen möchten.</span><span class="sxs-lookup"><span data-stu-id="e4e57-108">✔️ DO use the same naming and capitalization for your methods and parameters as the native method you want to call.</span></span>
- <span data-ttu-id="e4e57-109">✔️ ERWÄGEN Sie die Verwendung der gleichen Benennungen und der gleichen Groß- und Kleinschreibung für Werte von Konstanten.</span><span class="sxs-lookup"><span data-stu-id="e4e57-109">✔️ CONSIDER using the same naming and capitalization for constant values.</span></span>
- <span data-ttu-id="e4e57-110">✔️ VERWENDEN Sie .NET-Typen, die dem nativen Typ am ähnlichsten sind.</span><span class="sxs-lookup"><span data-stu-id="e4e57-110">✔️ DO use .NET types that map closest to the native type.</span></span> <span data-ttu-id="e4e57-111">Wenn z.B. der native Typ in C# `unsigned int` ist, verwenden Sie `uint`.</span><span class="sxs-lookup"><span data-stu-id="e4e57-111">For example, in C#, use `uint` when the native type is `unsigned int`.</span></span>
- <span data-ttu-id="e4e57-112">✔️ VERWENDEN Sie nur `[In]`- und `[Out]`-Attribute, wenn sich das gewünschte Verhalten vom Standardverhalten unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="e4e57-112">✔️ DO only use `[In]` and `[Out]` attributes when the behavior you want differs from the default behavior.</span></span>
- <span data-ttu-id="e4e57-113">✔️ ERWÄGEN Sie die Verwendung von <xref:System.Buffers.ArrayPool%601?displayProperty=nameWithType>, um Ihre nativen Arraypuffer in einem Pool zusammenzufassen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-113">✔️ CONSIDER using <xref:System.Buffers.ArrayPool%601?displayProperty=nameWithType> to pool your native array buffers.</span></span>
- <span data-ttu-id="e4e57-114">✔️ ERWÄGEN Sie eine Umschließung Ihrer P/Invoke-Deklarationen in einer Klasse mit dem gleichen Namen und der gleichen Groß- und Kleinschreibung wie in Ihrer nativen Bibliothek.</span><span class="sxs-lookup"><span data-stu-id="e4e57-114">✔️ CONSIDER wrapping your P/Invoke declarations in a class with the same name and capitalization as your native library.</span></span>
  - <span data-ttu-id="e4e57-115">Damit können Ihre `[DllImport]`-Attribute das C#-Sprachfeature `nameof` verwenden, um den Namen der nativen Bibliothek zu übergeben, und so sicherstellen, dass der Name der nativen Bibliothek nicht falsch geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="e4e57-115">This allows your `[DllImport]` attributes to use the C# `nameof` language feature to pass in the name of the native library and ensure that you didn't misspell the name of the native library.</span></span>

## <a name="dllimport-attribute-settings"></a><span data-ttu-id="e4e57-116">Attributeinstellungen für „DllImport“</span><span class="sxs-lookup"><span data-stu-id="e4e57-116">DllImport attribute settings</span></span>

| <span data-ttu-id="e4e57-117">Einstellung</span><span class="sxs-lookup"><span data-stu-id="e4e57-117">Setting</span></span> | <span data-ttu-id="e4e57-118">Standard</span><span class="sxs-lookup"><span data-stu-id="e4e57-118">Default</span></span> | <span data-ttu-id="e4e57-119">Empfehlung</span><span class="sxs-lookup"><span data-stu-id="e4e57-119">Recommendation</span></span> | <span data-ttu-id="e4e57-120">Details</span><span class="sxs-lookup"><span data-stu-id="e4e57-120">Details</span></span> |
|---------|---------|----------------|---------|
| <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>   | `true` |  <span data-ttu-id="e4e57-121">Behalten Sie den Standardwert bei.</span><span class="sxs-lookup"><span data-stu-id="e4e57-121">keep default</span></span>  | <span data-ttu-id="e4e57-122">Wenn diese Einstellung explizit auf „false“ festgelegt wird, werden fehlerhafte HRESULT-Rückgabewerte zu Ausnahmen umgewandelt (und der Rückgabewert in der Definition wird dadurch NULL).</span><span class="sxs-lookup"><span data-stu-id="e4e57-122">When this is explicitly set to false, failed HRESULT return values will be turned into exceptions (and the return value in the definition becomes null as a result).</span></span>|
| <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> | `false`  | <span data-ttu-id="e4e57-123">Hängt von der API ab.</span><span class="sxs-lookup"><span data-stu-id="e4e57-123">depends on the API</span></span>  | <span data-ttu-id="e4e57-124">Legen Sie diese Einstellung auf „true“ fest, wenn die API „GetLastError“ verwendet, und verwenden Sie „Marshal.GetLastWin32Error“, um den Wert abzurufen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-124">Set this to true if the API uses GetLastError and use Marshal.GetLastWin32Error to get the value.</span></span> <span data-ttu-id="e4e57-125">Wenn die API eine Bedingung festlegt, die besagt, dass ein Fehler vorliegt, rufen Sie den Fehler ab, bevor Sie weitere Aufrufe senden, um ein versehentliches Überschreiben zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="e4e57-125">If the API sets a condition that says it has an error, get the error before making other calls to avoid inadvertently having it overwritten.</span></span>|
| <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> | <span data-ttu-id="e4e57-126">`CharSet.None` – Fallback auf das Verhalten `CharSet.Ansi`.</span><span class="sxs-lookup"><span data-stu-id="e4e57-126">`CharSet.None`, which falls back to `CharSet.Ansi` behavior</span></span>  | <span data-ttu-id="e4e57-127">Verwenden Sie explizit `CharSet.Unicode` oder `CharSet.Ansi`, wenn in der Definition Zeichenfolgen oder Zeichen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="e4e57-127">Explicitly  use `CharSet.Unicode` or `CharSet.Ansi` when strings or characters are present in the definition</span></span> | <span data-ttu-id="e4e57-128">Damit wird das Marshallingverhalten von Zeichenfolgen angegeben und festgelegt, was `ExactSpelling` bei `false` ausführt.</span><span class="sxs-lookup"><span data-stu-id="e4e57-128">This specifies marshaling behavior of strings and what `ExactSpelling` does when `false`.</span></span> <span data-ttu-id="e4e57-129">Beachten Sie, dass `CharSet.Ansi` tatsächlich UTF8 oder Unix ist.</span><span class="sxs-lookup"><span data-stu-id="e4e57-129">Note that `CharSet.Ansi` is actually UTF8 on Unix.</span></span> <span data-ttu-id="e4e57-130">_In den meisten Fällen_ verwendet Windows Unicode, Unix verwendet UTF8.</span><span class="sxs-lookup"><span data-stu-id="e4e57-130">_Most_ of the time Windows uses Unicode while Unix uses UTF8.</span></span> <span data-ttu-id="e4e57-131">Weitere Informationen finden Sie in der [Dokumentation zu Zeichensätzen](./charset.md).</span><span class="sxs-lookup"><span data-stu-id="e4e57-131">See more information on the [documentation on charsets](./charset.md).</span></span> |
| <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> | `false` | `true`             | <span data-ttu-id="e4e57-132">Legen Sie diesen Wert auf „true“ fest, um einen leichten Leistungsvorteil zu erzielen, da die Runtime nicht nach alternativen Funktionsnamen mit dem Suffix „A“ oder „W“ sucht, je nach Wert der Einstellung von `CharSet` („A“ für `CharSet.Ansi` und „W“ für `CharSet.Unicode`).</span><span class="sxs-lookup"><span data-stu-id="e4e57-132">Set this to true and gain a slight perf benefit as the runtime will not look for alternate function names with either an "A" or "W" suffix depending on the value of the `CharSet` setting ("A" for `CharSet.Ansi` and "W" for `CharSet.Unicode`).</span></span> |

## <a name="string-parameters"></a><span data-ttu-id="e4e57-133">Zeichenfolgenparameter</span><span class="sxs-lookup"><span data-stu-id="e4e57-133">String parameters</span></span>

<span data-ttu-id="e4e57-134">Wenn es sich um einen Unicode-Zeichensatz handelt oder das Argument explizit als `[MarshalAs(UnmanagedType.LPWSTR)]` gekennzeichnet ist _und_ die Zeichenfolge per Wert (nicht als `ref` oder `out`) übergeben wird, wird die Zeichenfolge angeheftet und vom nativen Code direkt verwendet (nicht kopiert).</span><span class="sxs-lookup"><span data-stu-id="e4e57-134">When the CharSet is Unicode or the argument is explicitly marked as `[MarshalAs(UnmanagedType.LPWSTR)]` _and_ the string is passed by value (not `ref` or `out`), the string will be pinned and used directly by native code (rather than copied).</span></span>

<span data-ttu-id="e4e57-135">Denken Sie daran, `[DllImport]` als `Charset.Unicode` zu kennzeichnen, es sei denn, Sie möchten explizit, dass Ihre Zeichenfolgen als ANSI verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-135">Remember to mark the `[DllImport]` as `Charset.Unicode` unless you explicitly want ANSI treatment of your strings.</span></span>

<span data-ttu-id="e4e57-136">❌ VERWENDEN SIE KEINE `[Out] string`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e4e57-136">❌ DO NOT use `[Out] string` parameters.</span></span> <span data-ttu-id="e4e57-137">Zeichenfolgenparameter, die per Wert mit dem `[Out]`-Attribut übergeben werden, können die Runtime destabilisieren, wenn die Zeichenfolge internalisiert ist.</span><span class="sxs-lookup"><span data-stu-id="e4e57-137">String parameters passed by value with the `[Out]` attribute can destabilize the runtime if the string is an interned string.</span></span> <span data-ttu-id="e4e57-138">Weitere Informationen zum Internalisieren von Zeichenfolgen finden Sie in der Dokumentation zu <xref:System.String.Intern%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e4e57-138">See more information about string interning in the documentation for <xref:System.String.Intern%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="e4e57-139">❌ VERMEIDEN Sie `StringBuilder`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e4e57-139">❌ AVOID `StringBuilder` parameters.</span></span> <span data-ttu-id="e4e57-140">`StringBuilder`Marshalling erzeugt *immer* eine native Pufferkopie.</span><span class="sxs-lookup"><span data-stu-id="e4e57-140">`StringBuilder` marshaling *always* creates a native buffer copy.</span></span> <span data-ttu-id="e4e57-141">Dies kann extrem ineffizient sein.</span><span class="sxs-lookup"><span data-stu-id="e4e57-141">As such, it can be extremely inefficient.</span></span> <span data-ttu-id="e4e57-142">Sehen Sie sich das folgende typische Szenario an, in dem eine Windows-API aufgerufen wird, die eine Zeichenfolge akzeptiert:</span><span class="sxs-lookup"><span data-stu-id="e4e57-142">Take the typical scenario of calling a Windows API that takes a string:</span></span>

1. <span data-ttu-id="e4e57-143">Erstellen Sie einen StringBuilder mit der gewünschten Kapazität (ordnet die verwaltete Kapazität zu) **{1}**</span><span class="sxs-lookup"><span data-stu-id="e4e57-143">Create a SB of the desired capacity (allocates managed capacity) **{1}**</span></span>
2. <span data-ttu-id="e4e57-144">Aufrufen</span><span class="sxs-lookup"><span data-stu-id="e4e57-144">Invoke</span></span>
   1. <span data-ttu-id="e4e57-145">Ordnet einen nativen Puffer zu **{2}**</span><span class="sxs-lookup"><span data-stu-id="e4e57-145">Allocates a native buffer **{2}**</span></span>
   2. <span data-ttu-id="e4e57-146">Kopiert den Inhalt im Fall von `[In]` _(Standard für `StringBuilder`-Parameter)_</span><span class="sxs-lookup"><span data-stu-id="e4e57-146">Copies the contents if `[In]` _(the default for a `StringBuilder` parameter)_</span></span>
   3. <span data-ttu-id="e4e57-147">Kopiert den nativen Puffer in ein neu zugeordnetes verwaltetes Array im Fall von `[Out]` **{3}** _(ebenfalls Standard für `StringBuilder`)_</span><span class="sxs-lookup"><span data-stu-id="e4e57-147">Copies the native buffer into a newly allocated managed array if `[Out]` **{3}** _(also the default for `StringBuilder`)_</span></span>
3. <span data-ttu-id="e4e57-148">`ToString()` ordnet ein weiteres verwaltetes Array zu **{4}**</span><span class="sxs-lookup"><span data-stu-id="e4e57-148">`ToString()` allocates yet another managed array **{4}**</span></span>

<span data-ttu-id="e4e57-149">Damit haben wir *{4}* Zuordnungen, um eine Zeichenfolge aus dem nativen Code abzurufen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-149">That is *{4}* allocations to get a string out of native code.</span></span> <span data-ttu-id="e4e57-150">Die beste Möglichkeit, um dies zu beschränken, besteht darin, den `StringBuilder` in einem weiteren Aufruf wiederzuverwenden, damit wird aber dennoch nur *1* Zuordnung eingespart.</span><span class="sxs-lookup"><span data-stu-id="e4e57-150">The best you can do to limit this is to reuse the `StringBuilder` in another call but this still only saves *1* allocation.</span></span> <span data-ttu-id="e4e57-151">Es ist viel besser, einen Zeichenpuffer aus dem `ArrayPool` zu verwenden und zwischenzuspeichern – damit benötigen Sie in nachfolgenden Aufrufen nur die Zuordnung für `ToString()`.</span><span class="sxs-lookup"><span data-stu-id="e4e57-151">It's much better to use and cache a character buffer from `ArrayPool`- you can then get down to just the allocation for the `ToString()` on subsequent calls.</span></span>

<span data-ttu-id="e4e57-152">Ein weiteres Problem bei `StringBuilder` ist, dass immer der Rückgabepuffer bis zum ersten NULL-Zeichen zurückkopiert wird.</span><span class="sxs-lookup"><span data-stu-id="e4e57-152">The other issue with `StringBuilder` is that it always copies the return buffer back up to the first null.</span></span> <span data-ttu-id="e4e57-153">Wenn die zurückgegebene Zeichenfolge nicht beendet oder mit einem doppelten NULL-Zeichen beendet wird, ist „P/Invoke“ bestenfalls falsch.</span><span class="sxs-lookup"><span data-stu-id="e4e57-153">If the passed back string isn't terminated or is a double-null-terminated string, your P/Invoke is incorrect at best.</span></span>

<span data-ttu-id="e4e57-154">Wenn Sie `StringBuilder`*tatsächlich* verwenden, besteht eine weitere Besonderheit darin, dass die Kapazität **kein** verborgenes NULL-Zeichen umfasst, das bei der Interoperabilität immer berücksichtigt wird.</span><span class="sxs-lookup"><span data-stu-id="e4e57-154">If you *do* use `StringBuilder`, one last gotcha is that the capacity does **not** include a hidden null, which is always accounted for in interop.</span></span> <span data-ttu-id="e4e57-155">Das wird häufig falsch gemacht, da die meisten APIs die Größe des Puffers *einschließlich* des NULL-Zeichens erwarten.</span><span class="sxs-lookup"><span data-stu-id="e4e57-155">It's common for people to get this wrong as most APIs want the size of the buffer *including* the null.</span></span> <span data-ttu-id="e4e57-156">Dies kann zu unnötigen bzw. verschwendeten Zuordnungen führen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-156">This can result in wasted/unnecessary allocations.</span></span> <span data-ttu-id="e4e57-157">Darüber hinaus verhindert diese Besonderheit, dass die Runtime das Marshalling von `StringBuilder` optimiert, um die Erstellung von Kopien zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="e4e57-157">Additionally, this gotcha prevents the runtime from optimizing `StringBuilder` marshaling to minimize copies.</span></span>

<span data-ttu-id="e4e57-158">✔️ ERWÄGEN Sie die Verwendung von `char[]`s aus einem `ArrayPool`.</span><span class="sxs-lookup"><span data-stu-id="e4e57-158">✔️ CONSIDER using `char[]`s from an `ArrayPool`.</span></span>

<span data-ttu-id="e4e57-159">Weitere Informationen zum Marshalling von Zeichenfolgen finden Sie unter [Standardmäßiges Marshalling für Zeichenfolgen](../../framework/interop/default-marshaling-for-strings.md) und [Anpassen des Zeichenfolgenmarshallings](customize-parameter-marshaling.md#customizing-string-parameters).</span><span class="sxs-lookup"><span data-stu-id="e4e57-159">For more information on string marshaling, see [Default Marshaling for Strings](../../framework/interop/default-marshaling-for-strings.md) and [Customizing string marshaling](customize-parameter-marshaling.md#customizing-string-parameters).</span></span>

> <span data-ttu-id="e4e57-160">__Windows-spezifisch:__ Bei `[Out]`-Zeichenfolgen verwendet die CLR (Common Language Runtime) standardmäßig `CoTaskMemFree`, um Zeichenfolgen freizugeben, oder `SysStringFree` bei Zeichenfolgen, die als `UnmanagedType.BSTR` gekennzeichnet sind.</span><span class="sxs-lookup"><span data-stu-id="e4e57-160">__Windows Specific__ For `[Out]` strings the CLR will use `CoTaskMemFree` by default to free strings or `SysStringFree` for strings that are marked as `UnmanagedType.BSTR`.</span></span>
> <span data-ttu-id="e4e57-161">**Bei den meisten APIs mit Puffer für Ausgabezeichenfolgen gilt Folgendes**: Die übergebene Zeichenanzahl muss das NULL-Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="e4e57-161">**For most APIs with an output string buffer:** The passed in character count must include the null.</span></span> <span data-ttu-id="e4e57-162">Wenn der zurückgegebene Wert kleiner ist als die Zeichenanzahl, ist der Aufruf erfolgreich und der Wert ist die Anzahl der Zeichen *ohne* das nachgestellte NULL-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-162">If the returned value is less than the passed in character count the call has succeeded and the value is the number of characters *without* the trailing null.</span></span> <span data-ttu-id="e4e57-163">Andernfalls ist die Anzahl die erforderliche Größe des Puffers *einschließlich* des NULL-Zeichens.</span><span class="sxs-lookup"><span data-stu-id="e4e57-163">Otherwise the count is the required size of the buffer *including* the null character.</span></span>
>
> - <span data-ttu-id="e4e57-164">5 übergeben, 4 abrufen: Die Zeichenfolge ist 4 Zeichen lang und umfasst ein nachgestelltes NULL-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-164">Pass in 5, get 4: The string is 4 characters long with a trailing null.</span></span>
> - <span data-ttu-id="e4e57-165">5 übergeben, 6 abrufen: Die Zeichenfolge ist 5 Zeichen lang und erfordert einen Puffer mit 6 Zeichen für das NULL-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-165">Pass in 5, get 6: The string is 5 characters long, need a 6 character buffer to hold the null.</span></span>
> [<span data-ttu-id="e4e57-166">Windows-Datentypen für Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="e4e57-166">Windows Data Types for Strings</span></span>](/windows/desktop/Intl/windows-data-types-for-strings)

## <a name="boolean-parameters-and-fields"></a><span data-ttu-id="e4e57-167">Boolesche Parameter und Felder</span><span class="sxs-lookup"><span data-stu-id="e4e57-167">Boolean parameters and fields</span></span>

<span data-ttu-id="e4e57-168">Bei booleschen Werten passieren leicht Fehler.</span><span class="sxs-lookup"><span data-stu-id="e4e57-168">Booleans are easy to mess up.</span></span> <span data-ttu-id="e4e57-169">Standardmäßig erfolgt für einen `bool`-Wert von .NET ein Marshalling in einen `BOOL`-Wert in Windows. Dort handelt es sich um einen 4 Byte langen Wert.</span><span class="sxs-lookup"><span data-stu-id="e4e57-169">By default, a .NET `bool` is marshaled to a Windows `BOOL`, where it's a 4-byte value.</span></span> <span data-ttu-id="e4e57-170">Die Typen `_Bool` und `bool` in C und C++ sind jedoch *Einzelbytewerte*.</span><span class="sxs-lookup"><span data-stu-id="e4e57-170">However, the `_Bool`, and `bool` types in C and C++ are a *single* byte.</span></span> <span data-ttu-id="e4e57-171">Dies kann zu Bugs führen, die sich nur sehr schwer auffinden lassen, da der halbe Rückgabewert verworfen wird, sich das Ergebnis aber nur *möglicherweise* ändert.</span><span class="sxs-lookup"><span data-stu-id="e4e57-171">This can lead to hard to track down bugs as half the return value will be discarded, which will only *potentially* change the result.</span></span> <span data-ttu-id="e4e57-172">Weitere Informationen zum Marshalling von `bool`-Werten aus .NET in `bool`-Typen in C oder C++ finden Sie in der Dokumentation zum [Anpassen des Marshallings von booleschen Feldern](customize-struct-marshaling.md#customizing-boolean-field-marshaling).</span><span class="sxs-lookup"><span data-stu-id="e4e57-172">For more for information on marshaling .NET `bool` values to C or C++ `bool` types, see the documentation on [customizing boolean field marshaling](customize-struct-marshaling.md#customizing-boolean-field-marshaling).</span></span>

## <a name="guids"></a><span data-ttu-id="e4e57-173">GUIDs</span><span class="sxs-lookup"><span data-stu-id="e4e57-173">GUIDs</span></span>

<span data-ttu-id="e4e57-174">GUIDs können direkt in Signaturen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-174">GUIDs are usable directly in signatures.</span></span> <span data-ttu-id="e4e57-175">Viele Windows-APIs akzeptieren `GUID&`-Typen wie `REFIID`.</span><span class="sxs-lookup"><span data-stu-id="e4e57-175">Many Windows APIs take `GUID&` type aliases like `REFIID`.</span></span> <span data-ttu-id="e4e57-176">Bei der Übergabe per Verweis können diese durch `ref` oder mit dem Attribut `[MarshalAs(UnmanagedType.LPStruct)]` übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-176">When passed by ref, they can either be passed by `ref` or with the `[MarshalAs(UnmanagedType.LPStruct)]` attribute.</span></span>

| <span data-ttu-id="e4e57-177">GUID</span><span class="sxs-lookup"><span data-stu-id="e4e57-177">GUID</span></span> | <span data-ttu-id="e4e57-178">By-ref-GUID</span><span class="sxs-lookup"><span data-stu-id="e4e57-178">By-ref GUID</span></span> |
|------|-------------|
| `KNOWNFOLDERID` | `REFKNOWNFOLDERID` |

<span data-ttu-id="e4e57-179">❌ VERWENDEN SIE NICHT `[MarshalAs(UnmanagedType.LPStruct)]` für etwas anderes als für `ref`-GUID-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e4e57-179">❌ DO NOT Use `[MarshalAs(UnmanagedType.LPStruct)]` for anything other than `ref` GUID parameters.</span></span>

## <a name="blittable-types"></a><span data-ttu-id="e4e57-180">Für Blitting geeignete Typen</span><span class="sxs-lookup"><span data-stu-id="e4e57-180">Blittable types</span></span>

<span data-ttu-id="e4e57-181">Für Blitting geeignete Typen sind Typen, die in verwaltetem und nativem Code die gleiche Darstellung auf Bitebene aufweisen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-181">Blittable types are types that have the same bit-level representation in managed and native code.</span></span> <span data-ttu-id="e4e57-182">Als solche müssen sie nicht in ein anderes Format konvertiert werden, um ein Marshalling in den und aus dem nativen Code zu ermöglichen. Da dies die Leistung verbessert, sind diese Typen zu bevorzugen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-182">As such they do not need to be converted to another format to be marshaled to and from native code, and as this improves performance they should be preferred.</span></span>

<span data-ttu-id="e4e57-183">**Für Blitting geeignete Typen**:</span><span class="sxs-lookup"><span data-stu-id="e4e57-183">**Blittable types:**</span></span>

- <span data-ttu-id="e4e57-184">`byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `single`, `double`</span><span class="sxs-lookup"><span data-stu-id="e4e57-184">`byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `single`, `double`</span></span>
- <span data-ttu-id="e4e57-185">Nicht geschachtelte eindimensionale Arrays aus für Blitting geeigneten Typen (z.B. `int[]`)</span><span class="sxs-lookup"><span data-stu-id="e4e57-185">non-nested one-dimensional arrays of blittable types (for example, `int[]`)</span></span>
- <span data-ttu-id="e4e57-186">Strukturen und Klassen mit festem Layout, die für Instanzfelder nur über für Blitting geeignete Typen verfügen</span><span class="sxs-lookup"><span data-stu-id="e4e57-186">structs and classes with fixed layout that only have blittable value types for instance fields</span></span>
  - <span data-ttu-id="e4e57-187">Ein festes Layout erfordert `[StructLayout(LayoutKind.Sequential)]` oder `[StructLayout(LayoutKind.Explicit)]`</span><span class="sxs-lookup"><span data-stu-id="e4e57-187">fixed layout requires `[StructLayout(LayoutKind.Sequential)]` or `[StructLayout(LayoutKind.Explicit)]`</span></span>
  - <span data-ttu-id="e4e57-188">Strukturen sind standardmäßig `LayoutKind.Sequential`, Klassen sind `LayoutKind.Auto`</span><span class="sxs-lookup"><span data-stu-id="e4e57-188">structs are `LayoutKind.Sequential` by default, classes are `LayoutKind.Auto`</span></span>

<span data-ttu-id="e4e57-189">**NICHT für Blitting geeignet**:</span><span class="sxs-lookup"><span data-stu-id="e4e57-189">**NOT blittable:**</span></span>

- `bool`

<span data-ttu-id="e4e57-190">**MANCHMAL für Blitting geeignet**:</span><span class="sxs-lookup"><span data-stu-id="e4e57-190">**SOMETIMES blittable:**</span></span>

- <span data-ttu-id="e4e57-191">`char`, `string`</span><span class="sxs-lookup"><span data-stu-id="e4e57-191">`char`, `string`</span></span>

<span data-ttu-id="e4e57-192">Wenn für Blitting geeignete Typen per Verweis übergeben werden, werden sie einfach vom Marshaller angeheftet, anstatt in einem temporären Puffer kopiert zu werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-192">When blittable types are passed by reference, they're simply pinned by the marshaller instead of being copied to an intermediate buffer.</span></span> <span data-ttu-id="e4e57-193">(Klassen werden von Natur aus per Verweis übergeben, Strukturen werden per Verweis übergeben, wenn sie mit `ref` oder `out` verwendet werden.)</span><span class="sxs-lookup"><span data-stu-id="e4e57-193">(Classes are inherently passed by reference, structs are passed by reference when used with `ref` or `out`.)</span></span>

<span data-ttu-id="e4e57-194">`char` ist in einem eindimensionalen Array **oder** bei Verwendung in einem Typen für Blitting geeignet, der explizit mit `[StructLayout]` mit `CharSet = CharSet.Unicode` gekennzeichnet ist.</span><span class="sxs-lookup"><span data-stu-id="e4e57-194">`char` is blittable in a one-dimensional array **or** if it's part of a type that contains it's explicitly marked with `[StructLayout]` with `CharSet = CharSet.Unicode`.</span></span>

```csharp
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct UnicodeCharStruct
{
    public char c;
}
```

<span data-ttu-id="e4e57-195">`string` ist für Blitting geeignet, wenn es nicht in einem anderen Typen enthalten ist und als Argument übergeben wird, das mit `[MarshalAs(UnmanagedType.LPWStr)]` gekennzeichnet ist oder in dem `CharSet = CharSet.Unicode` für `[DllImport]` festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="e4e57-195">`string` is blittable if it isn't contained in another type and it's being passed as an argument that is marked with `[MarshalAs(UnmanagedType.LPWStr)]` or the `[DllImport]` has `CharSet = CharSet.Unicode` set.</span></span>

<span data-ttu-id="e4e57-196">Sie können feststellen, ob ein Typ für Blitting geeignet ist, indem Sie versuchen, ein angeheftetes `GCHandle` zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-196">You can see if a type is blittable by attempting to create a pinned `GCHandle`.</span></span> <span data-ttu-id="e4e57-197">Wenn der Typ keine Zeichenfolge ist oder nicht als für Blitting geeignet betrachtet wird, löst `GCHandle.Alloc` eine `ArgumentException` aus.</span><span class="sxs-lookup"><span data-stu-id="e4e57-197">If the type isn't a string or considered blittable, `GCHandle.Alloc` will throw an `ArgumentException`.</span></span>

<span data-ttu-id="e4e57-198">✔️ LEGEN Sie Ihre Strukturen nach Möglichkeit als für Blitting geeignet fest.</span><span class="sxs-lookup"><span data-stu-id="e4e57-198">✔️ DO make your structures blittable when possible.</span></span>

<span data-ttu-id="e4e57-199">Weitere Informationen finden Sie unter:</span><span class="sxs-lookup"><span data-stu-id="e4e57-199">For more information, see:</span></span>

- [<span data-ttu-id="e4e57-200">Blitfähige und nicht blitfähige Typen</span><span class="sxs-lookup"><span data-stu-id="e4e57-200">Blittable and Non-Blittable Types</span></span>](../../framework/interop/blittable-and-non-blittable-types.md)
- [<span data-ttu-id="e4e57-201">Marshalling von Typen</span><span class="sxs-lookup"><span data-stu-id="e4e57-201">Type Marshaling</span></span>](type-marshaling.md)

## <a name="keeping-managed-objects-alive"></a><span data-ttu-id="e4e57-202">Beibehalten von verwalteten Objekten</span><span class="sxs-lookup"><span data-stu-id="e4e57-202">Keeping managed objects alive</span></span>

<span data-ttu-id="e4e57-203">`GC.KeepAlive()` stellt sicher, dass ein Objekt im Gültigkeitsbereich bleibt, bis die KeepAlive-Methode erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="e4e57-203">`GC.KeepAlive()` will ensure an object stays in scope until the KeepAlive method is hit.</span></span>

<span data-ttu-id="e4e57-204">[`HandleRef`](xref:System.Runtime.InteropServices.HandleRef) ermöglicht es dem Marshaller, ein Objekt während der Dauer eines P/Invoke beizubehalten.</span><span class="sxs-lookup"><span data-stu-id="e4e57-204">[`HandleRef`](xref:System.Runtime.InteropServices.HandleRef) allows the marshaller to keep an object alive for the duration of a P/Invoke.</span></span> <span data-ttu-id="e4e57-205">Es kann statt `IntPtr` in Methodensignaturen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-205">It can be used instead of `IntPtr` in method signatures.</span></span> <span data-ttu-id="e4e57-206">`SafeHandle` ersetzt diese Klasse und sollte stattdessen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-206">`SafeHandle` effectively replaces this class and should be used instead.</span></span>

<span data-ttu-id="e4e57-207">[`GCHandle`](xref:System.Runtime.InteropServices.GCHandle) ermöglicht das Anheften eines verwalteten Objekts und Abrufen des nativen Zeigers auf das Objekt.</span><span class="sxs-lookup"><span data-stu-id="e4e57-207">[`GCHandle`](xref:System.Runtime.InteropServices.GCHandle) allows pinning a managed object and getting the native pointer to it.</span></span> <span data-ttu-id="e4e57-208">Das grundlegende Muster sieht folgendermaßen aus:</span><span class="sxs-lookup"><span data-stu-id="e4e57-208">The basic pattern is:</span></span>

```csharp
GCHandle handle = GCHandle.Alloc(obj, GCHandleType.Pinned);
IntPtr ptr = handle.AddrOfPinnedObject();
handle.Free();
```

<span data-ttu-id="e4e57-209">Anheften ist kein Standardvorgang für `GCHandle`.</span><span class="sxs-lookup"><span data-stu-id="e4e57-209">Pinning isn't the default for `GCHandle`.</span></span> <span data-ttu-id="e4e57-210">Das andere wichtige Muster sieht so aus: Ein Verweis wird über nativen Code an ein verwaltetes Objekt übergeben und, in der Regel über einen Rückruf, wieder zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="e4e57-210">The other major pattern is for passing a reference to a managed object through native code and back to managed code, usually with a callback.</span></span> <span data-ttu-id="e4e57-211">Hier sehen Sie das Muster:</span><span class="sxs-lookup"><span data-stu-id="e4e57-211">Here is the pattern:</span></span>

```csharp
GCHandle handle = GCHandle.Alloc(obj);
SomeNativeEnumerator(callbackDelegate, GCHandle.ToIntPtr(handle));

// In the callback
GCHandle handle = GCHandle.FromIntPtr(param);
object managedObject = handle.Target;

// After the last callback
handle.Free();
```

<span data-ttu-id="e4e57-212">Denken Sie daran, dass `GCHandle` explizit freigegeben werden muss, um Arbeitsspeicherverluste zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-212">Don't forget that `GCHandle` needs to be explicitly freed to avoid memory leaks.</span></span>

## <a name="common-windows-data-types"></a><span data-ttu-id="e4e57-213">Allgemeine Windows-Datentypen</span><span class="sxs-lookup"><span data-stu-id="e4e57-213">Common Windows data types</span></span>

<span data-ttu-id="e4e57-214">Die folgende Liste enthält Datentypen, die in Windows-APIs häufig verwendet werden, sowie C#-Typen, die beim Aufrufen des Windows-Codes verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-214">Here is a list of data types commonly used in Windows APIs and which C# types to use when calling into the Windows code.</span></span>

<span data-ttu-id="e4e57-215">Die folgenden Typen weisen trotz ihrer Namen die gleiche Größe wie 32- und 64-Bit-Typen für Windows auf.</span><span class="sxs-lookup"><span data-stu-id="e4e57-215">The following types are the same size on 32-bit and 64-bit Windows, despite their names.</span></span>

| <span data-ttu-id="e4e57-216">Breite</span><span class="sxs-lookup"><span data-stu-id="e4e57-216">Width</span></span> | <span data-ttu-id="e4e57-217">Windows</span><span class="sxs-lookup"><span data-stu-id="e4e57-217">Windows</span></span>          | <span data-ttu-id="e4e57-218">C (Windows)</span><span class="sxs-lookup"><span data-stu-id="e4e57-218">C (Windows)</span></span>          | <span data-ttu-id="e4e57-219">C#</span><span class="sxs-lookup"><span data-stu-id="e4e57-219">C#</span></span>       | <span data-ttu-id="e4e57-220">Alternative</span><span class="sxs-lookup"><span data-stu-id="e4e57-220">Alternative</span></span>                          |
|:------|:-----------------|:---------------------|:---------|:-------------------------------------|
| <span data-ttu-id="e4e57-221">32</span><span class="sxs-lookup"><span data-stu-id="e4e57-221">32</span></span>    | `BOOL`           | `int`                | `int`    | `bool`                               |
| <span data-ttu-id="e4e57-222">8</span><span class="sxs-lookup"><span data-stu-id="e4e57-222">8</span></span>     | `BOOLEAN`        | `unsigned char`      | `byte`   | `[MarshalAs(UnmanagedType.U1)] bool` |
| <span data-ttu-id="e4e57-223">8</span><span class="sxs-lookup"><span data-stu-id="e4e57-223">8</span></span>     | `BYTE`           | `unsigned char`      | `byte`   |                                      |
| <span data-ttu-id="e4e57-224">8</span><span class="sxs-lookup"><span data-stu-id="e4e57-224">8</span></span>     | `CHAR`           | `char`               | `sbyte`  |                                      |
| <span data-ttu-id="e4e57-225">8</span><span class="sxs-lookup"><span data-stu-id="e4e57-225">8</span></span>     | `UCHAR`          | `unsigned char`      | `byte`   |                                      |
| <span data-ttu-id="e4e57-226">16</span><span class="sxs-lookup"><span data-stu-id="e4e57-226">16</span></span>    | `SHORT`          | `short`              | `short`  |                                      |
| <span data-ttu-id="e4e57-227">16</span><span class="sxs-lookup"><span data-stu-id="e4e57-227">16</span></span>    | `CSHORT`         | `short`              | `short`  |                                      |
| <span data-ttu-id="e4e57-228">16</span><span class="sxs-lookup"><span data-stu-id="e4e57-228">16</span></span>    | `USHORT`         | `unsigned short`     | `ushort` |                                      |
| <span data-ttu-id="e4e57-229">16</span><span class="sxs-lookup"><span data-stu-id="e4e57-229">16</span></span>    | `WORD`           | `unsigned short`     | `ushort` |                                      |
| <span data-ttu-id="e4e57-230">16</span><span class="sxs-lookup"><span data-stu-id="e4e57-230">16</span></span>    | `ATOM`           | `unsigned short`     | `ushort` |                                      |
| <span data-ttu-id="e4e57-231">32</span><span class="sxs-lookup"><span data-stu-id="e4e57-231">32</span></span>    | `INT`            | `int`                | `int`    |                                      |
| <span data-ttu-id="e4e57-232">32</span><span class="sxs-lookup"><span data-stu-id="e4e57-232">32</span></span>    | `LONG`           | `long`               | `int`    |                                      |
| <span data-ttu-id="e4e57-233">32</span><span class="sxs-lookup"><span data-stu-id="e4e57-233">32</span></span>    | `ULONG`          | `unsigned long`      | `uint`   |                                      |
| <span data-ttu-id="e4e57-234">32</span><span class="sxs-lookup"><span data-stu-id="e4e57-234">32</span></span>    | `DWORD`          | `unsigned long`      | `uint`   |                                      |
| <span data-ttu-id="e4e57-235">64</span><span class="sxs-lookup"><span data-stu-id="e4e57-235">64</span></span>    | `QWORD`          | `long long`          | `long`   |                                      |
| <span data-ttu-id="e4e57-236">64</span><span class="sxs-lookup"><span data-stu-id="e4e57-236">64</span></span>    | `LARGE_INTEGER`  | `long long`          | `long`   |                                      |
| <span data-ttu-id="e4e57-237">64</span><span class="sxs-lookup"><span data-stu-id="e4e57-237">64</span></span>    | `LONGLONG`       | `long long`          | `long`   |                                      |
| <span data-ttu-id="e4e57-238">64</span><span class="sxs-lookup"><span data-stu-id="e4e57-238">64</span></span>    | `ULONGLONG`      | `unsigned long long` | `ulong`  |                                      |
| <span data-ttu-id="e4e57-239">64</span><span class="sxs-lookup"><span data-stu-id="e4e57-239">64</span></span>    | `ULARGE_INTEGER` | `unsigned long long` | `ulong`  |                                      |
| <span data-ttu-id="e4e57-240">32</span><span class="sxs-lookup"><span data-stu-id="e4e57-240">32</span></span>    | `HRESULT`        | `long`               | `int`    |                                      |
| <span data-ttu-id="e4e57-241">32</span><span class="sxs-lookup"><span data-stu-id="e4e57-241">32</span></span>    | `NTSTATUS`       | `long`               | `int`    |                                      |

<span data-ttu-id="e4e57-242">Die folgenden Typen sind Zeiger und entsprechen der Breite der Plattform.</span><span class="sxs-lookup"><span data-stu-id="e4e57-242">The following types, being pointers, do follow the width of the platform.</span></span> <span data-ttu-id="e4e57-243">Verwenden Sie `IntPtr`/`UIntPtr` für diese.</span><span class="sxs-lookup"><span data-stu-id="e4e57-243">Use `IntPtr`/`UIntPtr` for these.</span></span>

| <span data-ttu-id="e4e57-244">Signierte Zeigertypen (verwenden Sie `IntPtr`).</span><span class="sxs-lookup"><span data-stu-id="e4e57-244">Signed Pointer Types (use `IntPtr`)</span></span> | <span data-ttu-id="e4e57-245">Nicht signierte Zeigertypen (verwenden Sie `UIntPtr`).</span><span class="sxs-lookup"><span data-stu-id="e4e57-245">Unsigned Pointer Types (use `UIntPtr`)</span></span> |
|:------------------------------------|:---------------------------------------|
| `HANDLE`                            | `WPARAM`                               |
| `HWND`                              | `UINT_PTR`                             |
| `HINSTANCE`                         | `ULONG_PTR`                            |
| `LPARAM`                            | `SIZE_T`                               |
| `LRESULT`                           |                                        |
| `LONG_PTR`                          |                                        |
| `INT_PTR`                           |                                        |

<span data-ttu-id="e4e57-246">Für einen `PVOID`-Wert in Windows, der `void*` in C entspricht, kann ein Marshalling als `IntPtr` oder `UIntPtr` erfolgen. `void*` sollte jedoch nach Möglichkeit bevorzugt werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-246">A Windows `PVOID` which is a C `void*` can be marshaled as either `IntPtr` or `UIntPtr`, but prefer `void*` when possible.</span></span>

[<span data-ttu-id="e4e57-247">Windows-Datentypen</span><span class="sxs-lookup"><span data-stu-id="e4e57-247">Windows Data Types</span></span>](/windows/desktop/WinProg/windows-data-types)

[<span data-ttu-id="e4e57-248">Datentypbereiche</span><span class="sxs-lookup"><span data-stu-id="e4e57-248">Data Type Ranges</span></span>](/cpp/cpp/data-type-ranges)

## <a name="structs"></a><span data-ttu-id="e4e57-249">Strukturen</span><span class="sxs-lookup"><span data-stu-id="e4e57-249">Structs</span></span>

<span data-ttu-id="e4e57-250">Verwaltete Strukturen werden im Stapel erstellt und erst dann entfernt, wenn die Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="e4e57-250">Managed structs are created on the stack and aren't removed until the method returns.</span></span> <span data-ttu-id="e4e57-251">Per Definition werden sie „angeheftet“ (also von der Garbage Collection nicht verschoben).</span><span class="sxs-lookup"><span data-stu-id="e4e57-251">By definition then, they are "pinned" (it won't get moved by the GC).</span></span> <span data-ttu-id="e4e57-252">Sie können auch einfach die Adresse in unsicheren Codeblöcken verwenden, wenn der native Code den Zeiger nicht über das Ende der aktuellen Methode hinaus verwendet.</span><span class="sxs-lookup"><span data-stu-id="e4e57-252">You can also simply take the address in unsafe code blocks if native code won't use the pointer past the end of the current method.</span></span>

<span data-ttu-id="e4e57-253">Für Blitting geeignete Strukturen sind wesentlich leistungsfähiger, da sie ganz einfach direkt von der Marshallingebene genutzt werden können.</span><span class="sxs-lookup"><span data-stu-id="e4e57-253">Blittable structs are much more performant as they can simply be used directly by the marshaling layer.</span></span> <span data-ttu-id="e4e57-254">Versuchen Sie, Typen blitfähig zu machen (vermeiden Sie z.B. `bool`).</span><span class="sxs-lookup"><span data-stu-id="e4e57-254">Try to make structs blittable (for example, avoid `bool`).</span></span> <span data-ttu-id="e4e57-255">Weitere Informationen finden Sie im Abschnitt [Für Blitting geeignete Typen](#blittable-types).</span><span class="sxs-lookup"><span data-stu-id="e4e57-255">For more information, see the [Blittable Types](#blittable-types) section.</span></span>

<span data-ttu-id="e4e57-256">*Wenn* eine Struktur für Blitting geeignet ist, verwenden Sie `sizeof()` statt `Marshal.SizeOf<MyStruct>()`, um eine bessere Leistung zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-256">*If* the struct is blittable, use `sizeof()` instead of `Marshal.SizeOf<MyStruct>()` for better performance.</span></span> <span data-ttu-id="e4e57-257">Wie oben erwähnt, können Sie überprüfen, ob der Typ für Blitting geeignet ist, indem Sie versuchen, ein angeheftetes `GCHandle` zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-257">As mentioned above, you can validate that the type is blittable by attempting to create a pinned `GCHandle`.</span></span> <span data-ttu-id="e4e57-258">Wenn der Typ keine Zeichenfolge ist oder nicht als für Blitting geeignet betrachtet wird, löst `GCHandle.Alloc` eine `ArgumentException` aus.</span><span class="sxs-lookup"><span data-stu-id="e4e57-258">If the type is not a string or considered blittable, `GCHandle.Alloc` will throw an `ArgumentException`.</span></span>

<span data-ttu-id="e4e57-259">Zeiger auf Strukturen in Definitionen müssen entweder von `ref` übergeben werden oder `unsafe` und `*` verwenden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-259">Pointers to structs in definitions must either be passed by `ref` or use `unsafe` and `*`.</span></span>

<span data-ttu-id="e4e57-260">✔️ PASSEN Sie die verwaltete Struktur so eng wie möglich an die Form und die Namen an, die in der offiziellen Dokumentation zur Plattform oder im Header verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-260">✔️ DO match the managed struct as closely as possible to the shape and names that are used in the official platform documentation or header.</span></span>

<span data-ttu-id="e4e57-261">✔️ VERWENDEN Sie `sizeof()` aus C# anstelle von `Marshal.SizeOf<MyStruct>()` für Strukturen, die für Blitting geeignet sind, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="e4e57-261">✔️ DO use the C# `sizeof()` instead of `Marshal.SizeOf<MyStruct>()` for blittable structures to improve performance.</span></span>

<span data-ttu-id="e4e57-262">❌ VERMEIDEN Sie die Verwendung von `System.Delegate`- oder `System.MulticastDelegate`-Feldern, um Felder für Funktionszeiger in Strukturen darzustellen.</span><span class="sxs-lookup"><span data-stu-id="e4e57-262">❌ AVOID using `System.Delegate` or `System.MulticastDelegate` fields to represent function pointer fields in structures.</span></span>

<span data-ttu-id="e4e57-263">Da <xref:System.Delegate?displayProperty=fullName> und <xref:System.MulticastDelegate?displayProperty=fullName> nicht über eine erforderliche Signatur verfügen, garantieren sie nicht, dass der übergebene Delegat der Signatur entspricht, die vom nativen Code erwartet wird.</span><span class="sxs-lookup"><span data-stu-id="e4e57-263">Since <xref:System.Delegate?displayProperty=fullName> and <xref:System.MulticastDelegate?displayProperty=fullName> don't have a required signature, they don't guarantee that the delegate passed in will match the signature the native code expects.</span></span> <span data-ttu-id="e4e57-264">Außerdem kann in .NET Framework und .NET Core das Marshalling einer Struktur, die einen `System.Delegate` oder einen `System.MulticastDelegate` aus ihrer nativen Darstellung in ein verwaltetes Objekt enthält, die Runtime destabilisieren, wenn der Wert des Felds in der nativen Darstellung kein Funktionszeiger ist, der einen verwalteten Delegaten umschließt.</span><span class="sxs-lookup"><span data-stu-id="e4e57-264">Additionally, in .NET Framework and .NET Core, marshaling a struct containing a `System.Delegate` or `System.MulticastDelegate` from its native representation to a managed object can destabilize the runtime if the value of the field in the native representation isn't a function pointer that wraps a managed delegate.</span></span> <span data-ttu-id="e4e57-265">In .NET 5 und höheren Versionen wird das Marshalling eines `System.Delegate`- oder `System.MulticastDelegate`-Felds aus einer nativen Darstellung in ein verwaltetes Objekt nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="e4e57-265">In .NET 5 and later versions, marshaling a `System.Delegate` or `System.MulticastDelegate` field from a native representation to a managed object is not supported.</span></span> <span data-ttu-id="e4e57-266">Verwenden Sie anstelle von `System.Delegate` oder `System.MulticastDelegate` einen bestimmten Delegattyp.</span><span class="sxs-lookup"><span data-stu-id="e4e57-266">Use a specific delegate type instead of `System.Delegate` or `System.MulticastDelegate`.</span></span>

### <a name="fixed-buffers"></a><span data-ttu-id="e4e57-267">Puffer fester Größe</span><span class="sxs-lookup"><span data-stu-id="e4e57-267">Fixed Buffers</span></span>

<span data-ttu-id="e4e57-268">Für ein Array wie `INT_PTR Reserved1[2]` muss ein Marshalling in zwei `IntPtr`-Felder durchgeführt werden: `Reserved1a` und `Reserved1b`.</span><span class="sxs-lookup"><span data-stu-id="e4e57-268">An array like `INT_PTR Reserved1[2]` has to be marshaled to two `IntPtr` fields, `Reserved1a` and `Reserved1b`.</span></span> <span data-ttu-id="e4e57-269">Wenn das native Array ein primitiver Typ ist, können wir das Schlüsselwort `fixed` verwenden, um es etwas übersichtlicher zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="e4e57-269">When the native array is a primitive type, we can use the `fixed` keyword to write it a little more cleanly.</span></span> <span data-ttu-id="e4e57-270">`SYSTEM_PROCESS_INFORMATION` sieht im nativen Header beispielsweise so aus:</span><span class="sxs-lookup"><span data-stu-id="e4e57-270">For example, `SYSTEM_PROCESS_INFORMATION` looks like this in the native header:</span></span>

```c
typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    BYTE Reserved1[48];
    UNICODE_STRING ImageName;
...
} SYSTEM_PROCESS_INFORMATION
```

<span data-ttu-id="e4e57-271">In C# können wir es folgendermaßen schreiben:</span><span class="sxs-lookup"><span data-stu-id="e4e57-271">In C#, we can write it like this:</span></span>

```csharp
internal unsafe struct SYSTEM_PROCESS_INFORMATION
{
    internal uint NextEntryOffset;
    internal uint NumberOfThreads;
    private fixed byte Reserved1[48];
    internal Interop.UNICODE_STRING ImageName;
    ...
}
```

<span data-ttu-id="e4e57-272">Es gibt jedoch einige Besonderheiten bei festen Puffern.</span><span class="sxs-lookup"><span data-stu-id="e4e57-272">However, there are some gotchas with fixed buffers.</span></span> <span data-ttu-id="e4e57-273">Bei festen Puffern aus nicht für Blitting geeigneten Typen wird das Marshalling nicht ordnungsgemäß ausgeführt, daher muss das vorhandene Array auf mehrere einzelne Felder erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="e4e57-273">Fixed buffers of non-blittable types won't be correctly marshaled, so the in-place array needs to be expanded out to multiple individual fields.</span></span> <span data-ttu-id="e4e57-274">Darüber hinaus gilt für .NET Framework und .NET Core vor Version 3.0: Wenn eine Struktur, die ein festes Pufferfeld enthält, in einer nicht für Blitting geeigneten Struktur geschachtelt wird, erfolgt kein ordnungsgemäßes Marshalling des festen Pufferfelds zum nativen Code.</span><span class="sxs-lookup"><span data-stu-id="e4e57-274">Additionally, in .NET Framework and .NET Core before 3.0, if a struct containing a fixed buffer field is nested within a non-blittable struct, the fixed buffer field won't be correctly marshaled to native code.</span></span>
