---
title: Plattformaufruf (P/Invoke)
description: Erfahren Sie, wie Sie native Funktionen über P/Invoke in .Net aufrufen.
ms.date: 01/18/2019
ms.openlocfilehash: fa8b43edfba50fbc620f257c4e7caf1673f83235
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/07/2020
ms.locfileid: "75706304"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="b1ba0-103">Plattformaufruf (P/Invoke)</span><span class="sxs-lookup"><span data-stu-id="b1ba0-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="b1ba0-104">P/Invoke ist eine Technologie, die Ihnen den Zugriff auf Strukturen, Rückrufe und Funktionen in nicht verwalteten Bibliotheken von verwaltetem Code aus ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="b1ba0-105">Der Großteil der P/Invoke-API ist in zwei Namespaces enthalten: `System` und `System.Runtime.InteropServices`.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="b1ba0-106">Über diese beiden Namespaces können Sie auf die Tools zugreifen, die beschreiben, wie Sie mit der nativen Komponente kommunizieren möchten.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="b1ba0-107">Beginnen wir mit dem gängigsten Beispiel, dem Aufruf nicht verwalteter Funktionen im Ihrem verwalteten Code.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="b1ba0-108">Wir zeigen ein Meldungsfeld aus einer Befehlszeilenanwendung:</span><span class="sxs-lookup"><span data-stu-id="b1ba0-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="b1ba0-109">Das obige Beispiel ist recht einfach, zeigt jedoch, was zum Aufrufen nicht verwalteter Funktionen von verwaltetem Code aus erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="b1ba0-110">Gehen wir das Beispiel schrittweise durch:</span><span class="sxs-lookup"><span data-stu-id="b1ba0-110">Let’s step through the example:</span></span>

- <span data-ttu-id="b1ba0-111">Zeile 1 zeigt die using-Anweisung für `System.Runtime.InteropServices`. Dies ist der Namespace, der alle benötigten Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-111">Line #1 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="b1ba0-112">In Zeile 7 wird das `DllImport`-Attribut eingeführt.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-112">Line #7 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="b1ba0-113">Dieses Attribut ist äußerst wichtig, da es der Runtime mitteilt, dass die nicht verwaltete DLL geladen werden soll.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="b1ba0-114">Die übergebene Zeichenfolge ist die DLL, in der sich unsere Zielfunktion befindet.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="b1ba0-115">Zusätzlich gibt sie an, welcher [Zeichensatz](./charset.md) für das Marshallen der Zeichenfolgen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="b1ba0-116">Schließlich gibt sie an, dass diese Funktion [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) aufruft und dass die Laufzeit diesen Fehlercode abfangen muss, damit der Benutzer ihn über <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType> abrufen kann.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="b1ba0-117">Zeile 8 ist der Kern der P/Invoke-Funktion.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-117">Line #8 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="b1ba0-118">Sie definiert eine verwaltete Methode, die **genau dieselbe Signatur** aufweist wie die nicht verwaltete Methode.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="b1ba0-119">Wie Sie sehen, enthält die Deklaration ein neues Schlüsselwort, `extern`. Dieses teilt der Runtime mit, dass es sich um eine externe Methode handelt und dass die Runtime die Methode bei Aufruf in der im `DllImport`-Attribut angegebenen DLL findet.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="b1ba0-120">Der Rest des Beispiels besteht nur aus dem Aufruf der Methode, der wie bei jeder anderen verwalteten Methode erfolgt.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="b1ba0-121">Das Beispiel ist für macOS ähnlich.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-121">The sample is similar for macOS.</span></span> <span data-ttu-id="b1ba0-122">Der Name der Bibliothek im `DllImport`-Attribut muss geändert werden, da macOS ein anderes Schema für die Benennung dynamischer Bibliotheken verwendet.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="b1ba0-123">Das folgende Beispiel verwendet die `getpid(2)`-Funktion, um die Prozess-ID der Anwendung abzurufen und in der Konsole auszugeben.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="b1ba0-124">Bei Linux ist es ähnlich.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-124">It is also similar on Linux.</span></span> <span data-ttu-id="b1ba0-125">Der Funktionsname ist identisch, da es sich bei `getpid(2)` um einen standardmäßigen [POSIX](https://en.wikipedia.org/wiki/POSIX)-Systemaufruf handelt.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="b1ba0-126">Aufrufen von verwaltetem Code von nicht verwaltetem Code aus</span><span class="sxs-lookup"><span data-stu-id="b1ba0-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="b1ba0-127">Die Runtime ermöglicht den Kommunikationsfluss in beide Richtungen, sodass Sie verwalteten Code mithilfe von Funktionszeigern aus nativen Funktionen zurückrufen können.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="b1ba0-128">Einem Funktionszeiger in verwaltetem Code kommt ein **Delegat** am nächsten. Dieser wird verwendet, um Rückrufe von nativem Code an verwalteten Code zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="b1ba0-129">Dieses Feature wird ähnlich dem oben beschriebenen Verfahren von verwaltetem zu nativem Code verwendet.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="b1ba0-130">Für einen bestimmten Rückruf definieren Sie einen Delegaten, der der Signatur entspricht, und übergeben Sie ihn an die externe Methode.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="b1ba0-131">Die Runtime übernimmt alles Weitere.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="b1ba0-132">Bevor wir unser Beispiel durchgehen, sollten wir die Signaturen der nicht verwalteten Funktionen betrachten, mit denen wir arbeiten müssen.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="b1ba0-133">Die Funktion, die wir zum Auflisten aller Fenster aufrufen möchten, weist folgende Signatur auf: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="b1ba0-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="b1ba0-134">Der erste Parameter ist ein Rückruf.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-134">The first parameter is a callback.</span></span> <span data-ttu-id="b1ba0-135">Dieser Rückruf besitzt die folgende Signatur: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="b1ba0-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="b1ba0-136">Schauen wir uns jetzt das Beispiel an:</span><span class="sxs-lookup"><span data-stu-id="b1ba0-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="b1ba0-137">Zeile 9 im Beispiel definiert einen Delegaten, der der Signatur des Rückrufs von nicht verwaltetem Code aus entspricht.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="b1ba0-138">Beachten Sie, wie die Typen LPARAM und HWND über `IntPtr` im verwalteten Code dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="b1ba0-139">In den Zeilen 13 und 14 wird die `EnumWindows`-Funktion über die user32.dll-Bibliothek eingeführt.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="b1ba0-140">In den Zeilen 17 bis 20 wird der Delegat implementiert.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="b1ba0-141">In diesem einfachen Beispiel möchten wir nur das Handle an die Konsole ausgeben.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="b1ba0-142">Abschließend wird in Zeile 24 die externe Methode aufgerufen und an den Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="b1ba0-143">Die Beispiele für Linux und macOS werden im Folgenden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="b1ba0-144">Hierfür verwenden wir die `ftw`-Funktion, die in `libc` zu finden ist, der C-Bibliothek.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="b1ba0-145">Anhand dieser Funktion werden die Verzeichnishierarchien durchlaufen. Sie verwendet einen Zeiger auf eine Funktion als einen ihrer Parameter.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="b1ba0-146">Diese Funktion besitzt die folgende Signatur: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="b1ba0-147">Im macOS-Beispiel wird die gleiche Funktion verwendet. Der einzige Unterschied ist das Argument für das `DllImport`-Attribut, da macOS `libc` an einer anderen Stelle speichert.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="b1ba0-148">Beide oben aufgeführten Beispiele hängen von Parametern ab, und in beiden Fällen werden die Parameter als verwaltete Typen angegeben.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="b1ba0-149">Die Runtime reagiert demgemäß und verarbeitet diese in ihren Entsprechungen auf der anderen Seite.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="b1ba0-150">Weitere Informationen dazu, wie Typen in nativen Code auf unserer Seite gemarshallt werden, finden Sie unter [Marshalling von Typen](type-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="b1ba0-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="b1ba0-151">Weitere Ressourcen</span><span class="sxs-lookup"><span data-stu-id="b1ba0-151">More resources</span></span>

- <span data-ttu-id="b1ba0-152">[PInvoke.NET-Wiki](https://www.pinvoke.net/) ist eine ausgezeichnete Wiki-Seite mit Informationen zu gängigen Windows-APIs und deren Aufruf.</span><span class="sxs-lookup"><span data-stu-id="b1ba0-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="b1ba0-153">Native und .NET-Interoperabilität</span><span class="sxs-lookup"><span data-stu-id="b1ba0-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="b1ba0-154">Mono-Dokumentation zu P/Invoke</span><span class="sxs-lookup"><span data-stu-id="b1ba0-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
