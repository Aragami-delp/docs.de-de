---
title: Aufgabenbasiertes asynchrones Programmieren – .NET
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallelism, task
ms.assetid: 458b5e69-5210-45e5-bc44-3888f86abd6f
ms.openlocfilehash: 66904a24817eee0161d877ace7f4584d58fe30f0
ms.sourcegitcommit: 1cb64b53eb1f253e6a3f53ca9510ef0be1fd06fe
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/29/2020
ms.locfileid: "82507571"
---
# <a name="task-based-asynchronous-programming"></a><span data-ttu-id="e3eb1-102">Aufgabenbasiertes asynchrones Programmieren</span><span class="sxs-lookup"><span data-stu-id="e3eb1-102">Task-based asynchronous programming</span></span>

<span data-ttu-id="e3eb1-103">Die Task Parallel Library (TPL) basiert auf dem Konzept einer *Aufgabe*, die einen asynchronen Vorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-103">The Task Parallel Library (TPL) is based on the concept of a *task*, which represents an asynchronous operation.</span></span> <span data-ttu-id="e3eb1-104">In einigen Dingen ist eine Aufgabe vergleichbar mit einer <xref:System.Threading.ThreadPool>, weist jedoch eine höhere Abstraktionsebene auf.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-104">In some ways, a task resembles a thread or <xref:System.Threading.ThreadPool> work item, but at a higher level of abstraction.</span></span> <span data-ttu-id="e3eb1-105">Der Begriff *Aufgabenparallelität* bezeichnet eine oder mehrere eigenständige Aufgaben, die gleichzeitig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-105">The term *task parallelism* refers to one or more independent tasks running concurrently.</span></span> <span data-ttu-id="e3eb1-106">Aufgaben bieten zwei Hauptvorteile:</span><span class="sxs-lookup"><span data-stu-id="e3eb1-106">Tasks provide two primary benefits:</span></span>

- <span data-ttu-id="e3eb1-107">Effiziente und skalierbare Verwendung von Systemressourcen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-107">More efficient and more scalable use of system resources.</span></span>

     <span data-ttu-id="e3eb1-108">Aufgaben werden im Hintergrund in <xref:System.Threading.ThreadPool> eingereicht, der mit Algorithmen verbessert wurde, durch die die Anzahl von Threads bestimmt und angepasst wird und die einen Lastenausgleich verfügbar machen, der den Durchsatz maximiert.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-108">Behind the scenes, tasks are queued to the <xref:System.Threading.ThreadPool>, which has been enhanced with algorithms  that determine and adjust to the number of threads and that provide load balancing to maximize throughput.</span></span> <span data-ttu-id="e3eb1-109">Aufgaben sind hierdurch relativ einfach strukturiert, und Sie können für eine differenzierte Parallelität viele Aufgaben erstellen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-109">This makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.</span></span>

- <span data-ttu-id="e3eb1-110">Stärker programmgesteuerte Kontrolle als bei Threads oder Arbeitselementen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-110">More programmatic control than is possible with a thread or work item.</span></span>

     <span data-ttu-id="e3eb1-111">Aufgaben und das diese umgebende Framework stellen einen umfangreichen Satz von APIs bereit, die Warten, Abbruch, Fortsetzungen, robuste Ausnahmebehandlung, detaillierte Zustandsangaben, benutzerdefinierte Planung und Vieles mehr unterstützen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-111">Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.</span></span>

<span data-ttu-id="e3eb1-112">Aus diesen Gründen ist TPL in .NET Framework die bevorzugte API zum Schreiben von asynchronem, parallelem und Multithreadcode.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-112">For both of these reasons, in the .NET Framework, TPL is the preferred API for writing multi-threaded, asynchronous, and parallel code.</span></span>

## <a name="creating-and-running-tasks-implicitly"></a><span data-ttu-id="e3eb1-113">Implizites Erstellen und Ausführen von Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-113">Creating and running tasks implicitly</span></span>

<span data-ttu-id="e3eb1-114">Die <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType>-Methode bietet eine einfache Möglichkeit, eine beliebige Anzahl willkürlicher Anweisungen gleichzeitig auszuführen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-114">The <xref:System.Threading.Tasks.Parallel.Invoke%2A?displayProperty=nameWithType> method provides a convenient way to run any number of arbitrary statements concurrently.</span></span> <span data-ttu-id="e3eb1-115">Sie müssen nur einen <xref:System.Action>-Delegaten für jede Arbeitsaufgabe übergeben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-115">Just pass in an <xref:System.Action> delegate for each item of work.</span></span> <span data-ttu-id="e3eb1-116">Die einfachste Möglichkeit, diese Delegaten zu erstellen, sind Lambdaausdrücke.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-116">The easiest way to create these delegates is to use lambda expressions.</span></span> <span data-ttu-id="e3eb1-117">Der Lambdaausdruck kann entweder eine benannte Methode aufrufen oder den Code inline bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-117">The lambda expression can either call a named method or provide the code inline.</span></span> <span data-ttu-id="e3eb1-118">Im folgenden Beispiel wird ein grundlegender <xref:System.Threading.Tasks.Parallel.Invoke%2A>-Aufruf dargestellt, der zwei Aufgaben erstellt und startet, die gleichzeitig ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-118">The following example shows a basic <xref:System.Threading.Tasks.Parallel.Invoke%2A> call that creates and starts two tasks that run concurrently.</span></span> <span data-ttu-id="e3eb1-119">Die erste Aufgabe wird durch einen Lambda-Ausdruck dargestellt, der die `DoSomeWork`-Methode aufruft, und die zweite Aufgabe wird durch einen Lambda-Ausdruck dargestellt, der die `DoSomeOtherWork`-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-119">The first task is represented by a lambda expression that calls a method named `DoSomeWork`, and the second task is represented by a lambda expression that calls a method named `DoSomeOtherWork`.</span></span>

> [!NOTE]
> <span data-ttu-id="e3eb1-120">Diese Dokumentation definiert Delegaten in TPL mithilfe von Lambdaausdrücken.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-120">This documentation uses lambda expressions to define delegates in TPL.</span></span> <span data-ttu-id="e3eb1-121">Falls Sie mit der Verwendung von Lambda-Ausdrücken in C# oder Visual Basic nicht vertraut sind, finden Sie entsprechende Informationen unter [Lambda Expressions in PLINQ and TPL (Lambda-Ausdrücke in PLINQ und TPL)](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-121">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span></span>

[!code-csharp[TPL#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl/cs/tpl.cs#21)]
[!code-vb[TPL#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl/vb/tpl_vb.vb#21)]

> [!NOTE]
> <span data-ttu-id="e3eb1-122">Die Anzahl von <xref:System.Threading.Tasks.Task>-Instanzen, die im Hintergrund von <xref:System.Threading.Tasks.Parallel.Invoke%2A> erstellt werden, ist nicht notwendigerweise mit der Anzahl der bereitgestellten Delegaten identisch.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-122">The number of <xref:System.Threading.Tasks.Task> instances that are created behind the scenes by <xref:System.Threading.Tasks.Parallel.Invoke%2A> is not necessarily equal to the number of delegates that are provided.</span></span> <span data-ttu-id="e3eb1-123">Die TPL kann verschiedene Optimierungen einsetzen, besonders bei einer großen Anzahl von Delegaten.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-123">The TPL may employ various optimizations, especially with large numbers of delegates.</span></span>

<span data-ttu-id="e3eb1-124">Weitere Informationen finden Sie unter [Vorgehensweise: Ausführen von parallelen Vorgängen mithilfe von „Parallel.Invoke“](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-124">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>

<span data-ttu-id="e3eb1-125">Wenn Sie die Aufgabenausführung präziser steuern oder einen Wert aus der Aufgabe zurückgeben möchten, müssen Sie expliziter mit <xref:System.Threading.Tasks.Task>-Objekten arbeiten.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-125">For greater control over task execution or to return a value from the task, you have to work with <xref:System.Threading.Tasks.Task> objects more explicitly.</span></span>

## <a name="creating-and-running-tasks-explicitly"></a><span data-ttu-id="e3eb1-126">Explizites Erstellen und Ausführen von Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-126">Creating and running tasks explicitly</span></span>

<span data-ttu-id="e3eb1-127">Eine Aufgabe, die keinen Wert zurückgibt, wird durch die <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Klasse dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-127">A task that does not return a value is represented by the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="e3eb1-128">Eine Aufgabe, die einen Wert zurückgibt, wird durch die <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>-Klasse dargestellt, die von <xref:System.Threading.Tasks.Task> erbt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-128">A task that returns a value is represented by the <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> class, which inherits from <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="e3eb1-129">Das Aufgabenobjekt verarbeitet die Infrastrukturdetails und stellt Methoden sowie Eigenschaften bereit, auf die während der gesamten Lebensdauer der Aufgabe vom aufrufenden Thread aus zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-129">The task object handles the infrastructure details and provides methods and properties that are accessible from the calling thread throughout the lifetime of the task.</span></span> <span data-ttu-id="e3eb1-130">Sie können beispielsweise jederzeit auf die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft einer Aufgabe zugreifen, um zu ermitteln, ob die Ausführung gestartet, abgeschlossen oder abgebrochen wurde bzw. ob eine Ausnahme ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-130">For example, you can access the <xref:System.Threading.Tasks.Task.Status%2A> property of a task at any time to determine whether it has started running, ran to completion, was canceled, or has thrown an exception.</span></span> <span data-ttu-id="e3eb1-131">Der Status wird durch eine <xref:System.Threading.Tasks.TaskStatus>-Enumeration dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-131">The status is represented by a <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span>

<span data-ttu-id="e3eb1-132">Wenn Sie eine Aufgabe erstellen, weisen Sie dieser einen Benutzerdelegaten zu, der den von der Aufgabe ausgeführten Code kapselt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-132">When you create a task, you give it a user delegate that encapsulates the code that the task will execute.</span></span> <span data-ttu-id="e3eb1-133">Der Delegat kann als benannter Delegat, als anonyme Methode oder als Lambda-Ausdruck angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-133">The delegate can be expressed as a named delegate, an anonymous method, or a lambda expression.</span></span> <span data-ttu-id="e3eb1-134">Lambdaausdrücke können einen Aufruf einer benannten Methode enthalten, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-134">Lambda expressions can contain a call to a named method, as shown in the following example.</span></span> <span data-ttu-id="e3eb1-135">Beachten Sie, dass im Beispiel ein Aufruf der <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>-Methode enthalten ist, um sicherzustellen, dass die Aufgabe abgeschlossen ist, ehe die Konsolenmodusanwendung beendet wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-135">Note that the example includes a call to the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to ensure that the task completes execution before the console mode application ends.</span></span>

[!code-csharp[TPL_TaskIntro#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/lambda1.cs#1)]
[!code-vb[TPL_TaskIntro#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/lambda1.vb#1)]

<span data-ttu-id="e3eb1-136">Sie können auch die <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>-Methoden verwenden, um eine Aufgabe in einem Vorgang zu erstellen und zu starten.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-136">You can also use the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> methods to create and start a task in one operation.</span></span> <span data-ttu-id="e3eb1-137">Zum Verwalten der Aufgabe verwenden die <xref:System.Threading.Tasks.Task.Run%2A>-Methoden den Standardaufgabenplaner, unabhängig von dem Aufgabenplaner, der dem aktuellen Thread zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-137">To manage the task, the <xref:System.Threading.Tasks.Task.Run%2A> methods use the default  task scheduler, regardless of which task scheduler is associated with the current thread.</span></span> <span data-ttu-id="e3eb1-138">Wenn eine präzisere Steuerung der Erstellung und Planung von Aufgaben nicht erforderlich ist, sollten diese vorzugsweise mit den <xref:System.Threading.Tasks.Task.Run%2A>-Methoden erstellt und gestartet werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-138">The <xref:System.Threading.Tasks.Task.Run%2A> methods are the preferred way to create and start tasks when more control over the creation and scheduling of the task is not needed.</span></span>

[!code-csharp[TPL_TaskIntro#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/run1.cs#2)]
[!code-vb[TPL_TaskIntro#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/run1.vb#2)]

<span data-ttu-id="e3eb1-139">Sie können auch die <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>-Methode verwenden, um eine Aufgabe in einem Schritt zu erstellen und zu starten.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-139">You can also use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to create and start a task in one operation.</span></span> <span data-ttu-id="e3eb1-140">Verwenden Sie diese Methode, wenn Erstellung und Planung nicht getrennt werden müssen, zusätzliche Aufgabenerstellungsoptionen oder die Nutzung eines bestimmten Planers erforderlich sind oder der Aufgabe zusätzliche Zustände übergeben werden müssen, die über deren <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType>-Eigenschaft abgerufen werden können, wie im folgenden Beispiel dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-140">Use this method when creation and scheduling do not have to be separated and you require additional task creation options or the use of a specific scheduler, or when you need to pass additional state into the task that you can retrieve through its <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property, as shown in the following example.</span></span>

[!code-csharp[TPL_TaskIntro#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

<span data-ttu-id="e3eb1-141"><xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601> machen jeweils eine statische <xref:System.Threading.Tasks.Task.Factory%2A>-Eigenschaft verfügbar, von der eine Standardinstanz von <xref:System.Threading.Tasks.TaskFactory> zurückgegeben wird, sodass Sie die Methode als `Task.Factory.StartNew()` aufrufen können.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-141"><xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> each expose a static <xref:System.Threading.Tasks.Task.Factory%2A> property that returns a default instance of <xref:System.Threading.Tasks.TaskFactory>, so that you can call the method as `Task.Factory.StartNew()`.</span></span> <span data-ttu-id="e3eb1-142">Darüber hinaus verfügen die Aufgaben im Beispiel, da sie vom <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>-Typ sind, jeweils über eine öffentliche <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>-Eigenschaft, die das Ergebnis der Berechnung enthält.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-142">Also, in the following example, because the tasks are of type <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, they each have a public <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property that contains the result of the computation.</span></span> <span data-ttu-id="e3eb1-143">Die Aufgaben werden asynchron ausgeführt und können in einer beliebigen Reihenfolge abgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-143">The tasks run asynchronously and may complete in any order.</span></span> <span data-ttu-id="e3eb1-144">Wenn auf die <xref:System.Threading.Tasks.Task%601.Result%2A>-Eigenschaft zugegriffen wird, ehe die Berechnung beendet wurde, sperrt die Eigenschaft den aufrufenden Thread, bis der Wert verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-144">If the <xref:System.Threading.Tasks.Task%601.Result%2A> property is accessed before the computation finishes, the property blocks the calling thread until the value is available.</span></span>

[!code-csharp[TPL_TaskIntro#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/result1.cs#4)]
[!code-vb[TPL_TaskIntro#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/result1.vb#4)]

<span data-ttu-id="e3eb1-145">Weitere Informationen finden Sie unter [Vorgehensweise: Zurückgeben eines Werts aus einer Aufgabe](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-145">For more information, see [How to: Return a Value from a Task](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md).</span></span>

<span data-ttu-id="e3eb1-146">Wenn Sie einen Lambdaausdruck verwenden, um einen Delegaten zu erstellen, haben Sie Zugriff auf alle Variablen, die an dieser Stelle im Quellcode sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-146">When you use a lambda expression to create a delegate, you have access to all the variables that are visible at that point in your source code.</span></span> <span data-ttu-id="e3eb1-147">In einigen Fällen jedoch, insbesondere in Schleifen, wird die Variable nicht wie erwartet vom Lambda-Ausdruck erfasst.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-147">However, in some cases, most notably within loops, a lambda doesn't capture the variable as expected.</span></span> <span data-ttu-id="e3eb1-148">Es wird nur der endgültige Wert erfasst, und nicht der nach jeder Iteration geänderte Wert.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-148">It only captures the final value, not the value as it mutates after each iteration.</span></span> <span data-ttu-id="e3eb1-149">Das Problem wird anhand des folgenden Beispiels veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-149">The following example illustrates the problem.</span></span> <span data-ttu-id="e3eb1-150">Es wird ein Schleifenzähler an den Lambda-Ausdruck übergeben, wodurch ein `CustomData`-Objekt instanziiert wird und der Schleifenzähler als Objektbezeichner verwendet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-150">It passes a loop counter to a lambda expression that instantiates a `CustomData` object and uses the loop counter as the object's identifier.</span></span> <span data-ttu-id="e3eb1-151">Die Ausgabe im Beispiel zeigt, dass jedes `CustomData`-Objekt einen identischen Bezeichner hat.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-151">As the output from the example shows, each `CustomData` object has an identical identifier.</span></span>

[!code-csharp[TPL_TaskIntro#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1b.cs#22)]
[!code-vb[TPL_TaskIntro#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1b.vb#22)]

<span data-ttu-id="e3eb1-152">Sie können auf den Wert jeder Iteration zugreifen, indem Sie für die Aufgabe über ihren Konstruktor ein Zustandsobjekt bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-152">You can access the value on each iteration by providing a state object to a task through its constructor.</span></span> <span data-ttu-id="e3eb1-153">Im folgenden Beispiel wird das vorhergehende Beispiel geändert, indem der Schleifenzähler beim Erstellen des `CustomData`-Objekts verwendet wird, das wiederum an den Lambda-Ausdruck übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-153">The following example modifies the previous example by using the loop counter when creating the `CustomData` object, which, in turn, is passed to the lambda expression.</span></span>  <span data-ttu-id="e3eb1-154">Wie die Ausgabe im Beispiel zeigt, weist jedes `CustomData`-Objekt jetzt einen eindeutigen Bezeichner basierend auf den Wert des Schleifenzählers zum Zeitpunkt der Instanziierung des Objekts auf.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-154">As the output from the example shows, each `CustomData` object now has a unique identifier based on the value of the loop counter at the time the object was instantiated.</span></span>

[!code-csharp[TPL_TaskIntro#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/iteration1a.cs#21)]
[!code-vb[TPL_TaskIntro#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/iteration1a.vb#21)]

<span data-ttu-id="e3eb1-155">Dieser Zustand wird als Argument an den Aufgabendelegaten übergeben, und mit der <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType>-Eigenschaft kann über das Aufgabenobjekt auf den Zustand zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-155">This state is passed as an argument to the task delegate, and it can be accessed from the task object by using the <xref:System.Threading.Tasks.Task.AsyncState%2A?displayProperty=nameWithType> property.</span></span>  <span data-ttu-id="e3eb1-156">Das folgende Beispiel zeigt eine Abwandlung des vorherigen Beispiels.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-156">The following example is a variation on the previous example.</span></span> <span data-ttu-id="e3eb1-157">Es verwendet die <xref:System.Threading.Tasks.Task.AsyncState%2A>-Eigenschaft, um Informationen zu den `CustomData`-Objekten anzuzeigen, die an den Lambdaausdruck übergeben wurden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-157">It uses the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to display information about the `CustomData` objects passed to the lambda expression.</span></span>

[!code-csharp[TPL_TaskIntro#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/asyncstate.cs#23)]
[!code-vb[TPL_TaskIntro#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/asyncstate.vb#23)]

## <a name="task-id"></a><span data-ttu-id="e3eb1-158">Aufgaben-ID</span><span class="sxs-lookup"><span data-stu-id="e3eb1-158">Task ID</span></span>

<span data-ttu-id="e3eb1-159">Jeder Aufgabe wird eine ganzzahlige ID zugeordnet, durch die diese in einer Anwendungsdomäne eindeutig identifiziert wird und auf die mit der <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType>-Eigenschaft zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-159">Every task receives an integer ID that uniquely identifies it in an application domain and can be accessed by using the <xref:System.Threading.Tasks.Task.Id%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e3eb1-160">Die ID vereinfacht das Anzeigen von Aufgabeninformationen in den Fenstern **Parallele Stapel** und **Parallele Aufgaben** des Visual Studio-Debuggers.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-160">The ID is useful for viewing task information in the Visual Studio debugger **Parallel Stacks** and **Tasks** windows.</span></span> <span data-ttu-id="e3eb1-161">Die ID wird verzögert erzeugt, d. h., sie wird erst nach einer entsprechenden Anforderung erstellt. Eine Aufgabe kann daher bei jeder Programmausführung eine andere ID aufweisen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-161">The ID is lazily created, which means that it isn't created until it is requested; therefore, a task may have a different ID every time the program is run.</span></span> <span data-ttu-id="e3eb1-162">Weitere Informationen zum Anzeigen von Aufgaben-IDs im Debugger finden Sie unter [Verwenden des Fensters „Aufgaben“](/visualstudio/debugger/using-the-tasks-window) und [Verwenden des Fensters „Parallele Stapel“](/visualstudio/debugger/using-the-parallel-stacks-window).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-162">For more information about how to view task IDs in the debugger, see [Using the Tasks Window](/visualstudio/debugger/using-the-tasks-window) and [Using the Parallel Stacks Window](/visualstudio/debugger/using-the-parallel-stacks-window).</span></span>

## <a name="task-creation-options"></a><span data-ttu-id="e3eb1-163">Aufgabenerstellungsoptionen</span><span class="sxs-lookup"><span data-stu-id="e3eb1-163">Task creation options</span></span>

<span data-ttu-id="e3eb1-164">Die meisten APIs, die Aufgaben erstellen, stellen Überladungen bereit, die einen <xref:System.Threading.Tasks.TaskCreationOptions>-Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-164">Most APIs that create tasks provide overloads that accept a <xref:System.Threading.Tasks.TaskCreationOptions> parameter.</span></span> <span data-ttu-id="e3eb1-165">Durch Angabe einer dieser Optionen teilen Sie dem Aufgabenplaner mit, wie die Aufgabe im Threadpool geplant werden soll.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-165">By specifying one of these options, you tell the task scheduler how to schedule the task on the thread pool.</span></span> <span data-ttu-id="e3eb1-166">In der folgenden Tabelle sind die verschiedenen Aufgabenerstellungsoptionen aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-166">The following table lists the various task creation options.</span></span>

|<span data-ttu-id="e3eb1-167"><xref:System.Threading.Tasks.TaskCreationOptions>-Parameterwert</span><span class="sxs-lookup"><span data-stu-id="e3eb1-167"><xref:System.Threading.Tasks.TaskCreationOptions> parameter value</span></span>|<span data-ttu-id="e3eb1-168">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="e3eb1-168">Description</span></span>|
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|
|<xref:System.Threading.Tasks.TaskCreationOptions.None>|<span data-ttu-id="e3eb1-169">Dies ist die Standardoption, wenn keine Option angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-169">The default when no option is specified.</span></span> <span data-ttu-id="e3eb1-170">Der Planer verwendet zum Planen der Aufgabe seine Standardheuristik.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-170">The scheduler uses its default heuristics to schedule the task.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>|<span data-ttu-id="e3eb1-171">Gibt an, dass die Aufgabe so geplant werden soll, dass früher erstellte Aufgaben mit großer Wahrscheinlichkeit auch früher ausgeführt werden als Aufgaben, die später erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-171">Specifies that the task should be scheduled so that tasks created sooner will be more likely to be executed sooner, and tasks created later will be more likely to execute later.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.LongRunning>|<span data-ttu-id="e3eb1-172">Gibt an, dass die Aufgabe einen Vorgang mit langer Laufzeit darstellt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-172">Specifies that the task represents a long-running operation.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>|<span data-ttu-id="e3eb1-173">Gibt an, dass eine Aufgabe als angefügtes untergeordnetes Element der aktuellen Aufgabe erstellt werden soll (sofern vorhanden).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-173">Specifies that a task should be created as an attached child of the current task, if one exists.</span></span> <span data-ttu-id="e3eb1-174">Weitere Informationen finden Sie unter [Angefügte und getrennte untergeordnete Aufgaben](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-174">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach>|<span data-ttu-id="e3eb1-175">Gibt an, dass beim Angeben der `AttachedToParent`-Option durch eine innere Aufgabe diese Aufgabe nicht zu einer angefügten untergeordneten Aufgabe wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-175">Specifies that if an inner task specifies the `AttachedToParent` option, that task will not become an attached child task.</span></span>|
|<xref:System.Threading.Tasks.TaskCreationOptions.HideScheduler>|<span data-ttu-id="e3eb1-176">Gibt an, dass der Taskplaner für Aufgaben, die über das Aufrufen von Methoden wie <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> aus einer bestimmten Aufgabe erstellt werden, der Standardplaner ist und nicht der Planer, mit dem diese Aufgabe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-176">Specifies that the task scheduler for tasks created by calling methods like <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> from within a particular task is the default scheduler instead of the scheduler on which this task is running.</span></span>|

<span data-ttu-id="e3eb1-177">Die Optionen können mit einer bitweisen **OR**-Operation kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-177">The options may be combined by using a bitwise **OR** operation.</span></span> <span data-ttu-id="e3eb1-178">Im folgenden Beispiel wird eine Aufgabe veranschaulicht, die über die <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning>-Option und die <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness>-Option verfügt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-178">The following example shows a task that has the <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> and <xref:System.Threading.Tasks.TaskContinuationOptions.PreferFairness> option.</span></span>

[!code-csharp[TPL_TaskIntro#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#03)]
[!code-vb[TPL_TaskIntro#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#03)]

## <a name="tasks-threads-and-culture"></a><span data-ttu-id="e3eb1-179">Aufgaben, Threads und Kultur</span><span class="sxs-lookup"><span data-stu-id="e3eb1-179">Tasks, threads, and culture</span></span>

<span data-ttu-id="e3eb1-180">Jeder Thread hat eine zugeordnete Kultur und Benutzeroberflächenkultur, die durch die <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>- bzw. die <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType>-Eigenschaft definiert ist.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-180">Each thread has an associated culture and UI culture, which is defined by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> properties, respectively.</span></span> <span data-ttu-id="e3eb1-181">Die Kultur eines Threads wird in Vorgängen wie Formatieren, Analysieren, Sortieren und Zeichenfolgenvergleich verwendet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-181">A thread's culture is used in such operations as formatting, parsing, sorting, and string comparison.</span></span> <span data-ttu-id="e3eb1-182">Die Benutzeroberflächenkultur eines Threads wird für Nachschlagen in Ressourcen verwendet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-182">A thread's UI culture is used in resource lookup.</span></span> <span data-ttu-id="e3eb1-183">Normalerweise sind die Standardkultur und -benutzeroberflächenkultur eines Threads durch die Systemkultur definiert, es sei denn, Sie legen eine Standardkultur für alle Threads in einer Anwendungsdomäne mit der <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType>- und der <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>-Eigenschaft fest.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-183">Ordinarily, unless you specify a default culture for all the threads in an application domain by using the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties, the default culture and UI culture of a thread is defined by the system culture.</span></span> <span data-ttu-id="e3eb1-184">Wenn Sie die Kultur eines Threads explizit festlegen und einen neuen Thread starten, erbt der neue Thread nicht die Kultur des aufrufenden Threads, sondern die Standardkultur des Systems wird als seine Kultur verwendet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-184">If you explicitly set a thread's culture and launch a new thread, the new thread does not inherit the culture of the calling thread; instead, its culture is the default system culture.</span></span> <span data-ttu-id="e3eb1-185">Im aufgabenbasierten Programmiermodell für Anwendungen, die gezielt Versionen von .NET Framework vor .NET Framework 4.6 verwenden, wird so vorgegangen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-185">The task-based programming model for apps that target versions of the .NET Framework prior to .NET Framework 4.6 adhere to this practice.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e3eb1-186">Beachten Sie, dass die Kultur des aufrufenden Threads (als Bestandteil des Kontexts einer Aufgabe) für Anwendungen gilt, die *gezielt* .NET Framework 4.6 verwenden, und nicht für Anwendungen, deren *Ausführung unter* .NET Framework 4.6 erfolgt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-186">Note that the calling thread's culture as part of a task's context applies to apps that *target* the .NET Framework 4.6, not apps that *run under* the .NET Framework 4.6.</span></span> <span data-ttu-id="e3eb1-187">Sie können beim Erstellen Ihres Projekts in Visual Studio eine bestimmte Version von .NET Framework als Ziel angeben, indem Sie diese Version aus der Dropdownliste am oberen Rand des Dialogfelds **Neues Projekt** auswählen; außerhalb von Visual Studio können Sie das <xref:System.Runtime.Versioning.TargetFrameworkAttribute>-Attribut verwenden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-187">You can target a particular version of the .NET Framework when you create your project in Visual Studio by selecting that version from the dropdown list at the top of the **New Project** dialog box, or outside of Visual Studio you can use the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute.</span></span> <span data-ttu-id="e3eb1-188">Bei Anwendungen, die gezielt Versionen von .NET Framework vor .NET Framework 4.6 verwenden oder auf keine bestimmte Version von .NET Framework ausgerichtet sind, wird die Kultur einer Aufgabe weiterhin durch die Kultur des Threads bestimmt, über den sie ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-188">For apps that target versions of the .NET Framework prior to the .NET Framework 4.6, or that do not target a specific version of the .NET Framework, a task's culture continues to be determined by the culture of the thread on which it runs.</span></span>

<span data-ttu-id="e3eb1-189">Beginnend mit Anwendungen, die gezielt .NET Framework 4.6 verwenden, erbt jede Aufgabe die Kultur des aufrufenden Threads. Das gilt selbst dann, wenn die Aufgabe asynchron über einen Threadpoolthread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-189">Starting with apps that target the .NET Framework 4.6, the calling thread's culture is inherited by each task, even if the task runs asynchronously on a thread pool thread.</span></span>

<span data-ttu-id="e3eb1-190">Das folgende Beispiel bietet eine einfache Veranschaulichung.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-190">The following example provides a simple illustration.</span></span> <span data-ttu-id="e3eb1-191">In dem Beispiel wird das Attribut <xref:System.Runtime.Versioning.TargetFrameworkAttribute> verwendet, um gezielt .NET Framework 4.6 zu verwenden, und die aktuelle Kultur der Anwendung wird entweder in Französisch (Frankreich) oder, wenn Französisch (Frankreich) bereits die aktuelle Kultur ist, in Englisch (USA) geändert.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-191">It uses the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute to target the .NET Framework 4.6 and changes the app's current culture to either French (France) or, if French (France) is already the current culture, English (United States).</span></span> <span data-ttu-id="e3eb1-192">Anschließend wird der Delegat `formatDelegate` aufgerufen, der einige Zahlen zurückgibt, die als Währungswerte in der neuen Kultur formatiert sind.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-192">It then invokes a delegate named `formatDelegate` that returns some numbers formatted as currency values in the new culture.</span></span> <span data-ttu-id="e3eb1-193">Beachten Sie, dass der Delegat unabhängig davon, ob er als Aufgabe synchron oder asynchron ausgeführt wird, das erwartete Ergebnis zurückgibt, weil die asynchrone Aufgabe die Kultur des aufrufenden Threads erbt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-193">Note that whether the delegate as a task either synchronously or asynchronously, it returns the expected result because the culture of the calling thread is inherited by the asynchronous task.</span></span>

[!code-csharp[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/cs/asyncculture1.cs#5)]
[!code-vb[System.Globalization.CultureInfo.Class.Async#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.cultureinfo.class.async/vb/asyncculture1.vb#5)]

<span data-ttu-id="e3eb1-194">Wenn Sie Visual Studio verwenden, können Sie das <xref:System.Runtime.Versioning.TargetFrameworkAttribute>-Attribut weglassen und stattdessen beim Erstellen des Projekts im Dialogfeld **Neues Projekt** .NET Framework 4.6 als Ziel auswählen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-194">If you are using Visual Studio, you can omit the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute and instead select the .NET Framework 4.6 as the target when you create the project in the **New Project** dialog.</span></span>

<span data-ttu-id="e3eb1-195">Wenn die Ausgabe das Verhalten von Apps widerspiegeln soll, die gezielt .NET Framework-Versionen vor .NET Framework 4.6 verwenden, entfernen Sie das Attribut <xref:System.Runtime.Versioning.TargetFrameworkAttribute> aus dem Quellcode.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-195">For output that reflects the behavior of apps the target versions of the .NET Framework prior to .NET Framework 4.6, remove the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute from the source code.</span></span> <span data-ttu-id="e3eb1-196">Die Ausgabe entspricht den Formatierungskonventionen der Standardsystemkultur, nicht der Kultur des aufrufenden Threads.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-196">The output will reflect the formatting conventions of the default system culture, not the culture of the calling thread.</span></span>

<span data-ttu-id="e3eb1-197">Weitere Informationen zu asynchronen Aufgaben und Kultur, finden Sie im Thema <xref:System.Globalization.CultureInfo> im Abschnitt "Kultur und asynchrone aufgabenbasierte Vorgänge".</span><span class="sxs-lookup"><span data-stu-id="e3eb1-197">For more information on asynchronous tasks and culture, see the "Culture and asynchronous task-based operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>

## <a name="creating-task-continuations"></a><span data-ttu-id="e3eb1-198">Erstellen von Aufgabenfortsetzungen</span><span class="sxs-lookup"><span data-stu-id="e3eb1-198">Creating task continuations</span></span>

<span data-ttu-id="e3eb1-199">Mithilfe der Methoden <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> und <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> können Sie eine Aufgabe angeben, die gestartet werden soll, wenn die *Vorgängeraufgabe* abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-199">The <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType> methods let you specify a task to start when the *antecedent task* finishes.</span></span> <span data-ttu-id="e3eb1-200">An den Delegaten der Fortsetzungsaufgabe wird ein Verweis auf die vorherige Aufgabe übergeben, damit dieser den Status der vorherigen Aufgabe überprüfen kann und durch Abruf des Werts der <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>-Eigenschaft die Ausgabe der vorherigen Aufgabe als Eingabe für die Fortsetzung verwenden kann.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-200">The delegate of the continuation task is passed a reference to the antecedent task so that it can examine the antecedent task's status and, by retrieving the value of the <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property, can use the output of the antecedent as input for the continuation.</span></span>

<span data-ttu-id="e3eb1-201">Im folgenden Beispiel wird die `getData`-Aufgabe durch einen Aufruf der <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType>-Methode gestartet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-201">In the following example, the `getData` task is started by a call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e3eb1-202">Die `processData`-Aufgabe wird automatisch gestartet, wenn `getData` endet, und `displayData` wird gestartet, wenn `processData` endet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-202">The `processData` task is started automatically when `getData` finishes, and `displayData` is started when `processData` finishes.</span></span> <span data-ttu-id="e3eb1-203">`getData` erzeugt ein Ganzzahlarray, auf das über die `processData`-Aufgabe durch die `getData`-Eigenschaft der <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>-Aufgabe zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-203">`getData` produces an integer array, which is accessible to the `processData` task through the `getData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e3eb1-204">Die `processData` Aufgabe verarbeitet das Array und gibt ein Ergebnis zurück, dessen Typ vom Rückgabetyp des Lambda-Ausdrucks abgeleitet wird, der an die <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType>-Methode übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-204">The `processData` task processes that array and returns a result whose type is inferred from the return type of the lambda expression passed to the <xref:System.Threading.Tasks.Task%601.ContinueWith%60%601%28System.Func%7BSystem.Threading.Tasks.Task%7B%600%7D%2C%60%600%7D%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e3eb1-205">Die `displayData`-Aufgabe wird automatisch ausgeführt, wenn  `processData` endet und das <xref:System.Tuple%603>-Objekt, das durch den `processData`-Lambda-Ausdruck zurückgegeben wurde, über die `displayData`-Eigenschaft der `processData`-Aufgabe für die  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>-Aufgabe zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-205">The `displayData` task executes automatically when `processData` finishes, and the <xref:System.Tuple%603> object returned by the `processData` lambda expression is accessible to the `displayData` task through the `processData` task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e3eb1-206">Die `displayData`-Aufgabe nutzt das Ergebnis der `processData`-Aufgabe und erzeugt ein Ergebnis, dessen Typ auf ähnliche Weise abgeleitet wird und das dem Programm in der <xref:System.Threading.Tasks.Task%601.Result%2A>-Eigenschaft zur Verfügung gestellt wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-206">The `displayData` task takes the result of the `processData` task and produces a result whose type is inferred in a similar manner and which is made available to the program in the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span>

[!code-csharp[TPL_TaskIntro#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations1.cs#5)]
[!code-vb[TPL_TaskIntro#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations1.vb#5)]

<span data-ttu-id="e3eb1-207">Da <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> eine Instanzmethode ist, können Sie die Methodenaufrufe verketten, anstatt ein <xref:System.Threading.Tasks.Task%601>-Objekt für jede Vorgängeraufgabe zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-207">Because <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> is an instance method, you can chain method calls together instead of instantiating a <xref:System.Threading.Tasks.Task%601> object for each antecedent task.</span></span> <span data-ttu-id="e3eb1-208">Das folgende Beispiel entspricht funktionell dem vorherigen Beispiel, verkettet aber die Aufrufe der <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-208">The following example is functionally identical to the previous example, except that it chains together calls to the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e3eb1-209">Beachten Sie, dass das <xref:System.Threading.Tasks.Task%601>-Objekt, das durch die Kette von Methodenaufrufen zurückgegeben wird, die endgültige Fortsetzungsaufgabe ist.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-209">Note that the <xref:System.Threading.Tasks.Task%601> object returned by the chain of method calls is the final continuation task.</span></span>

[!code-csharp[TPL_TaskIntro#24](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/continuations2.cs#24)]
[!code-vb[TPL_TaskIntro#24](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/continuations2.vb#24)]

<span data-ttu-id="e3eb1-210">Die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A>-Methode und die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A>-Methode ermöglichen es Ihnen, die Ausführung von mehreren Aufgaben fortzusetzen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-210">The <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> methods enable you to continue from multiple tasks.</span></span>

<span data-ttu-id="e3eb1-211">Weitere Informationen finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-211">For more information, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>

## <a name="creating-detached-child-tasks"></a><span data-ttu-id="e3eb1-212">Erstellen von getrennten untergeordneten Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-212">Creating detached child tasks</span></span>

<span data-ttu-id="e3eb1-213">Wenn durch Benutzercode, der in einer Aufgabe ausgeführt wird, eine neue Aufgabe ohne Angabe der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>-Option erstellt wird, ist die neue Aufgabe auf keine besondere Weise mit der übergeordneten Aufgabe synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-213">When user code that is running in a task creates a new task and does not specify the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is not synchronized with the parent task in any special way.</span></span> <span data-ttu-id="e3eb1-214">Dieser Typ einer nicht synchronisierten Aufgabe wird als *getrennte geschachtelte Aufgabe* oder *getrennte untergeordnete Aufgabe* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-214">This type of non-synchronized task is called a *detached nested task* or *detached child task*.</span></span> <span data-ttu-id="e3eb1-215">Im folgenden Beispiel wird eine Aufgabe dargestellt, die eine getrennte untergeordnete Aufgabe erstellt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-215">The following example shows a task that creates one detached child task.</span></span>

[!code-csharp[TPL_TaskIntro#07](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#07)]
[!code-vb[TPL_TaskIntro#07](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#07)]

<span data-ttu-id="e3eb1-216">Beachten Sie, dass die übergeordnete Aufgabe nicht auf den Abschluss der getrennten untergeordneten Aufgabe wartet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-216">Note that the parent task does not wait for the detached child task to finish.</span></span>

## <a name="creating-child-tasks"></a><span data-ttu-id="e3eb1-217">Erstellen von untergeordneten Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-217">Creating child tasks</span></span>

<span data-ttu-id="e3eb1-218">Wenn durch Benutzercode, der in einer Aufgabe ausgeführt wird, eine Aufgabe mit der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>-Option erstellt wird, wird die neue Aufgabe als *angefügte untergeordnete Aufgabe* der übergeordneten Aufgabe bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-218">When user code that is running in a task creates a task with the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option, the new task is known as a *attached child task* of the parent task.</span></span> <span data-ttu-id="e3eb1-219">Mithilfe der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent>-Option können Sie eine strukturierte Aufgabenparallelität angeben, da die übergeordnete Aufgabe implizit auf den Abschluss aller angefügten untergeordneten Aufgaben wartet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-219">You can use the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> option to express structured task parallelism, because the parent task implicitly waits for all attached child tasks to finish.</span></span> <span data-ttu-id="e3eb1-220">Im folgenden Beispiel wird eine übergeordnete Aufgabe dargestellt, die zehn angefügte untergeordnete Aufgaben erstellt.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-220">The following example shows a parent task that creates ten attached child tasks.</span></span> <span data-ttu-id="e3eb1-221">Beachten Sie, dass, obwohl das Beispiel die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>-Methode aufruft, um auf den Abschluss der übergeordneten Aufgabe zu warten, nicht explizit auf den Abschluss der angefügten untergeordneten Aufgabe gewartet werden muss.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-221">Note that although the example calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the parent task to finish, it does not have to explicitly wait for the attached child tasks to complete.</span></span>

[!code-csharp[TPL_TaskIntro#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/child1.cs#8)]
[!code-vb[TPL_TaskIntro#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/child1.vb#8)]

<span data-ttu-id="e3eb1-222">Durch das Angeben der <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>-Option für eine übergeordnete Aufgabe kann das Anfügen anderer Aufgaben an die übergeordnete Aufgabe verhindert werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-222">A parent task can use the <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> option to prevent other tasks from attaching to the parent task.</span></span> <span data-ttu-id="e3eb1-223">Weitere Informationen finden Sie unter [Angefügte und getrennte untergeordnete Aufgaben](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-223">For more information, see [Attached and Detached Child Tasks](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>

## <a name="waiting-for-tasks-to-finish"></a><span data-ttu-id="e3eb1-224">Warten auf die Beendigung von Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-224">Waiting for tasks to finish</span></span>

<span data-ttu-id="e3eb1-225">Der <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Typ und der <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>-Typ bieten mehrere Überladungen der <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>-Methode, die das Warten auf den Abschluss einer Aufgabe ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-225">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types provide several overloads of the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> methods that enable you to wait for a task to finish.</span></span> <span data-ttu-id="e3eb1-226">Außerdem können Sie mittels Überladungen der statischen <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>-Methode und der <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType>-Methode auf den Abschluss einer bestimmten oder aller Aufgaben in einem Array warten.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-226">In addition, overloads of the static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> methods let you wait for any or all of an array of tasks to finish.</span></span>

<span data-ttu-id="e3eb1-227">In der Regel wird aus einem der folgenden Gründe auf den Abschluss einer Aufgabe gewartet:</span><span class="sxs-lookup"><span data-stu-id="e3eb1-227">Typically, you would wait for a task for one of these reasons:</span></span>

- <span data-ttu-id="e3eb1-228">Der Hauptthread hängt von dem Endergebnis ab, das von einer Aufgabe berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-228">The main thread depends on the final result computed by a task.</span></span>

- <span data-ttu-id="e3eb1-229">Sie müssen Ausnahmen behandeln, die möglicherweise von der Aufgabe ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-229">You have to handle exceptions that might be thrown from the task.</span></span>

- <span data-ttu-id="e3eb1-230">Die Anwendung wird möglicherweise beendet, ehe die Ausführung aller Aufgaben abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-230">The application may terminate before all tasks have completed execution.</span></span> <span data-ttu-id="e3eb1-231">Beispielsweise werden Konsolenanwendungen beendet, sobald der synchrone Code in `Main` (dem Anwendungseinstiegspunkt) ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-231">For example, console applications will terminate as soon as all synchronous code in `Main` (the application entry point) has executed.</span></span>

<span data-ttu-id="e3eb1-232">Im folgenden Beispiel wird das grundlegende Muster dargestellt, das keine Ausnahmebehandlung beinhaltet.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-232">The following example shows the basic pattern that does not involve exception handling.</span></span>

[!code-csharp[TPL_TaskIntro#06](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_taskintro/cs/taskintro.cs#06)]
[!code-vb[TPL_TaskIntro#06](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_taskintro/vb/tpl_intro.vb#06)]

<span data-ttu-id="e3eb1-233">Ein Beispiel, in dem die Behandlung von Ausnahmen veranschaulicht wird, finden Sie unter [Ausnahmebehandlung](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-233">For an example that shows exception handling, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>

<span data-ttu-id="e3eb1-234">Bei einigen Überladungen können Sie einen Timeout angeben, während andere ein zusätzliches <xref:System.Threading.CancellationToken> als Eingabeparameter nutzen, sodass der Wartevorgang selbst entweder programmgesteuert oder als Reaktion auf eine Benutzereingabe abgebrochen werden kann.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-234">Some overloads let you specify a time-out, and others take an additional <xref:System.Threading.CancellationToken> as an input parameter, so that the wait itself can be canceled either programmatically or in response to user input.</span></span>

<span data-ttu-id="e3eb1-235">Beim Warten auf eine Aufgabe wird implizit auf alle untergeordneten Elemente dieser Aufgabe gewartet, die mit der <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType>-Option erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-235">When you wait for a task, you implicitly wait for all children of that task that were created by using the <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="e3eb1-236"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> wird sofort zurückgegeben, wenn die Aufgabe bereits abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-236"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> returns immediately if the task has already completed.</span></span> <span data-ttu-id="e3eb1-237">Alle von einer Aufgabe ausgelöste Ausnahmen werden von einer <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>-Methode ausgelöst, auch wenn die <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>-Methode nach Abschluss der Aufgabe aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-237">Any exceptions raised by a task will be thrown by a <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method, even if the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method was called after the task completed.</span></span>

## <a name="composing-tasks"></a><span data-ttu-id="e3eb1-238">Verfassen von Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-238">Composing tasks</span></span>

<span data-ttu-id="e3eb1-239">Die Klassen <xref:System.Threading.Tasks.Task> und <xref:System.Threading.Tasks.Task%601> bieten mehrere Methoden zur einfacheren Erstellung mehrerer Aufgaben, um allgemeine Muster zu implementieren und die in C#, Visual Basic sowie F# bereitgestellten asynchronen Sprachfeatures besser einzusetzen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-239">The <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes provide several methods that can help you compose multiple tasks to implement common patterns and to better use the asynchronous language features that are provided by C#, Visual Basic, and F#.</span></span> <span data-ttu-id="e3eb1-240">In diesem Abschnitt werden die Methoden <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A> und <xref:System.Threading.Tasks.Task.FromResult%2A> beschrieben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-240">This section describes the <xref:System.Threading.Tasks.Task.WhenAll%2A>, <xref:System.Threading.Tasks.Task.WhenAny%2A>, <xref:System.Threading.Tasks.Task.Delay%2A>, and <xref:System.Threading.Tasks.Task.FromResult%2A> methods.</span></span>

### <a name="taskwhenall"></a><span data-ttu-id="e3eb1-241">Task.WhenAll</span><span class="sxs-lookup"><span data-stu-id="e3eb1-241">Task.WhenAll</span></span>

<span data-ttu-id="e3eb1-242">Die <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>-Methode wartet asynchron auf den Abschluss mehrerer <xref:System.Threading.Tasks.Task>-Objekte oder <xref:System.Threading.Tasks.Task%601>-Objekte.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-242">The <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method asynchronously waits for multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="e3eb1-243">Die Methode stellt überladene Versionen zum Warten auf nicht einheitliche Sätze von Aufgaben bereit.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-243">It provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="e3eb1-244">Beispielsweise kann in einem Methodenaufruf auf den Abschluss mehrerer <xref:System.Threading.Tasks.Task>-Objekte und <xref:System.Threading.Tasks.Task%601>-Objekte gewartet werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-244">For example, you can wait for multiple <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects to complete from one method call.</span></span>

### <a name="taskwhenany"></a><span data-ttu-id="e3eb1-245">Task.WhenAny</span><span class="sxs-lookup"><span data-stu-id="e3eb1-245">Task.WhenAny</span></span>

<span data-ttu-id="e3eb1-246">Die <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType>-Methode wartet asynchron auf den Abschluss eines von mehreren <xref:System.Threading.Tasks.Task>-Objekten oder <xref:System.Threading.Tasks.Task%601>-Objekten.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-246">The <xref:System.Threading.Tasks.Task.WhenAny%2A?displayProperty=nameWithType> method asynchronously waits for one of multiple <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> objects to finish.</span></span> <span data-ttu-id="e3eb1-247">Wie die <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>-Methode stellt auch diese Methode überladene Versionen bereit, mit denen auf nicht einheitliche Sätze von Aufgaben gewartet werden kann.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-247">As in the <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> method, this method provides overloaded versions that enable you to wait for non-uniform sets of tasks.</span></span> <span data-ttu-id="e3eb1-248">Die <xref:System.Threading.Tasks.Task.WhenAny%2A>-Methode ist insbesondere in folgenden Szenarien nützlich.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-248">The <xref:System.Threading.Tasks.Task.WhenAny%2A> method is especially useful in the following scenarios.</span></span>

- <span data-ttu-id="e3eb1-249">Redundante Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-249">Redundant operations.</span></span> <span data-ttu-id="e3eb1-250">Betrachten Sie einen Algorithmus oder einen Vorgang, der auf verschiedene Weise ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-250">Consider an algorithm or operation that can be performed in many ways.</span></span> <span data-ttu-id="e3eb1-251">Sie können die <xref:System.Threading.Tasks.Task.WhenAny%2A>-Methode verwenden, um den Vorgang auszuwählen, der zuerst beendet wird, und dann die verbleibenden Vorgänge abzubrechen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-251">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select the operation that finishes first and then cancel the remaining operations.</span></span>

- <span data-ttu-id="e3eb1-252">Überlappende Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-252">Interleaved operations.</span></span> <span data-ttu-id="e3eb1-253">Sie können mehrere Vorgänge starten, die alle beendet werden müssen, und die <xref:System.Threading.Tasks.Task.WhenAny%2A>-Methode verwenden, um Ergebnisse zu verarbeiten, wenn jeder Vorgang beendet wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-253">You can start multiple operations that must all finish and use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to process results as each operation finishes.</span></span> <span data-ttu-id="e3eb1-254">Nachdem ein Vorgang beendet wurde, können Sie eine oder mehrere weitere Aufgaben starten.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-254">After one operation finishes, you can start one or more additional tasks.</span></span>

- <span data-ttu-id="e3eb1-255">Eingeschränkte Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-255">Throttled operations.</span></span> <span data-ttu-id="e3eb1-256">Sie können die <xref:System.Threading.Tasks.Task.WhenAny%2A>-Methode verwenden, um das vorherige Szenario zu erweitern, indem Sie die Anzahl der gleichzeitigen Vorgänge einschränken.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-256">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to extend the previous scenario by limiting the number of concurrent operations.</span></span>

- <span data-ttu-id="e3eb1-257">Abgelaufene Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-257">Expired operations.</span></span> <span data-ttu-id="e3eb1-258">Sie können die <xref:System.Threading.Tasks.Task.WhenAny%2A>-Methode verwenden, um eine Auswahl zwischen einer oder mehreren Aufgaben und einer anderen Aufgabe zu treffen, die nach einem bestimmten Zeitpunkt abgeschlossen wird, z. B. die von der <xref:System.Threading.Tasks.Task.Delay%2A>-Methode zurückgegebene Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-258">You can use the <xref:System.Threading.Tasks.Task.WhenAny%2A> method to select between one or more tasks and a task that finishes after a specific time, such as a task that is returned by the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span> <span data-ttu-id="e3eb1-259">Die <xref:System.Threading.Tasks.Task.Delay%2A>-Methode wird im folgenden Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-259">The <xref:System.Threading.Tasks.Task.Delay%2A> method is described in the following section.</span></span>

### <a name="taskdelay"></a><span data-ttu-id="e3eb1-260">Task.Delay</span><span class="sxs-lookup"><span data-stu-id="e3eb1-260">Task.Delay</span></span>

<span data-ttu-id="e3eb1-261">Die <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType>-Methode generiert <xref:System.Threading.Tasks.Task>-Objekt, das nach dem angegebenen Zeitraum abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-261">The <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method produces a <xref:System.Threading.Tasks.Task> object that finishes after the specified time.</span></span> <span data-ttu-id="e3eb1-262">Mithilfe dieser Methode können Sie Schleifen erstellen, die gelegentlich Daten abrufen, Timeouts einfügen, die Verarbeitung von Benutzereingaben für einen vorab festgelegten Zeitraum verzögern usw.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-262">You can use this method to build loops that occasionally poll for data, introduce time-outs, delay the handling of user input for a predetermined time, and so on.</span></span>

### <a name="tasktfromresult"></a><span data-ttu-id="e3eb1-263">Task(T).FromResult</span><span class="sxs-lookup"><span data-stu-id="e3eb1-263">Task(T).FromResult</span></span>

<span data-ttu-id="e3eb1-264">Mit der <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType>-Methode, können Sie ein <xref:System.Threading.Tasks.Task%601>-Objekt erstellen, das ein vorberechnetes Ergebnis enthält.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-264">By using the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method, you can create a <xref:System.Threading.Tasks.Task%601> object that holds a pre-computed result.</span></span> <span data-ttu-id="e3eb1-265">Diese Methode ist nützlich, wenn Sie einen asynchronen Vorgang ausführen, der ein <xref:System.Threading.Tasks.Task%601>-Objekt zurückgibt, und das Ergebnis dieses <xref:System.Threading.Tasks.Task%601>-Objekts bereits berechnet wurde.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-265">This method is useful when you perform an asynchronous operation that returns a <xref:System.Threading.Tasks.Task%601> object, and the result of that <xref:System.Threading.Tasks.Task%601> object is already computed.</span></span> <span data-ttu-id="e3eb1-266">Ein Beispiel, das <xref:System.Threading.Tasks.Task.FromResult%2A> verwendet, um die Ergebnisse asynchroner Downloadvorgänge aus einem Cache abzurufen, finden Sie unter [Vorgehensweise: Erstellen von vorberechneten Aufgaben](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-266">For an example that uses <xref:System.Threading.Tasks.Task.FromResult%2A> to retrieve the results of asynchronous download operations that are held in a cache, see [How to: Create Pre-Computed Tasks](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md).</span></span>

## <a name="handling-exceptions-in-tasks"></a><span data-ttu-id="e3eb1-267">Behandeln von Ausnahmen in Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-267">Handling exceptions in tasks</span></span>

<span data-ttu-id="e3eb1-268">Wenn eine Aufgabe eine oder mehrere Ausnahmen auslöst, werden die Ausnahmen in eine <xref:System.AggregateException>-Ausnahme eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-268">When a task throws one or more exceptions, the exceptions are wrapped in an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="e3eb1-269">Diese Ausnahme wird an den Thread zurückgegeben, der mit der Aufgabe verbunden ist. In der Regel ist dies der Thread, der auf den Abschluss der Aufgabe wartet oder der Thread, der auf die <xref:System.Threading.Tasks.Task%601.Result%2A>-Eigenschaft zugreift.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-269">That exception is propagated back to the thread that joins with the task, which is typically the thread that is waiting for the task to finish or the thread that accesses the <xref:System.Threading.Tasks.Task%601.Result%2A> property.</span></span> <span data-ttu-id="e3eb1-270">Dieses Verhalten trägt dazu bei, dass die .NET Framework-Richtlinie umgesetzt wird, der zufolge alle Ausnahmefehler standardmäßig zu einem Beenden des Prozesses führen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-270">This behavior serves to enforce the .NET Framework policy that all unhandled exceptions by default should terminate the process.</span></span> <span data-ttu-id="e3eb1-271">Der aufrufende Code kann die Ausnahmen behandeln, indem er Folgendes in einem `try`/`catch`-Block verwendet:</span><span class="sxs-lookup"><span data-stu-id="e3eb1-271">The calling code can handle the exceptions by using any of the following in a `try`/`catch` block:</span></span>

- <span data-ttu-id="e3eb1-272">Die <xref:System.Threading.Tasks.Task.Wait%2A> -Methode</span><span class="sxs-lookup"><span data-stu-id="e3eb1-272">The <xref:System.Threading.Tasks.Task.Wait%2A> method</span></span>

- <span data-ttu-id="e3eb1-273">Die <xref:System.Threading.Tasks.Task.WaitAll%2A> -Methode</span><span class="sxs-lookup"><span data-stu-id="e3eb1-273">The <xref:System.Threading.Tasks.Task.WaitAll%2A> method</span></span>

- <span data-ttu-id="e3eb1-274">Die <xref:System.Threading.Tasks.Task.WaitAny%2A> -Methode</span><span class="sxs-lookup"><span data-stu-id="e3eb1-274">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method</span></span>

- <span data-ttu-id="e3eb1-275">Die <xref:System.Threading.Tasks.Task%601.Result%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-275">The <xref:System.Threading.Tasks.Task%601.Result%2A> property</span></span>

<span data-ttu-id="e3eb1-276">Der Verbindungsthread kann Ausnahmen ebenfalls behandeln, indem er auf die <xref:System.Threading.Tasks.Task.Exception%2A>-Eigenschaft zugreift, bevor die Aufgabe der Garbage Collection zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-276">The joining thread can also handle exceptions by accessing the <xref:System.Threading.Tasks.Task.Exception%2A> property before the task is garbage-collected.</span></span> <span data-ttu-id="e3eb1-277">Durch den Zugriff auf diese Eigenschaft verhindern Sie, dass der Ausnahmefehler das Ausnahmeweitergabe-Verhalten auslöst, durch das der Prozess beim Abschluss des Objekts beendet wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-277">By accessing this property, you prevent the unhandled exception from triggering the exception propagation behavior that terminates the process when the object is finalized.</span></span>

<span data-ttu-id="e3eb1-278">Weitere Informationen zu Ausnahmen und Aufgaben finden Sie unter [Ausnahmebehandlung](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-278">For more information about exceptions and tasks, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>

## <a name="canceling-tasks"></a><span data-ttu-id="e3eb1-279">Abbrechen von Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-279">Canceling tasks</span></span>

<span data-ttu-id="e3eb1-280">Die <xref:System.Threading.Tasks.Task>-Klasse unterstützt einen kooperativen Abbruch und ist vollständig in die <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType>-Klasse und die <xref:System.Threading.CancellationToken?displayProperty=nameWithType>-Klasse integriert, die in .NET Framework 4 eingeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-280">The <xref:System.Threading.Tasks.Task> class supports cooperative cancellation and is fully integrated with the <xref:System.Threading.CancellationTokenSource?displayProperty=nameWithType> and <xref:System.Threading.CancellationToken?displayProperty=nameWithType> classes, which were introduced in the .NET Framework 4.</span></span> <span data-ttu-id="e3eb1-281">Viele Konstruktoren in der <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>-Klasse verwenden ein <xref:System.Threading.CancellationToken>-Objekt als Eingabeparameter.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-281">Many of the constructors in the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class take a <xref:System.Threading.CancellationToken> object as an input parameter.</span></span> <span data-ttu-id="e3eb1-282">Viele der <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>- und <xref:System.Threading.Tasks.Task.Run%2A>-Überladungen enthalten auch einen <xref:System.Threading.CancellationToken>-Parameter.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-282">Many of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> and <xref:System.Threading.Tasks.Task.Run%2A> overloads also include a <xref:System.Threading.CancellationToken> parameter.</span></span>

<span data-ttu-id="e3eb1-283">Mit der <xref:System.Threading.CancellationTokenSource>-Klasse können Sie das Token erstellen und die Abbruchanforderung zu einem späteren Zeitpunkt ausgeben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-283">You can create the token, and issue the cancellation request at some later time, by using the <xref:System.Threading.CancellationTokenSource> class.</span></span> <span data-ttu-id="e3eb1-284">Übergeben Sie das Token als Argument an <xref:System.Threading.Tasks.Task>, und verweisen Sie in dem Benutzerdelegaten, der auf eine Abbruchanforderung reagiert, auf das gleiche Token.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-284">Pass the token to the <xref:System.Threading.Tasks.Task> as an argument, and also reference the same token in your user delegate, which does the work of responding to a cancellation request.</span></span>

<span data-ttu-id="e3eb1-285">Weitere Informationen finden Sie unter [Aufgabenabbruch](../../../docs/standard/parallel-programming/task-cancellation.md) und [Vorgehensweise: Abbrechen einer Aufgabe und ihrer untergeordneten Elemente](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-285">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md) and [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>

## <a name="the-taskfactory-class"></a><span data-ttu-id="e3eb1-286">Die TaskFactory-Klasse</span><span class="sxs-lookup"><span data-stu-id="e3eb1-286">The TaskFactory class</span></span>

<span data-ttu-id="e3eb1-287">Die <xref:System.Threading.Tasks.TaskFactory>-Klasse stellt statische Methoden bereit, die einige allgemeine Muster zum Erstellen und Starten von Aufgaben und Fortsetzungsaufgaben kapseln.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-287">The <xref:System.Threading.Tasks.TaskFactory> class provides static methods that encapsulate some common patterns for creating and starting tasks and continuation tasks.</span></span>

- <span data-ttu-id="e3eb1-288">Das bekannteste Muster ist <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, durch das in einer Anweisung eine Aufgabe erstellt und gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-288">The most common pattern is <xref:System.Threading.Tasks.TaskFactory.StartNew%2A>, which creates and starts a task in one statement.</span></span>

- <span data-ttu-id="e3eb1-289">Wenn Sie Fortsetzungsaufgaben aus mehreren Vorgängern erstellen, verwenden Sie die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A>-Methode oder die <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A>-Methode oder die äquivalenten Methoden in der <xref:System.Threading.Tasks.Task%601>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-289">When you create continuation tasks from multiple antecedents, use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> method or <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> method or their equivalents in the <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="e3eb1-290">Weitere Informationen finden Sie unter [Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-290">For more information, see [Chaining Tasks by Using Continuation Tasks](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>

- <span data-ttu-id="e3eb1-291">Um die `BeginX`-Methode und `EndX`-Methode des asynchronen Programmiermodells in einer <xref:System.Threading.Tasks.Task>-Instanz oder <xref:System.Threading.Tasks.Task%601>-Instanz zu kapseln, verwenden Sie die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A>-Methoden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-291">To encapsulate Asynchronous Programming Model `BeginX` and `EndX` methods in a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> instance, use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="e3eb1-292">Weitere Informationen finden Sie unter [TPL und herkömmliche asynchrone .NET Framework-Programmierung](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-292">For more information, see [TPL and Traditional .NET Framework Asynchronous Programming](../../../docs/standard/parallel-programming/tpl-and-traditional-async-programming.md).</span></span>

<span data-ttu-id="e3eb1-293">Auf die standardmäßige <xref:System.Threading.Tasks.TaskFactory> kann als statische Eigenschaft in der <xref:System.Threading.Tasks.Task>-Klasse oder <xref:System.Threading.Tasks.Task%601>-Klasse zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-293">The default <xref:System.Threading.Tasks.TaskFactory> can be accessed as a static property on the <xref:System.Threading.Tasks.Task> class or <xref:System.Threading.Tasks.Task%601> class.</span></span> <span data-ttu-id="e3eb1-294">Sie können eine <xref:System.Threading.Tasks.TaskFactory> auch direkt instanziieren und verschiedene Optionen angeben, einschließlich <xref:System.Threading.CancellationToken>, <xref:System.Threading.Tasks.TaskCreationOptions>, <xref:System.Threading.Tasks.TaskContinuationOptions> oder <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-294">You can also instantiate a <xref:System.Threading.Tasks.TaskFactory> directly and specify various options that include a <xref:System.Threading.CancellationToken>, a <xref:System.Threading.Tasks.TaskCreationOptions> option, a <xref:System.Threading.Tasks.TaskContinuationOptions> option, or a <xref:System.Threading.Tasks.TaskScheduler>.</span></span> <span data-ttu-id="e3eb1-295">Die beim Erstellen der Aufgabenfactory angegebenen Optionen werden auf alle Aufgaben angewendet, die von dieser erstellt werden, außer Sie erstellen <xref:System.Threading.Tasks.Task> mit der <xref:System.Threading.Tasks.TaskCreationOptions>-Enumeration. In diesem Fall werden die Optionen der Aufgabenfactory mit den Optionen der Aufgabe überschrieben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-295">Whatever options are specified when you create the task factory will be applied to all tasks that it creates, unless the <xref:System.Threading.Tasks.Task> is created by using the <xref:System.Threading.Tasks.TaskCreationOptions> enumeration, in which case the task's options override those of the task factory.</span></span>

## <a name="tasks-without-delegates"></a><span data-ttu-id="e3eb1-296">Aufgaben ohne Delegaten</span><span class="sxs-lookup"><span data-stu-id="e3eb1-296">Tasks without delegates</span></span>

<span data-ttu-id="e3eb1-297">In einigen Fällen können Sie mithilfe einer <xref:System.Threading.Tasks.Task> einen asynchronen Vorgang kapseln, der nicht von Ihrem Benutzerdelegaten, sondern von einer externen Komponente durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-297">In some cases, you may want to use a <xref:System.Threading.Tasks.Task> to encapsulate some asynchronous operation that is performed by an external component instead of your own user delegate.</span></span> <span data-ttu-id="e3eb1-298">Wenn der Vorgang auf dem Begin/End-Muster des asynchronen Programmiermodells basiert, können Sie die <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A>-Methoden verwenden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-298">If the operation is based on the Asynchronous Programming Model Begin/End pattern, you can use the <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> methods.</span></span> <span data-ttu-id="e3eb1-299">Wenn das nicht der Fall ist, können Sie den Vorgang mithilfe des <xref:System.Threading.Tasks.TaskCompletionSource%601>-Objekts in eine Aufgabe einschließen und dadurch bestimmte Vorteile der <xref:System.Threading.Tasks.Task>-Programmierbarkeit erhalten, z. B. Unterstützung von Ausnahmeweitergabe und Fortsetzungen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-299">If that is not the case, you can use the <xref:System.Threading.Tasks.TaskCompletionSource%601> object to wrap the operation in a task and thereby gain some of the benefits of <xref:System.Threading.Tasks.Task> programmability, for example, support for exception propagation and continuations.</span></span> <span data-ttu-id="e3eb1-300">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-300">For more information, see <xref:System.Threading.Tasks.TaskCompletionSource%601>.</span></span>

## <a name="custom-schedulers"></a><span data-ttu-id="e3eb1-301">Benutzerdefinierte Planer</span><span class="sxs-lookup"><span data-stu-id="e3eb1-301">Custom schedulers</span></span>

<span data-ttu-id="e3eb1-302">Die meisten Anwendungs- oder Bibliotheksentwickler machen sich keine Gedanken über den für die Ausführung der Aufgabe verwendeten Prozessor, über die Synchronisierung der Arbeit mit anderen Aufgaben oder die Planung im <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-302">Most application or library developers do not care which processor the task runs on, how it synchronizes its work with other tasks, or how it is scheduled on the <xref:System.Threading.ThreadPool?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e3eb1-303">Die einzige Voraussetzung für sie ist eine möglichst effiziente Ausführung auf dem Hostcomputer.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-303">They only require that it execute as efficiently as possible on the host computer.</span></span> <span data-ttu-id="e3eb1-304">Wenn Sie eine präzisere Steuerung der Planungsdetails benötigen, können Sie in der Task Parallel Library bestimmte Einstellungen im Standardaufgabenplaner konfigurieren und sogar einen benutzerdefinierten Planer angeben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-304">If you require more fine-grained control over the scheduling details, the Task Parallel Library lets you configure some settings on the default task scheduler, and even lets you supply a custom scheduler.</span></span> <span data-ttu-id="e3eb1-305">Weitere Informationen finden Sie unter <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-305">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>

## <a name="related-data-structures"></a><span data-ttu-id="e3eb1-306">Verwandte Datenstrukturen</span><span class="sxs-lookup"><span data-stu-id="e3eb1-306">Related data structures</span></span>

<span data-ttu-id="e3eb1-307">Die TPL beinhaltet zahlreiche neue öffentliche Typen, die sowohl in parallelen, als auch in sequenziellen Szenarios hilfreich sind.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-307">The TPL has several new public types that are useful in both parallel and sequential scenarios.</span></span> <span data-ttu-id="e3eb1-308">Hierzu zählen mehrere threadsichere, schnelle und skalierbare Auflistungsklassen im <xref:System.Collections.Concurrent?displayProperty=nameWithType>-Namespace sowie mehrere neue Synchronisierungstypen, z. B. <xref:System.Threading.Semaphore?displayProperty=nameWithType> und <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, die für bestimmte Arten von Arbeitslasten effizienter als ihre Vorgänger sind.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-308">These include several thread-safe, fast and scalable collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, and several new synchronization types, for example, <xref:System.Threading.Semaphore?displayProperty=nameWithType> and <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>, which are more efficient than their predecessors for specific kinds of workloads.</span></span> <span data-ttu-id="e3eb1-309">Andere neue Typen in .NET Framework 4, z. B. <xref:System.Threading.Barrier?displayProperty=nameWithType> und <xref:System.Threading.SpinLock?displayProperty=nameWithType>, stellen Funktionalität bereit, die in früheren Releases nicht verfügbar war.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-309">Other new types in the .NET Framework 4, for example, <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.SpinLock?displayProperty=nameWithType>, provide functionality that was not available in earlier releases.</span></span> <span data-ttu-id="e3eb1-310">Weitere Informationen finden Sie unter [Datenstrukturen für die parallele Programmierung](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-310">For more information, see [Data Structures for Parallel Programming](../../../docs/standard/parallel-programming/data-structures-for-parallel-programming.md).</span></span>

## <a name="custom-task-types"></a><span data-ttu-id="e3eb1-311">Benutzerdefinierte Aufgabentypen</span><span class="sxs-lookup"><span data-stu-id="e3eb1-311">Custom task types</span></span>

<span data-ttu-id="e3eb1-312">Es wird empfohlen, nicht von <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> zu erben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-312">We recommend that you do not inherit from <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e3eb1-313">Stattdessen sollten Sie die <xref:System.Threading.Tasks.Task.AsyncState%2A>-Eigenschaft verwenden, um einem <xref:System.Threading.Tasks.Task>-Objekt oder einem <xref:System.Threading.Tasks.Task%601>-Objekt zusätzliche Daten oder einen zusätzlichen Zustand zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-313">Instead, we recommend that you use the <xref:System.Threading.Tasks.Task.AsyncState%2A> property to associate additional data or state with a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object.</span></span> <span data-ttu-id="e3eb1-314">Sie können auch Erweiterungsmethoden verwenden, um die Funktionen der <xref:System.Threading.Tasks.Task>-Klasse und der <xref:System.Threading.Tasks.Task%601>-Klasse zu erweitern.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-314">You can also use extension methods to extend the functionality of the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes.</span></span> <span data-ttu-id="e3eb1-315">Weitere Informationen zu Erweiterungsmethoden finden Sie unter [Erweiterungsmethoden](../../csharp/programming-guide/classes-and-structs/extension-methods.md) und [Erweiterungsmethoden](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="e3eb1-315">For more information about extension methods, see [Extension Methods](../../csharp/programming-guide/classes-and-structs/extension-methods.md) and [Extension Methods](../../visual-basic/programming-guide/language-features/procedures/extension-methods.md).</span></span>

<span data-ttu-id="e3eb1-316">Wenn Sie von <xref:System.Threading.Tasks.Task> oder <xref:System.Threading.Tasks.Task%601> erben müssen, können Sie nicht <xref:System.Threading.Tasks.Task.Run%2A> oder die Klassen <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType> oder <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> zum Erstellen von Instanzen des benutzerdefinierten Aufgabentyps verwenden, da von diesen Mechanismen nur <xref:System.Threading.Tasks.Task>- und <xref:System.Threading.Tasks.Task%601>-Objekte erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-316">If you must inherit from <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, you cannot use <xref:System.Threading.Tasks.Task.Run%2A>, or the <xref:System.Threading.Tasks.TaskFactory?displayProperty=nameWithType>, <xref:System.Threading.Tasks.TaskFactory%601?displayProperty=nameWithType>, or <xref:System.Threading.Tasks.TaskCompletionSource%601?displayProperty=nameWithType> classes to create instances of your custom task type because these mechanisms create only <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> objects.</span></span> <span data-ttu-id="e3eb1-317">Außerdem können Sie nicht die von <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory> und <xref:System.Threading.Tasks.TaskFactory%601> bereitgestellten Aufgabenfortsetzungsmechanismen verwenden, um Instanzen des benutzerdefinierten Aufgabentyps zu erstellen, da mit diesen Mechanismen ebenfalls nur <xref:System.Threading.Tasks.Task>-Objekte und <xref:System.Threading.Tasks.Task%601>-Objekte erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-317">In addition, you cannot use the task continuation mechanisms that are provided by <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.TaskFactory>, and  <xref:System.Threading.Tasks.TaskFactory%601> to create instances of your custom task type because these mechanisms also create only <xref:System.Threading.Tasks.Task> and  <xref:System.Threading.Tasks.Task%601> objects.</span></span>

## <a name="related-topics"></a><span data-ttu-id="e3eb1-318">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="e3eb1-318">Related topics</span></span>

|<span data-ttu-id="e3eb1-319">Titel</span><span class="sxs-lookup"><span data-stu-id="e3eb1-319">Title</span></span>|<span data-ttu-id="e3eb1-320">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="e3eb1-320">Description</span></span>|
|-|-|
|[<span data-ttu-id="e3eb1-321">Verketten von Aufgaben mithilfe von Fortsetzungsaufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-321">Chaining Tasks by Using Continuation Tasks</span></span>](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)|<span data-ttu-id="e3eb1-322">Beschreibt die Funktionsweise von Fortsetzungen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-322">Describes how continuations work.</span></span>|
|[<span data-ttu-id="e3eb1-323">Angefügte und getrennte untergeordnete Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-323">Attached and Detached Child Tasks</span></span>](../../../docs/standard/parallel-programming/attached-and-detached-child-tasks.md)|<span data-ttu-id="e3eb1-324">Beschreibt den Unterschied zwischen angefügten und getrennten untergeordneten Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-324">Describes the difference between attached and detached child tasks.</span></span>|
|[<span data-ttu-id="e3eb1-325">Aufgabenabbruch</span><span class="sxs-lookup"><span data-stu-id="e3eb1-325">Task Cancellation</span></span>](../../../docs/standard/parallel-programming/task-cancellation.md)|<span data-ttu-id="e3eb1-326">Beschreibt die integrierte Abbruchunterstützung des <xref:System.Threading.Tasks.Task>-Objekts.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-326">Describes the cancellation support that is built into the <xref:System.Threading.Tasks.Task> object.</span></span>|
|[<span data-ttu-id="e3eb1-327">Ausnahmebehandlung</span><span class="sxs-lookup"><span data-stu-id="e3eb1-327">Exception Handling</span></span>](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)|<span data-ttu-id="e3eb1-328">Beschreibt die Behandlung von Ausnahmen in gleichzeitigen Threads.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-328">Describes how exceptions on concurrent threads are handled.</span></span>|
|[<span data-ttu-id="e3eb1-329">How to: Ausführen von parallelen Vorgängen mithilfe von „Parallel.Invoke“</span><span class="sxs-lookup"><span data-stu-id="e3eb1-329">How to: Use Parallel.Invoke to Execute Parallel Operations</span></span>](../../../docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|<span data-ttu-id="e3eb1-330">Beschreibt die Verwendung von <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-330">Describes how to use <xref:System.Threading.Tasks.Parallel.Invoke%2A>.</span></span>|
|[<span data-ttu-id="e3eb1-331">How to: Zurückgeben eines Werts aus einer Aufgabe</span><span class="sxs-lookup"><span data-stu-id="e3eb1-331">How to: Return a Value from a Task</span></span>](../../../docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md)|<span data-ttu-id="e3eb1-332">Beschreibt, wie in Aufgaben Werte zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-332">Describes how to return values from tasks.</span></span>|
|[<span data-ttu-id="e3eb1-333">How to: Abbrechen einer Aufgabe und ihrer untergeordneten Elemente</span><span class="sxs-lookup"><span data-stu-id="e3eb1-333">How to: Cancel a Task and Its Children</span></span>](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)|<span data-ttu-id="e3eb1-334">Beschreibt, wie Aufgaben abgebrochen werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-334">Describes how to cancel tasks.</span></span>|
|[<span data-ttu-id="e3eb1-335">How to: Erstellen von vorberechneten Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-335">How to: Create Pre-Computed Tasks</span></span>](../../../docs/standard/parallel-programming/how-to-create-pre-computed-tasks.md)|<span data-ttu-id="e3eb1-336">Beschreibt, wie mithilfe der <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType>-Methode die Ergebnisse asynchroner Downloadvorgänge aus einem Cache abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-336">Describes how to use the <xref:System.Threading.Tasks.Task.FromResult%2A?displayProperty=nameWithType> method to retrieve the results of asynchronous download operations that are held in a cache.</span></span>|
|[<span data-ttu-id="e3eb1-337">How to: Durchlaufen einer binären Struktur mit parallelen Aufgaben</span><span class="sxs-lookup"><span data-stu-id="e3eb1-337">How to: Traverse a Binary Tree with Parallel Tasks</span></span>](../../../docs/standard/parallel-programming/how-to-traverse-a-binary-tree-with-parallel-tasks.md)|<span data-ttu-id="e3eb1-338">Beschreibt, wie Aufgaben zum Traversieren einer binären Struktur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-338">Describes how to use tasks to traverse a binary tree.</span></span>|
|[<span data-ttu-id="e3eb1-339">How to: Entpacken einer geschachtelten Aufgabe</span><span class="sxs-lookup"><span data-stu-id="e3eb1-339">How to: Unwrap a Nested Task</span></span>](../../../docs/standard/parallel-programming/how-to-unwrap-a-nested-task.md)|<span data-ttu-id="e3eb1-340">Veranschaulicht die Verwendung der <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A>-Erweiterungsmethode.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-340">Demonstrates how to use the <xref:System.Threading.Tasks.TaskExtensions.Unwrap%2A> extension method.</span></span>|
|[<span data-ttu-id="e3eb1-341">Datenparallelität</span><span class="sxs-lookup"><span data-stu-id="e3eb1-341">Data Parallelism</span></span>](../../../docs/standard/parallel-programming/data-parallelism-task-parallel-library.md)|<span data-ttu-id="e3eb1-342">Beschreibt, wie Sie mithilfe von <xref:System.Threading.Tasks.Parallel.For%2A> und <xref:System.Threading.Tasks.Parallel.ForEach%2A> parallele Schleifen für Daten erstellen.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-342">Describes how to use <xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> to create parallel loops over data.</span></span>|
|[<span data-ttu-id="e3eb1-343">Parallele Programmierung</span><span class="sxs-lookup"><span data-stu-id="e3eb1-343">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)|<span data-ttu-id="e3eb1-344">Der Knoten auf oberster Ebene für die parallele .NET Framework-Programmierung.</span><span class="sxs-lookup"><span data-stu-id="e3eb1-344">Top level node for .NET Framework parallel programming.</span></span>|

## <a name="see-also"></a><span data-ttu-id="e3eb1-345">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="e3eb1-345">See also</span></span>

- [<span data-ttu-id="e3eb1-346">Parallele Programmierung</span><span class="sxs-lookup"><span data-stu-id="e3eb1-346">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="e3eb1-347">Beispiele für die parallele Programmierung mit .NET Core und .NET Standard</span><span class="sxs-lookup"><span data-stu-id="e3eb1-347">Samples for Parallel Programming with the .NET Core & .NET Standard</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
