---
title: Funktionale Programmierung und Imperative Programmierung
ms.date: 07/20/2015
ms.assetid: 6a1f3b57-00e6-447d-9906-74c7c4d5d85c
ms.openlocfilehash: 0090761dc07218673e1e0299951530d5a4763ffe
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 06/04/2020
ms.locfileid: "84364798"
---
# <a name="functional-programming-vs-imperative-programming-visual-basic"></a><span data-ttu-id="ee336-102">Funktionale Programmierung im Vergleich zu imperativer Programmierung (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ee336-102">Functional Programming vs. Imperative Programming (Visual Basic)</span></span>
<span data-ttu-id="ee336-103">In diesem Thema werden die Gemeinsamkeiten und die Unterschiede der funktionalen Programmierung und der herkömmlichen imperativen (prozeduralen) Programmierung erläutert.</span><span class="sxs-lookup"><span data-stu-id="ee336-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="ee336-104">Funktionale Programmierung und Imperative Programmierung</span><span class="sxs-lookup"><span data-stu-id="ee336-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="ee336-105">Explizite Aufgabe der *funktionalen Programmierung* ist die Unterstützung eines reinen funktionalen Ansatzes bei der Problemlösung.</span><span class="sxs-lookup"><span data-stu-id="ee336-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="ee336-106">Die funktionale Programmierung ist eine Form der *deklarativen Programmierung*.</span><span class="sxs-lookup"><span data-stu-id="ee336-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="ee336-107">Im Unterschied dazu unterstützen die meisten normalen Programmiersprachen, darunter auch OOP-Sprachen wie C#, Visual Basic, C++ und Java, in erster Linie die *imperative* (prozedurale) Programmierung.</span><span class="sxs-lookup"><span data-stu-id="ee336-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="ee336-108">Beim imperativen Ansatz schreibt ein Entwickler Code, der detailliert die Schritte beschreibt, die der Computer zur Erfüllung der Aufgabe ausführen muss.</span><span class="sxs-lookup"><span data-stu-id="ee336-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="ee336-109">Diese Form der Programmierung wird mitunter auch als *algorithmische* Programmierung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ee336-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="ee336-110">Beim funktionalen Ansatz hingegen wird das Problem als Satz von auszuführenden Funktionen formuliert.</span><span class="sxs-lookup"><span data-stu-id="ee336-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="ee336-111">Sie definieren sorgfältig, was für jede Funktion eingegeben wird und was die jeweilige Funktion zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ee336-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="ee336-112">In der folgenden Tabelle werden einige der allgemeinen Unterschiede zwischen diesen beiden Ansätzen beschrieben:</span><span class="sxs-lookup"><span data-stu-id="ee336-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="ee336-113">Merkmal</span><span class="sxs-lookup"><span data-stu-id="ee336-113">Characteristic</span></span>|<span data-ttu-id="ee336-114">Imperativer Ansatz</span><span class="sxs-lookup"><span data-stu-id="ee336-114">Imperative approach</span></span>|<span data-ttu-id="ee336-115">Funktionaler Ansatz</span><span class="sxs-lookup"><span data-stu-id="ee336-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="ee336-116">Schwerpunkt bei der Programmierung</span><span class="sxs-lookup"><span data-stu-id="ee336-116">Programmer focus</span></span>|<span data-ttu-id="ee336-117">Art und Weise der Ausführung von Aufgaben (Algorithmen) und der Überwachung von Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="ee336-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="ee336-118">Art der gewünschten Informationen und der erforderlichen Transformationen</span><span class="sxs-lookup"><span data-stu-id="ee336-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="ee336-119">Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="ee336-119">State changes</span></span>|<span data-ttu-id="ee336-120">wichtig</span><span class="sxs-lookup"><span data-stu-id="ee336-120">Important.</span></span>|<span data-ttu-id="ee336-121">nicht existent</span><span class="sxs-lookup"><span data-stu-id="ee336-121">Non-existent.</span></span>|  
|<span data-ttu-id="ee336-122">Reihenfolge der Ausführung</span><span class="sxs-lookup"><span data-stu-id="ee336-122">Order of execution</span></span>|<span data-ttu-id="ee336-123">wichtig</span><span class="sxs-lookup"><span data-stu-id="ee336-123">Important.</span></span>|<span data-ttu-id="ee336-124">weniger wichtig</span><span class="sxs-lookup"><span data-stu-id="ee336-124">Low importance.</span></span>|  
|<span data-ttu-id="ee336-125">Primäre Datenflusskontrolle</span><span class="sxs-lookup"><span data-stu-id="ee336-125">Primary flow control</span></span>|<span data-ttu-id="ee336-126">Schleifen, Bedingungen und Funktions- (Methoden-)Aufrufe</span><span class="sxs-lookup"><span data-stu-id="ee336-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="ee336-127">Funktionsaufrufe, einschließlich Rekursion</span><span class="sxs-lookup"><span data-stu-id="ee336-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="ee336-128">Primäre Manipulationseinheit</span><span class="sxs-lookup"><span data-stu-id="ee336-128">Primary manipulation unit</span></span>|<span data-ttu-id="ee336-129">Instanzen von Strukturen oder Klassen</span><span class="sxs-lookup"><span data-stu-id="ee336-129">Instances of structures or classes.</span></span>|<span data-ttu-id="ee336-130">Funktionen als erstklassige Objekte und Datensammlungen</span><span class="sxs-lookup"><span data-stu-id="ee336-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="ee336-131">Die meisten Sprachen unterstützen zwar ein bestimmtes Programmierparadigma, viele allgemeine Sprachen sind aber ausreichend flexibel, um mehrere Paradigmen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ee336-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="ee336-132">So können z. B. die meisten Sprachen, die Funktionszeiger enthalten, zur glaubwürdigen Unterstützung der funktionalen Programmierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ee336-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="ee336-133">Darüber hinaus enthält Visual Basic explizite Spracherweiterungen zur Unterstützung der funktionalen Programmierung, einschließlich Lambda-Ausdrücken und Typrückschluss.</span><span class="sxs-lookup"><span data-stu-id="ee336-133">Furthermore, Visual Basic includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="ee336-134">Eine Form der deklarativen, funktionalen Programmierung ist die LINQ-Technologie.</span><span class="sxs-lookup"><span data-stu-id="ee336-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="ee336-135">Funktionale Programmierung mit XSLT</span><span class="sxs-lookup"><span data-stu-id="ee336-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="ee336-136">Viele XSLT-Entwickler sind mit dem reinen funktionalen Ansatz vertraut.</span><span class="sxs-lookup"><span data-stu-id="ee336-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="ee336-137">Der effektivste Weg bei der Entwicklung eines XSLT-Stylesheets besteht darin, jede Vorlage als isolierte, zusammensetzbare Transformation zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="ee336-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="ee336-138">Die Reihenfolge der Ausführung ist dabei ohne jede Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="ee336-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="ee336-139">XSLT lässt keine Nebenwirkungen zu (lediglich die Escapemechanismen für die Ausführung von prozeduralem Code können Nebenwirkungen mit sich bringen, die zu funktionaler Unreinheit führen).</span><span class="sxs-lookup"><span data-stu-id="ee336-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="ee336-140">XSLT ist zwar ein wirksames Tool, dennoch sind einige seiner Eigenschaften nicht optimal.</span><span class="sxs-lookup"><span data-stu-id="ee336-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="ee336-141">So führt z. B. das Ausdrücken von Programmierkonstrukten in XML dazu, dass Code relativ weitschweifig und damit schwierig zu unterhalten ist.</span><span class="sxs-lookup"><span data-stu-id="ee336-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="ee336-142">Auch die schwere Abhängigkeit von der Rekursion zur Flusssteuerung kann dazu führen, dass Code schwer lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="ee336-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="ee336-143">Weitere Informationen zu XSLT finden Sie unter [XSLT-Transformationen](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="ee336-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="ee336-144">Dennoch hat XSLT bewiesen, dass die Verwendung eines reinen funktionalen Ansatzes bei der Transformierung von XML von einer Form in eine andere sinnvoll ist.</span><span class="sxs-lookup"><span data-stu-id="ee336-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="ee336-145">Die reine funktionale Programmierung mit LINQ to XML ähnelt in vielerlei Hinsicht XSLT.</span><span class="sxs-lookup"><span data-stu-id="ee336-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="ee336-146">Mit den Programmierkonstrukten, die mit LINQ to XML und Visual Basic eingeführt wurden, können Sie jedoch reine funktionale Transformationen schreiben, die besser lesbar und verwalterbar sind als XSLT.</span><span class="sxs-lookup"><span data-stu-id="ee336-146">However, the programming constructs introduced by LINQ to XML and Visual Basic allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="ee336-147">Vorteile von reinen Funktionen</span><span class="sxs-lookup"><span data-stu-id="ee336-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="ee336-148">Der Hauptgrund für die Implementierung von funktionalen Transformationen als reinen Funktionen (Pure-Funktionen) besteht darin, dass reine Funktionen zusammenstellbar sind, d. h., sie sind in sich abgeschlossen und zustandslos.</span><span class="sxs-lookup"><span data-stu-id="ee336-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="ee336-149">Diese Eigenschaften bieten u. a. die folgenden Vorteile:</span><span class="sxs-lookup"><span data-stu-id="ee336-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="ee336-150">Bessere Lesbarkeit und Verwaltbarkeit:</span><span class="sxs-lookup"><span data-stu-id="ee336-150">Increased readability and maintainability.</span></span> <span data-ttu-id="ee336-151">Jede Funktion ist für die Erledigung einer bestimmten Aufgabe anhand ihrer Argumente vorgesehen,</span><span class="sxs-lookup"><span data-stu-id="ee336-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="ee336-152">ohne sich dabei auf einen externen Zustand zu verlassen.</span><span class="sxs-lookup"><span data-stu-id="ee336-152">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="ee336-153">Einfachere reiterative Entwicklung:</span><span class="sxs-lookup"><span data-stu-id="ee336-153">Easier reiterative development.</span></span> <span data-ttu-id="ee336-154">Da der Code einfacher umgestaltet werden kann, können Änderungen am Entwurf oft leichter implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="ee336-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="ee336-155">Nehmen wir z. B. an, Sie schreiben eine komplizierte Transformation und stellen dann fest, dass sich ein Teil des Codes in der Transformation mehrmals wiederholt.</span><span class="sxs-lookup"><span data-stu-id="ee336-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="ee336-156">Bei der Umgestaltung mit einer reinen Methode können Sie Ihre reine Methode ganz nach Belieben aufrufen, ohne auf irgendwelche Nebenwirkungen Rücksicht nehmen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="ee336-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="ee336-157">Einfacheres Testen und Debuggen:</span><span class="sxs-lookup"><span data-stu-id="ee336-157">Easier testing and debugging.</span></span> <span data-ttu-id="ee336-158">Da reine Funktionen einfacher in Isolation getestet werden können, können Sie Testcode schreiben, der die reine Funktion mit typischen Werten, gültigen Randfällen und ungültigen Randfällen aufruft.</span><span class="sxs-lookup"><span data-stu-id="ee336-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="ee336-159">Was müssen OOP-Entwickler beachten?</span><span class="sxs-lookup"><span data-stu-id="ee336-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="ee336-160">Bei der traditionellen objektorientierten Programmierung (OOP) verwenden die meisten Entwickler beim Programmieren den imperativen/prozeduralen Stil.</span><span class="sxs-lookup"><span data-stu-id="ee336-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="ee336-161">Für den Umstieg auf die Entwicklung in einem reinen funktionalen Stil müssen die Entwickler umdenken und ihre Herangehensweise an die Entwicklung ändern.</span><span class="sxs-lookup"><span data-stu-id="ee336-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="ee336-162">Zur Lösung von Problemen entwerfen OOP-Entwickler Klassenhierarchien, konzentrieren sich auf die richtige Kapselung und denken in Klassenvertragskategorien.</span><span class="sxs-lookup"><span data-stu-id="ee336-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="ee336-163">Im Vordergrund stehen das Verhalten und der Status von Objekttypen, und zu diesem Zweck werden Sprachfunktionen wie Klassen, Schnittstellen, Vererbung und Polymorphie bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="ee336-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="ee336-164">Dagegen werden die Berechnungsprobleme bei der funktionalen Programmierung als Übung für die Auswertung reiner funktionaler Transformationen von Datensammlungen angesehen.</span><span class="sxs-lookup"><span data-stu-id="ee336-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="ee336-165">Bei der funktionalen Programmierung werden Zustands- und änderbare Daten vermieden, stattdessen steht die Anwendung von Funktionen im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="ee336-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="ee336-166">Glücklicherweise erfordert Visual Basic nicht den vollständigen Sprung zur funktionalen Programmierung, da Sie sowohl imperative als auch funktionale Programmier Ansätze unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ee336-166">Fortunately, Visual Basic doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="ee336-167">Der Entwickler kann daher selbst entscheiden, welcher Ansatz für ein bestimmtes Szenario am geeignetsten ist.</span><span class="sxs-lookup"><span data-stu-id="ee336-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="ee336-168">Bei vielen Programme werden beide Ansätze häufig miteinander kombiniert.</span><span class="sxs-lookup"><span data-stu-id="ee336-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ee336-169">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="ee336-169">See also</span></span>

- [<span data-ttu-id="ee336-170">Einführung in reine funktionale Transformationen (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ee336-170">Introduction to Pure Functional Transformations (Visual Basic)</span></span>](introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="ee336-171">XSLT Transformations (XSLT-Transformationen)</span><span class="sxs-lookup"><span data-stu-id="ee336-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="ee336-172">Refactoring in reine Funktionen (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="ee336-172">Refactoring Into Pure Functions (Visual Basic)</span></span>](refactoring-into-pure-functions.md)
